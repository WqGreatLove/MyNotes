日报形式：
#185824：兼容模式下，启用禁用约束模块，当使用DISABLE VALIDATE禁用约束后，使用copy from可以导入数据，应报错
开始时间：2023-05-30
结束时间：2023-05-30
描述：完成copy from可以导入数据，DISABLE VALIDATE禁用约束

#185575：兼容模式下，启用禁用约束模块，当表唯一键（主键）被外键依赖时，uxdb可以禁用成功，oracle报错
开始时间：2023-05-30
结束时间：2023-05-31
描述：分析依赖关系调用

项目号：
JA0101661769202320100


报销流程：李悦
发票报销：王淼

我的个人邮箱：
w18220815019@163.com
密码：926474.wq

我的github信息：
github用户名/密码：
18700612420@163.com/926474.wq
MyNotes 分支用户名：
WqGreatLove
以下token不会过期：
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

资料查找网站：

阿里云：
https://developer.aliyun.com/

remine问题：邓杰、钱金龙


提交代码：
代码分支：
标准版：
dev/ver2.1.1.4_dev
安全版：
dev/ver2.1.0.4s_dev

重构版：
dev/ver2.1.1.4s_dev

对外支持分支：
support/#101817

分支命名：

我的分支feature/ver2.1.1.3_dev/#91139

feature/ver2.1.1.3_dev/#94056
bug/ver2.1.1.3_dev/#94937

bug/ver2.1.0.4s_dev/#101492

测试分支：dev/ver2.1.1.3_dev_merge_into

对外支持分支：
1、开发基版分支
support/#102593

2、提交分支
102680_zwj

代码提交：
redmine提交merge：

•Root Cause (Bug) or Purpose (RFE/Task): #177029:kylin4/arm环境编译db冲突报错
•Affected Area:
•Solution:
问题分析：
代码分支：
support/#125828
repmgr、uxmpp、ux_probackup编译存在冲突问题；

处理方案：
删除冗余定义变量，解决冲突问题；

•Recommended Test Area:
•Reviewed by: 高升明
•Approved by: 高升明
•svn checkin rev Number：
2a299215fc3b8b05f04ca085dc12404a287834b0
•Affected files：3
uxdb-2.1-upper/contrib/repmgr/repmgr-client-global.h
uxdb-2.1-upper/contrib/uxmpp/src/include/distributed/uxmpp_nodes.h
uxdb-2.1-upper/src/bin/ux_probackup/src/backup.c


Unit test: 测试编译通过
测试步骤：
SELECT
    FORMAT(111111, 2),
	FORMAT(111111., 2),
    FORMAT(111111.111, 2),
    FORMAT(111111.111, 0),
    FORMAT('111111', 2),
	FORMAT(12332.123446,4),
	FORMAT(12332.123456,4),
    FORMAT(NULL, 2),
	FORMAT(12332.123456,4,'de_DE'),
	FORMAT(12332.123456,4,'en_US');

测试结果：






问题单记录：
问题分析、处理方案、验证结果、提交记录都要在单子上体现



uxdb项目：

1、项目目的：制作产品安全

2、熟悉项目框架
（1）通过微博、Google、百度、PDSN、等找到程序的体系结构，找到星星点点资料（很重要）

（2）[community | standard | professional | enterprise]

CE：社区版
EE：企业版
SE：标准版



3、项目组成

uxdb主要由DB以及DFS组成
DFS：分布式文件系统（Distributed file system），DFS由DIR、MRC和OSD三个模块组成，以Volume（卷）的形式管理文件
DIR：目录服务器，用来记录集群中可用的元服务器和数据存储器的状态，可用的Volume信息，mapping OSD/MRC的URL到服务。
MRC：元服务器，用来记录集群的基本信息，volume信息，文件对OSD的索引以及文件属性（大小，路径，所有者，访问Mask，时间信息等）和replication的信息
OSD：数据服务器，用来存储文件内容。
Volume：提供层级化的名称空间，相当于逻辑的卷。在电脑中， volume（文件集）是一个可辨认的数据存储（storage）单元。

4、配置文件

pg_hba.conf 配置详解：
https://blog.csdn.net/yaoqiancuo3276/article/details/80404883
trust：表示无需密码

/********************************************work*******************************************/

1、svn://192.29.1.2/svn/uxdb/11.开发/05.计划/2020/ver2.1.0.3/ver2.1.0.3 db自测基本用例.xls 组内自测



uxdb工作事务：
redmine:
http://cd.uxsino.com:19503/my/page
用户名/密码：wang_qi/1413014046.wq
uxdb绩效：
http://cd.uxsino.com:2090/#/login
用户名/密码：wang_qi/12082499

postgres手册：
http://postgres.cn/docs/12/ecpg-develop.html



数据库机器：
mysql

mysql使用：
https://blog.csdn.net/weixin_43268590/article/details/123776118
1、mysql数据库安装
安装mariadb：
yum install mariadb-devel
yum install mariadb

yum install mariadb-server

启动mysql数据库：
systemctl start mariadb.service
登录数据库：
mysql: (192.71.0.243 root/123456)
  cd /home/mysql/mysql157/bin
  ./mysql -uroot -p 123456		//登陆后，使用mysql数据库: use mysql

rpm安装方式：
http://c.biancheng.net/view/7616.html
在下面链接安装以下rpm：
https://dev.mysql.com/downloads/mysql/
mysql-community-common-5.7.29-1.el7.x86_64.rpm
mysql-community-libs-5.7.29-1.el7.x86_64.rpm
mysql-community-client-5.7.29-1.el7.x86_64.rpm
mysql-community-server-5.7.29-1.el7.x86_64.rpm
mysql-community-devel-5.7.29-1.el7.x86_64.rpm

使用以下方式启动数据库：
sudo systemctl start mysqld

mysql初始化数据库：
mysqld --initialize --user=mysql --datadir=/mnt/sdc/mysql

登录数据库：
查看初始密码（如果没有初始密码，直接输入用户名 root 登录即可）：
cat /var/log/mysqld.log | grep 'temporary password is generated'
本次初始密码：
uYu:cWess7/4

2、查看mysql版本
mysql -V


uxdb通过fdw访问mysql数据库：
步骤如下：
1、新建mysql_fdw插件
create extension mysql_fdw;

2、创建MySQL服务器定义(mysql库ip和端口)。
CREATE SERVER mysql_server FOREIGN DATA WRAPPER mysql_fdw OPTIONS (host '192.71.0.243', port '3107');

3、创建用户映射，将MySQL服务器定义映射到uxdb的某个用户上，将来使用这个用户访问MySQL的数据。
CREATE USER MAPPING FOR uxdb SERVER mysql_server OPTIONS (username 'root', password '123456');

4、使用上一步骤的uxdb用户创建MySQL的外部表（在mysql创建表test1）。
登录mysql：
使用root用户创建表test1(mysql 必须带主键)：
create table test1 (name text primary key, age int);

uxdb执行创建外部表
CREATE FOREIGN TABLE tkb_test (name text, age int) server mysql_server options (dbname 'mysql', table_name 'test1');
5、通过uxdb可以访问mysql的外部表
Insert into tkb_test values ('111',1);
Insert into tkb_test values ('222',2);
select * from tkb_test;


oracle_fdw:
Oracle的外部连接
Oracle机器上的
连接到默认数据库
sqlplus / as sysdba
 create user C##ora_tkb1 identified by "123456";
grant dba,resource,connect to C##ora_tkb1;
切换到定义的用户
conn C##ora_tkb
create table test_tab(id int,name varchar(100));
select * from test_tab;

uxdb数据库上执行
create extension oracle_fdw;
create server osdba_fdw foreign data wrapper oracle_fdw options (dbserver '//192.71.0.244:1521/orcl');
CREATE USER MAPPING FOR uxdb SERVER osdba_fdw OPTIONS (user 'C##ora_tkb', password '123456');
CREATE  FOREIGN TABLE "test_tab" (id int,name varchar(100)) SERVER osdba_fdw OPTIONS (table 'TEST_TAB');
select * from test_tab;
INSERT INTO test_tab select generate_series(1,10),'bb';
select * from test_tab limit 5,10;



  启动服务：
  1./etc/init.d/mysqld start 
  2. ./mysqld --defaults-file=/home/mysql/mysql57/conf/my.cnf --initialize --user=mysql --basedir=/home/mysql/mysql57 --datadir=/home/mysql/mysql57/data
ORACLE:(192.71.0.244 oracle/123456)
  以oracle用户登录服务器，
  执行sqlplus / as sysdba进入管理员模式
达梦:(192.71.0.245 root/123456)
  cd /dm8/bin 
  启动服务：./DmServiceTest start （或./DmServiceDMSERVER restart）
  启动客户端：./disql

dm登录：
进入bin目录，执行./disql
用户名：sysdba
密码：123456789(或者默认)

金仓:(192.72.1.122 root/123456)
  cd /opt/Kingbase/ES/V8/Server/bin 
  创建实例：./initdb -W -D testdb
  启动服务端：./sys_ctl -D testdb -l logfile start
   目录：/opt/Kingbase/ES/V8/ClientTools/bin 
  启动客户端：./ksql -d test -p 54328


2020-06-15

一、工作记录
redmine:
1、我的密码
redmine/git/svn 账号/密码:1413014046.wq
wangqi/1qaz!QAZ

2、开发设计模板
http://cd.uxsino.com:19503/projects/dev_uxdb/wiki/%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3%E6%A8%A1%E6%9D%BF%EF%BC%88%E5%85%BC%E5%AE%B9%E5%8A%9F%E8%83%BD%EF%BC%89

我的服务号：
服务 #80869

云账号:
云账号密码：
账号是wang_qi  密码：1413014046.wq
云网址：
http://111.204.26.202:10103/learning/hrux/user/hruxHome/index.html

svn://192.30.1.2/svn/uxdb/40.部门管理/03.产品服务部/01.年度计划/03.2022年/01.部门计划/产品服务部计划_2022年.xlsx

版本云存放路径：
rdshare/reading/rdshare/xian/release/uxdb

1、Nuxsql云路径：
http://cd.uxsino.com:24080/apps/files/?dir=/rdshare/reading/rdshare/xian/release/uxdb/ver2.1.1.4/release/04%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Windows&fileid=3039523

2、版本云存放路径：
/rdshare/reading/rdshare/xian/release/uxdb/ver2.1.1.4/release

3、Npgsql github链接：
https://github.com/npgsql/npgsql/tree/main/src

密码：
vpn：

北京vpn：
VPN 
账号 tianjinyang
        密码 tianjinyang@123
gaomingsheng
gaomingsheng@123

工时登记：
密码：12345678

西安vpn：
密码：
wangqi!@#

云：
用户名：wangqi
密码：
1413014046.wQ

绩效考核：
密码：12082499

绩效考核+工时：
http://cd.uxsino.com:2090/#/login
账号：wang_qi
密码：12082499

ci机器：

windows：
ci界面登录：
用户名/密码：uxdb/123456
ci机器登录
windows CI 117.34.70.110:63389 用户密码：uxdb / uxdb@123

ci打包链接：
http://117.34.70.110:58085/job/uxdb-package/

linux：

CI机器登录：
ssh uxdb@117.34.70.110 -p 60052
Uxdb#ci


2、我的ip

192.29.0.XX  81--85  255.255.254.0  192.29.1.1  192.29.1.1

用户名  IPv4前缀  IP段  掩码  网关  DNS

新办公场地：
IP段  掩码  网关  DNS
192.71.0.136~192.71.0.140
255.255.254.0
192.71.0.1
218.30.19.40

svn和ftp：
192.30.1.2

3、我的邮箱

wang_qi@uxsino.com
密码：1413014046.whj

4、git链接
svn地址：svn://192.29.1.2/svn/uxdb uxdb 1qaz!QAZ						//工具路径
git地址：git clone https://222.212.87.87:10943/db/uxdb-ng.git			//版本代码路径
https://cd.uxsino.com:10943/db/uxdb-ng
ftp地址：ftp://192.30.1.2/tools/VM/centoOS/    uxsino  123456
ftp地址：sftp://192.29.2.229   uxsino  123456							//工具路径与上面svn作用一样


wins CI机器：
117.34.70.110:63389
密码：
uxdb/uxdb@123




sftp地址：Uxsino_1918													//版本代码与git作用一致
客户端FileZilla
协议：sftp
主机：222.212.87.87
端口号：40232
用户名：rdshare
密码： Uxsino_KZoc8j5E

对外支持：

1、对外支持项目编号：
http://192.30.1.2:8090/pages/viewpage.action?pageId=11501920


项目工作：
河南移动：A01097617202210156
中防生态：SP202203310011
沈抚项目：A02403729202110949
9601项目：A01021769202210515
陕西军民融合信创项目: A02903359202210715
山西临汾xc：MA35103088202120147
中船WRT项目:
重庆传晟:
云上贵州：A851142725202211194
旋极军工项目(#129384)：JA01070578202220026
军工二十四套数据库项目:JA01070578202120039
交通委 A01036272202210173

XX车型号数据库
JA01070578202220026

3.28-4.2
1、准备研发部培训										12h
2、#135974 河南移动中标项目支持，rowid转bigint转换		4h
3、#138262 中防生态适配打包								16h		
4、#136367 dbms_utility.get_hash_value功能支持			4h
5、#138648 沈抚项目实施内部群							4h		
6、#138851 trunc、decode、nvl、mod等函数支持			8h		


4.6-4.8
1、#138851 add_months、months_between、last_day、to_char等函数支持		8h
2、uxpool研发部培训准备													8h
3、#135974:listagg、grouping_id、regexp_like、pg_backend_pid、chartorowid、userenv等函数功能支持
																	8h

虚拟机存放位置：
1.2上/tools/VM/uxdb：
linux虚拟机：CentOS 64 位7.4_UXDB_DEV.rar
windows：

版本存放位置：
/opt/rdshare/reading/rdshare/xian/release/uxdb/

流程规范参考地址:
http://cd.uxsino.com:19503/projects/dev_uxdb/wiki/%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83

postgre资料：

1、uxdb文档
http://192.30.3.136:3000/		//版本说明


2、pg查找资料

pg相关结构体关联源码查询
https://doxygen.postgresql.org/

pg学习资料：
1）、学习笔记
https://zhmin.github.io/archives/page/3/

2）、数据内核

http://mysql.taobao.org/monthly/

3、pg知识点
autoprewarm功能：
1）定时将内存中的数据写入autoprewarm.blocks文件中，定时时间pg_prewarm.autoprewarm_interval默认300s；
2）执行stop时，autoprewarm进程会将内存数据写入autoprewarm.blocks文件中；

pg内核：

1、PostgreSQL 基于heap表 存储引擎实现原理
https://zhuanlan.zhihu.com/p/557482910


2020-06-16

1、source insight

（1）、搜索某个变量、宏的方法


问题：

2、uxdb安装
Please input uxdb user[uxdb]:uxdb
Do you want to install UXFS?[Y/N]:
Please input UXFS install dir[/home/uxdb/uxdbinstall]:
UXFS will be installed to [/home/uxdb/uxdbinstall/uxfs].
记录了398729+1 的读入
记录了398729+1 的写出
204149704字节(204 MB)已复制，8.04415 秒，25.4 MB/秒
UXFS installed completely.
Do you want to install DBSQL?[Y/N]:
Please input DBSQL install dir[/home/uxdb/uxdbinstall]:
DBSQL will be installed to [/home/uxdb/uxdbinstall/dbsql].
[sudo] uxdb 的密码：
记录了398729+1 的读入
记录了398729+1 的写出
204149704字节(204 MB)已复制，9.13671 秒，22.3 MB/秒
DBSQL installed completely.
installing deploy tools ... done
installing license tools ... done
configuring environment variable of uxdb ... done
Install UXDB success!


2020-06-17

1、专业名词缩写

uxdb：
uxfs:

osd：
DIR：

2020-06-19

1、安装DB和DFS文档
编译安装DB和DFS gdb调试总结--李佩维.docx

license：
编译启动DB：
进入uxdb-2.0 目录，执行 ./build.sh –-release=enterprise –-version=2.1.0.3 –-liense=internal –-debug=yes
编译license代码，生成license生成工具：
uxdb-ng/uxdb-tools/UXDBLicense-encoder/UxdbLicense
uxdb-ng/install/linux/AutoGetLicenseInfo

2、进入uxdb安装目录下的license目录

修改IpAdd.ini文件		文件路径：/home/uxdb/uxdbinstall/license

./GetUserInfo.sh --version_type=enterprise --version=2.1.1.3
3、将UxdbLicense.json拷贝到 /home/uxdb/uxdbinstall/encryptLicense/encryptor/config/ 目 录下；
4、在 /home/uxdb/uxdbinstall/encryptLicense目录下执行 ./UxdbLicense ；
5、将 /home/uxdb/uxdbinstall/encryptLicense/encryptor/output目录下生成的uxdb.lic 拷贝 到 /home/uxdb/uxdbinstall/license/ 目录下即可。


二、初始化本地集群			//D:\old\svn\10.团队建设\01.新员工\01.总结心得\Uxdb安装、配置、使用--张栋梁.docx

进入DB目录（/home/uxdb/uxdbinstall/dbsql/bin），执行


./initdb -W -D uxdbtest
初始化本地集群

前台启动集群：

./uxdb -D uxdbtest
后台启动数据库：
./ux_ctl -D uxdbtest  start

查看server状态
./ux_ctl -D uxdbtest1 status

访问本地集群
./uxsql -d uxdb -U uxdb

关闭集群：
./ux_ctl -D uxdbtest1 stop

三、分布式集群

1、启动DFS和创建volume
创建volume：./mkfs.xtreemfs localhost/demo
//文档：D:\10.团队建设\01.新员工\01.总结心得\uxdb安装和编译-常鑫.docx

王若静

2、进入：/home/uxdb/uxdbinstall/dbsql/bin初始化集群
./initdb -W -Z -D test02

3、设置分布式集群端口
./uxsql -p 5455

4、启动分布式集群
./uxdb -Z -B 1024 -N 100 -p 5455 -D test02
5、查看DB server状态
./ux_ctl -Z -D test02 status

6、访问分布式集群
./uxsql -d uxdb -U uxdb



2020-06-23

1、
产品到期时间是可以手动修改的，在UxdbLicense.json中为ExpiredDate字段。目前标准版是10年，企业版是20年，专业版是30年。这些时间可以由产品序列号管理员根据需要手动修改调整。

2、生成器和json文件区别


2020-06-29

一、shell脚本中if语句用法：

Shell中判断语句if中-z至-d的意思
[ -a FILE ] 如果 FILE 存在则为真。

[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。

[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。

[ -d FILE ] 如果 FILE 存在且是一个目录则为真。

[ -e FILE ] 如果 FILE 存在则为真。

[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。

[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。

[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。

[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。

[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。

[ -r FILE ] 如果 FILE 存在且是可读的则为真。

[ -s FILE ] 如果 FILE 存在且大小不为0则为真。

[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。

[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。

[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。

[ -x FILE ] 如果 FILE 存在且是可执行的则为真。

[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。

[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。

[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。

[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。

[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。

[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。

[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。

[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。

二、linux下使用tar与openssl进行加解密

https://blog.csdn.net/libinbin_1014/article/details/50386016

三、sudo -su和sudo -s
sudo su 和 sudo -s都是切换到root用户，不同的是：

sudo su 环境用的是目标用户(root)的环境

sudo -s 环境用的是当前用户本身的环境

2020-07-01

1、守护进程：postmaste
服务器主进程PostmasterMain（守护进程入口函数）
源码位置：uxdb-2.0\src\backend\main\main.c

2、服务进程：Postgres
入口函数：PostgresMain（UxdbMain）
源码位置：uxdb--2.0\src\backend\tcop

3、辅助进程：系统日志进程SysLogger ，后台写进程bgWriter，预写式日志写进程WalWriter，预写式日志归档进程pg_archive,系统自动清理进程AutoVacuum,统计数据收集进程pg_state

logger Progress
功能：输出数据库运行过程中的日志信息
函数：SysLogger_Start（SysLoggerMain）
源码位置：src\backend\uxmaster\syslogger.c

Checkpointer Progress（检查点进程）
功能：数据库恢复，如果没有检查点操作，一旦系统由于断电等原因崩溃，数据库系统无法确切地知道哪些更新已经写入磁盘，做了永久性确认；哪些更新还没有写入磁盘，需要重新执行或者回退。这时数据库系统的恢复需要使用系统运行以来的所有日志文件，整个恢复过程复杂而漫长。

函数：StartCheckpointer
源码位置：uxdb-2.0\src\backend\main\main.c

Bg writer Progress
功能：对共享缓冲区的写操作进行统一的管理（管理共享缓冲区的数据，把脏数据刷出到磁盘）
函数：StartBackgroundWriter
源码位置：src\backend\uxmaster\uxmaster.c

wal writer Progress
功能：系统崩溃时，最近事物能够得到恢复（帮助恢复系统，先写日志后写数据，以便恢复数据）
fsync:（数据的一致性）
该参数直接控制日志是否先写入磁盘。默认值是ON(先写入)。开启该值时表明，更新数据写入磁盘时系统必须等待WAL的写入完成。
synchronous_commit:（事务的完整性）
参数表明是否等待WAL完成后才返回给用户事务的状态信息。默认值是ON，表明必须等待WAL完成后才返回事务状态信息。
函数：
|_ PostmasterMain()
	|_ ServerLoop()
		|_ StartWalWriter ()

autovacuum launcher Progress（用于释放系统空间）
功能：自动执行VACUUM和ANALYZE命令，释放空间
源码位置：
|_ main()
	|_ PostmasterMain()
		|_ ServerLoop()
			|_StartAutoVacLauncher()

stats collector Progress（数据库的统计）
功能：数据库统计信息收集器，专门负责收集数据库系统运行中的统计，如表的增删改次数
源码位置：
|_ main()
	|_ PostmasterMain()
		|_ ServerLoop()
			|_ uxstat_start ()


2020-07-03

git命令

1、将状态改变的代码提交至缓存
git add + 文件
git add -u + 路径：将修改过的被跟踪代码提交缓存
git add -A + 路径: 将修改过的未被跟踪的代码提交至缓存

2、git status			//显示所有修改记录

3、生成patch
git format-patch HEAD^ 　　　　　　　　　　　　　   #生成最近的1次commit的patch

指定commit的patch：
git format-patch -1 + commit号

4、打patch，通过git apply或git am
https://www.cnblogs.com/ArsenalfanInECNU/p/8931377.html
git apply和git am区别：git apply不会还原add和commit信息，git am会
git apply --stat 0001-limit-log-function.patch   　　　　  # 查看patch的情况
git apply --check 0001-limit-log-function.patch   　　　  # 检查patch是否能够打上，如果没有任何
如果没有问题，执行：
git apply 0001-limit-log-function.patch

git am 0001-limit-log-function.patch
git am --signoff 0001-limit-log-function.patch                  # 添加-s或者--signoff，还可以把自己的名字添加为signed off by信息，作用是注明打patch的人是谁，因为有时打patch的人并不是patch的作者
git am --abort                                                                   # 当git am失败时，用以将已经在am过程中打上的patch废弃掉(比如有三个patch，打到第三个patch时有冲突，那么这条命令会把打上的前两个patch丢弃掉，返回没有打patch的状态)
git am --resolved                                                             #当git am失败，解决完冲突后，这条命令会接着打patch
如果发生冲突，通过下面方式修改：
https://www.cnblogs.com/ArsenalfanInECNU/p/8931377.html

5、合并其他分支的commit到本地分支
git cherry-pick  0128660c08e325d410cb845616af355c0c19c6fe

然后就将A分支的某个commit合并到了B分支了

6、git记录用户名和密码：

git config --global credential.helper store

7、git push

git push <远程主机名> <本地分支名> <远程分支名>
将本地分支推到远端分支：
git push origin dbg_lichen_star:dbg_lichen_star				//dbg_lichen_star:dbg_lichen_star：本地：远端（可以随意起）

删除远端分支名：
git push origin --delete + 分支名

git常见问题
1：误将代码提交到缓存中（利用 git add 命令误将代码提交的缓存中）
解决办法：利用 git reset 命令将撤回缓存中的代码。

2：误将代码提交到本地仓库（利用 git commit 命令误将代码提交到本地仓库）
解决办法：
git reset —hard + 版本号
彻底回退到某个版本，本地的代码也会改变上一个版本内容。

8、git记住用户名密码、清除用户名密码

记住密码：
git config --global credential.helper store
清除密码：
git config --global --unset credential.helper


9、跟踪分支
1）、设置跟踪分支：
git branch --set-upstream-to=origin/support/#139826

10、ssl问题
git config http.sslVerify "false"


linux命令：

1、scp命令
将id_rsa.pub拷贝并重命名为id_rsa.pub.slave
scp id_rsa.pub root@192.21.0.171:/home/uxdb/.ssh/id_rsa.pub.slave

2、重启ssh命令
service sshd restart

3、查看文件大小命令
ls -lh	#该命令以更接近文件大小的单位显示文件的大小。在Linux中显示文件大小时，通常的做法是使用“ls -I”，这是文件的大小

du -h –max-depth=1 *			//查找各个文件的大小
du -sh							//显示当前目录总大小

4、
linux上windows文件结尾符转换
sed -e 's/.$//' results/privileges.out > 1.out

5、vi显示行尾符
set invlist

6、makefile打印

打印top_builddir变量：
$(warning $(top_builddir))
打印字符串：
$(warning "------------------------------------------------------")

7、查看系统版本
cat /proc/version

8、查看MD5
md5sum uxsinodb-2.1-1.nfs.x86_64.rpm

9、查看cpu执行占有率

执行nmon命令后，
输入D查看

10、
systemctl status numad

11、sed命令
1）替换某个文件某个字符串
sudo sed -i "s/被替换字串/替换字串/g" + 文件名
eg：含有特殊字符的需要转义，例如$
sudo sed -i "s/\$13/\'1\'/g" + mean_time_g1ms_10ms.text

12、查看实时网速
sar -n DEV 2 100  # 查看网卡流量，每秒输出一次，输出100次。

13、

gdb调试：

1）、查看指针内存地址值
第一个x：查看
b：以单字节查看：b表示单字节，h表示双字节，w表示四字节，g表示八字节
20：表示显示20个字节
eg：
x/20b + 变量		//默认按10进制显示，参数使用d

2）、

set args -n -d > uxpool.log 2>&1
屏蔽信号处理，例如屏蔽SIGUSR1信号，让程序不中断
handle SIGUSR1 nostop
b trigger_failover_command

3）
gdb查看汇编（产生core时，在gdb命令行输入）：
layout asm

4）gdb调试打印内存上下文
gdb调试进程，sql执行完成后，
在gdb窗口执行以下命令打印：
print MemoryContextStats(TopMemoryContext)
相关链接：
https://www.modb.pro/db/486292

5）查看sql详细日志：
打开guc参数
debug_print_parse


14、系统命令
centoes系统：
查看已安装包：
sudo yum list installed|grep readline
查看可安装的包：
yum list|grep gssapi

ubuntu系统：
查看已安装包：
apt list --installed | grep readline
或者
dpkg --list|grep gssapi
查看可安装包：
apt list|grep uuid
卸载安装包：
sudo apt remove libxslt1.1

15、配置动态库加载
方法一：
以下文件目录创建conf文件，文件配置加载库路径（需要加载的库路径），然后使用ldconfig /etc/ld.so.conf.d/加载该路径；
/etc/ld.so.conf.d/
方法二：使用patchelf --set-rpath			//动态库在/home/uxdb/uxdbinstall/dbsql/lib/gmssl/lib路径下：
patchelf --set-rpath /home/uxdb/uxdbinstall/dbsql/lib/gmssl/lib /home/uxdb/uxdbinstall/dbsql/lib/gmssl/bin/gmssl
方法三：打开/etc/ld.so.conf，将需要加载的库路径加入该文件，然后执行sudo ldconfig即可



16、查看磁盘io读写速度

iostat -x 3

17、绑定cpu使用命令numactl：

使用numactl -C 0-63启动集群：
numactl -C 0-63 ./ux_ctl -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=1 -p 5432" start
numactl -C 0-63 ./ux_ctl -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=2 -p 5433" start

taskset -c 0-63 ./ux_ctl -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=1 -p 5432" start

18、查看进程占用内存情况
smem -k | grep -e [P]ID -e 6197			//6197为进程id

2020-11-16

hao_xingang@uxsino.com

19、神威国产系统
文件编辑，鼠标不能拷贝
解决方法：打开文件，进入编辑模式，输入以下命令：
set mouse-=a

20、dpkg命令
dpkg -i + deb包		//安装命令
dpkg -l |grep + 包名关键字			//查看已安装包
sudo dpkg -r +包名关键字			//卸载软件包，保留配置信息
sudo dpkg -P +包名关键字			//卸载软件包，不保留配置



21、shell脚本

1）、调试脚本：shell脚本开头添加set -x
2）、错误检查：set -e 开启错误检查

22、
重载service服务：
sudo systemctl daemon-reload

指定用户执行脚本
sudo -u uxdb sh /opt/uxsinodb-2.1/bin/configure.sh start

init.d启用禁用服务：
sudo update-rc.d uxinodb defaults
sudo update-rc.d uxinodb remove
控制服务的启动、停止和重启：
sudo service uxinodb start
sudo service uxinodb stop
sudo service uxinodb restart

23、查看符号定义：

nm -C <dynamic_library>
objdump -T <dynamic_library>
readelf -s <dynamic_library>

24、windows查看文件MD5命令：

certutil -hashfile C:\Path\To\Your\File.txt MD5








2020-07-08

uxdb使用zpack打包及视图化安装
1、启动uxdb：systemctl start uxdb

查看uxdb状态：systemctl status uxdb
登录uxdb：	uxsql -d uxdb

关闭服务：systemctl stop uxdb

2、log文件：在/home/test/uxdbinstall/dbsql/data/dbhome_1/ux_log/startup.log

3、所属用户：chown -R test encryptLicense
修改用户组：chgrp -R test encryptLicense

```
postgres调试：
一、打开guc参数
（1）日志中打印sql执行时间
log_min_duration_statement





```

2020-07-09
同步代码到服务器：
https://blog.csdn.net/qq_39187019/article/details/90045064

2020-07-13

1、
CREATE DATABASE name
    [ [ WITH ] [ OWNER [=] user_name ]
           [ TEMPLATE [=] template ]
           [ ENCODING [=] encoding ]
           [ LC_COLLATE [=] lc_collate ]
           [ LC_CTYPE [=] lc_ctype ]
           [ TABLESPACE [=] tablespace_name ]
           [ ALLOW_CONNECTIONS [=] allowconn ]
           [ CONNECTION LIMIT [=] connlimit ]
           [ IS_TEMPLATE [=] istemplate ] ]

移除数据库：DROP DATABASE

2、CREATE DOMAIN

CREATE DOMAIN — 定义一个新的域

3、CREATE EXTENSION

CREATE EXTENSION — 安装一个扩展


2020-07-20

warning protobuf-2.5.0 or gtest-1.7.0 can not fuound,Please make sure it exists in the /Users/xyz/thirdyparty directory,and set the the environment variable THIRDPARTY_ROOT to the thirdyparty base directory before executing 'make',  e.g., export THIRDPARTY_ROOT=/Users/xyz/thirdyparty



2020-07-29

1、如何将linux代码编译成win32
sudo apt-get install mingw32
i586-mingw32msvc-cc main.c -o main.exe

2、linux下编译运行java代码
类名和文件名保持一致

javac -cp . HelloWorld.java
java -cp . HelloWorld
或者
javac *.java
java test



2020-08-03
工具配置：
1、vscode
排除文件：
*.po,*.out,*sql,*.html,*.md,*sgml,README,*.source

安装idea：
1、idea解码
https://blog.csdn.net/qq_43604667/article/details/98321517?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param

centos安装idea软件
http://www.mamicode.com/info-detail-2294728.html

2020-08-10

远端分支：
origin/dev/ver2.1.1.3_dev
ver2.1.1.3_dev

2020-08-19

1、select语句用于从数据库中选取数据
eg：select name,country FROM Websites;

2、CAST($1 AS text)		//将$1转化为文本

3、COUNT(*)：统计行数


./build.sh --release=enterprise  --version=2.1.1.2  --license=commercial
./build.sh --release=security  --version=2.1.0.3  --license=internal



support/#86836_merge
support/#86836_wbc

2020-08-25
*************rebrand***********
转换pg与uxsql
进入目录：
/home/uxdb/uxdb-ng/scripts/bash/rebrand
执行./rebrand.sh

2020-08-31

编译izpack源码

izpack编译：
/home/uxdb/uxdb-ng/install/izpack/izpack
mvn clean install
izpack使用：
/home/uxdb/uxdb-ng/install/izpack/izpack/izpack-dist/target
java -jar izpack-dist-5.1.4-SNAPSHOT.jar





git config --global user.name "wang_qi"
git config --global user.email "wang_qi@uxsino.com"

 wang_qi@uxsino.com
密码：Wang0519

2020-09-02
build：
编译debug版本
./build.sh -d -l internal


pgsql命令：

系统表：
数据字典

控制端sql命令：
create view v1 as select name from t1;		//创建视图

create schema repmgr；						//创建模式

insert into t1 select generate_series(1,10000),'a';			//循环插入10000行数据

explain (analyze,buffers) + sql语句							//输出执行时间

explain (analyze,buffers) MERGE INTO t2 A USING (select id,name from t1 B) C ON (A.id=C.id)
WHEN MATCHED THEN
UPDATE SET A.YEAR=C.YEAR

创建超级用户和密码：
CREATE ROLE kkxgd superuser PASSWORD '123' login;
CREATE ROLE test superuser PASSWORD '123' login;

创建数据库kkxgd：
create database kkxgd;
create database test;

切换用户：
\c - kkxgd

登录
./uxsql -U kkxgd -d kkxgd

恢复数据：
./ux_dump -U test -d test < /home/uxdb/wangqi/test_dump.sql

pg信任登录：初始化集群不需要密码
将-W 改为-Atrust

查看表名：
通过表明查看文件
./oid2name -t + tablename


grant命令：

执行计划命令：
explain (analyze true,buffers true) select * from emp1 where empno=7369 ;

通过explain (analyze true,buffers true)可以查看，从磁盘中读取了多少个数据块；

查看系统函数（查看系统函数名中含HASH的函数）：
select proname from ux_proc where proname like '%HASH%'

循环插入数据：

create table t1(id int);
insert into t1(id) select generate_series(1,10000);

create table t2(id int,b text);
insert into t2 select generate_series(1,10000), repeat(md5(random()::text),10);

循环插入多个字段数据：
insert into t2 select i,i||'aaa' from generate_series(1,100) i;

去重命令：
distinct

查看表磁盘文件：
select ux_relation_filepath('t1');

查找自上次使用 重置统计信息以来从未使用的索引，重置统计信息函数ux_stat_reset()
SELECT s.schemaname,
       s.relname AS tablename,
       s.indexrelname AS indexname,
       ux_relation_size(s.indexrelid) AS index_size
FROM ux_catalog.ux_stat_user_indexes s
   JOIN ux_catalog.ux_index i ON s.indexrelid = i.indexrelid
WHERE s.idx_scan = 0      -- has never been scanned
  AND 0 <>ALL (i.indkey)  -- no index column is an expression
  AND NOT i.indisunique   -- is not a UNIQUE index
  AND NOT EXISTS          -- does not enforce a constraint
         (SELECT 1 FROM ux_catalog.ux_constraint c
          WHERE c.conindid = s.indexrelid)
ORDER BY ux_relation_size(s.indexrelid) DESC;

查看numeric相关操作符
\dC numeric

查看所有数据库占用大小的语句：
select ux_database.datname, ux_database_size(ux_database.datname) AS size from ux_database;
select ux_database.datname, ux_size_pretty(ux_database_size(ux_database.datname)) AS size from ux_database; 这个可以带单位

查看函数repeat_test的owner：
SELECT proname, ux_get_userbyid(proowner) AS owner
FROM ux_proc
WHERE proname = 'repeat_test';

语句块使用：
DO $$
DECLARE
	xml_parser text;			//定义变量
BEGIN
  -- 创建 XML 解析器
  xml_parser := DBMS_XMLPARSER.newParser();

  -- 释放 XML 解析器
  PERFORM DBMS_XMLPARSER.freeParser(xml_parser);
END;
$$;

注意点：没返回值的函数，在语句块中，通过PERFORM调用，否则会报错；


ux_typeof函数		//用于查看函数返回类型
eg：ux_typeof(min(V6))		//查看min函数，参数字段是V6时，返回函数类型；




pgsql网站：
pg源码：
https://www.postgresql.org/download/

pgsql文档：
https://www.postgresql.org/docs/13/index.html




2020-09-04
note：

/* [qiwang] Add begin */

/* [qiwang] Add end */

2020-09-09

/************系统表：*****************/
1、创建ux*.h文件
作用：定义数组，用于存放系统表数据

2、修改initdb.c
作用：给系统表数据赋值

3、在indexing.h添加索引
作用：加快查询

4、修改syscache.c
作用：添加到缓存，加快sql执行

/************隐藏列：*****************/
1、添加字段号，唯一识别隐藏列

2、修改heap.c
将隐藏列添加到数组SysAtt

3、ux_config.c
作用:设置隐藏列的值

4、heaptuple.c
作用：识别到隐藏列后，获取隐藏列的值

/************with time：*****************/



2020-09-14

转正流程：
陈明波 + 郝鑫刚 + 张文江 + 赵宗鹏 +






2020-09-10


案例一：

查看ux_config的代码结构
确定功能实现是在编译前获取宏值
linux：
宏定义在编译前通过configure编译
了解configure功能结构
通过AC_DEFINE_UNQUOTED宏可以定义该
windows：
通过msvc获取
这块通过脚本solution.pm将宏定义生成在ux_config.h.win32
编译后将ux_config.h.win32生成ux_config.h


案例二：
刚开始拿到这个问题后，首先通过java入口追踪代码，最后没追到，这块封装的比较深。
然后通过查看关键字，发现这块代码是通过xml实现的，然后查看这块的功能代码
确定该功能是自定义界面实现
确定修改方案：
首先需要确定语言选择框的机制，通过查看之前代码的汉化，系统会识别对应的字符串，中文：chn，英文：eng
确定汉化的几种方式：
目前我知道的有三种：
	系统内部实现、通过id判断、通过变量判断（变量这块又分为代码、标签两部分）
这块通过标签对变量进行判断


一共三种方式：
1、汉化通过判断系统语言进行显示






2020-09-21

1、虚拟机：












2020-09-25

Makefile：
1、指定头文件路径：
CFLAGS和CPPFLAGS


2020-10-14

安全版数据库：

src/bin/uxsql/startup.c				//修改数据库5分钟后断开链接
将145行SIGALRM==sig修改为0



2020-10-28

学习gdb
1、core dump

gdb ./uxdb core******

2、gdb教程
http://c.biancheng.net/gdb/

3、https://jingyan.baidu.com/article/215817f7e6a3b81eda142323.html
gdb跟踪子进程
set follow-fork-mode child
set follow-fork-mode parent

set detach-on-fork off
有的时候，我们想同时调试父进程和子进程，以上的方法就不能满足了。Linux提供了set detach-on-fork mode命令来供我们使用。其使用的mode可以是以下的一种：

on
只调试父进程或子进程的其中一个(根据follow-fork-mode来决定)，这是默认的模式。
off
父子进程都在gdb的控制之下，其中一个进程正常调试(根据follow-fork-mode来决定)
另一个进程会被设置为暂停状态。

set follow-exec-mode mode
我们使用set follow-exec-mode mode提供的模式来跟踪这个exec装载的程序。mode可以是以下的一种：
new 当发生exec的时候，如果这个选项是new，则新建一个inferior给执行起来的子进程，而父进程的inferior仍然保留，当前保留的inferior的程序状态是没有执行。

same 当发生exec的时候，如果这个选项是same(默认值)，因为父进程已经退出，所以自动在执行exec的inferior上控制子进程。




2020-10-29

1、添加注释

我们现在写代码时有两种注释，标记注释和真正有效的注释。下面1和2都是标记注释，第3个是真正注释。希望写注释的时候大家有意识想清楚注释的原则，而不是不管三七二十一，有代码就往上加标记注释。

1、为了和pg内核代码区分，并方便以后进行内核升级或者代码追踪，
当在内核代码中嵌入大段新增代码时，需要前后加begin/end的注释。
如果是小段代码或者一行两行代码，就开头写上“add by XXX for #单号” 就行

添加内容：
/* Begin add by wangqi for #94833 at 2020.12.29 */
/* End add by wangqi for #94833 at 2020.12.29 */


修改内容：
/* Begin modify by wangqi for #94833 at 2020.12.29 */
/* End modify by wangqi for #94833 at 2020.12.29 */

2、如果一个函数本身就是我们新增的，那么在这个函数中改正，也不需要再加begin end。
如果你有新增或者修改，只需要在关键的地方标注，这个代码是谁加的“add by XXX”，或者是谁改的 “modify by xxx”，任务单号是多少 “for #单号”等关键信息就可以了。

eg：
/* add by wangqi for #94833 at 2020.12.29 */
/* modify by wangqi for #94833 at 2020.12.29 */

3、除了上述的标记注释，对关键逻辑代码需要加说明注释，是真正的注释。大部分情况下该类注释都是需要有的。

/* Begin modify by wangqi for #94833 at 2020.12.29 */
/* End modify by wangqi for #94833 at 2020.12.29 */
/* only merge run this */

英文注释：
注释不能用//
注释要有空格
函数要有

文件头参考pg

添加内容：
/* Begin add by wangqi for #91139 at 2020.10.31 */
/* End add by wangqi for #91139 at 2020.10.31 */


修改内容：
/* Begin modify by wangqi for #91139 at 2020.10.31 */
/* End modify by wangqi for #91139 at 2020.10.31 */

/* modify by wangqi for #91139(merge into) at 2020.11.09 */

/* Begin modify by wangqi for #104112 at 2021.04.29 */
/* End modify by wangqi for #104112 at 2021.04.29 */

修改注意：
1、变量初始化
2、变量对齐
3、语句对齐


二、redmine

1、提交记录
Root Cause (Bug) or Purpose (RFE/Task):
应用端输入小写用户名无法连接；
Affected Area:
Solution:
由于客户端链接服务器前，会将用户名和密码做加密处理，导致传到后端md5值不一致，故在加密前做大写转换，但后端接收到的port结构体用户还是大写，这块需做分析
test:
Recommended Test Area:
Reviewed by:张文江
Approved by:
git checkin rev Number：f7ccf19a4d1b25e37188077cbd424472a8c703f8
target branch:security10_develop
Affected files：
modify:
uxdb-2.0/src/backend/libuxsql/auth.c
uxdb-2.0/src/interfaces/libuxsql/fe-auth.c

•Root Cause (Bug) or Purpose (RFE/Task):应用端输入小写用户名无法连接；
•Solution:
integer报错原因：由于客户端链接服务器前，会将用户名和密码做加密处理，导致传到后端md5值不一致，故在加密前做大写转换，但后端接收到的port结构体用户还是大写，这块需做分析
•Unit test:

•Reviewed by: 张文江
•svn checkin rev Number：f7ccf19a4d1b25e37188077cbd424472a8c703f8
•Affected files：
uxdb-2.0/src/backend/libuxsql/auth.c
uxdb-2.0/src/interfaces/libuxsql/fe-auth.c

2、redmine登记参考问题单177363 




2、查看linux内存大小
https://jingyan.baidu.com/article/e2284b2b13165da2e7118d46.html

du -sm *|sort -nr | head -n 10
du -sh gdb-8.1/


2020-11-02

1、测试pgsql是否存在内存泄漏
uxbench -i

uxbench -T 100			//测试100s pg是否存在


uxbench使用方法：
1、登录控制台，创建uxbench数据库：
create database uxbench;
2、在bin目录下，初始化数据
./uxbench  -i  -s  100

3、uxbench测试：
./uxbench -s 300 -T 300 -P 5 -c 32

tpcc：
主要修改两个文件：
dbfarm.pg		//客户端链接
props.pg		//tpcc配置文件

参数说明：
warehouses：		单位100M
loadWorkers：		一般为warehouses的1/10
terminals：			客户端数量
runMins：			tpcc执行时间

tpcc的使用方法：
1、加载数据
./runDatabaseBuild.sh props.pg

2、测试数据

runBenchmark.sh props.pg

2020-11-16

1、辅助进程在postmaster的监听循环中执行


2020-11-17

1、
查看checkpoint检查点
./ux_controldata -D 数据库


2020-11-18



2020-11-18

1、代码命名方式
功能单
feature/ver2.1.1.3_dev/#91139

缺陷单
bug/ver2.1.1.3_dev/#94056


2020-11-20
恢复uxdb超级用户权限：
sudo -S setcap cap_setuid+ep uxdb  恢复uxdb的权限

1、使用pg_resetxlog修复PostgreSQL控制文件的方法
https://developer.aliyun.com/article/59113

2、pg_controldata详解
https://blog.csdn.net/allway2/article/details/95440443
https://www.askmaclean.com/page/8?m=bbs&amp%3Ba


2020-11-27

https://www.cnblogs.com/sxmny/p/11224842.html

1、端口设置

1、开启防火墙
    systemctl start firewalld
防火墙状态：
systemctl status firewalld
关闭防火墙：
systemctl stop firewalld

2、开放指定端口
      firewall-cmd --zone=public --add-port=1935/tcp --permanent
 命令含义：
--zone #作用域
--add-port=1935/tcp  #添加端口，格式为：端口/通讯协议
--permanent  #永久生效，没有此参数重启后失效

3、重启防火墙
      firewall-cmd --reload

4、查看端口号
netstat -ntlp   //查看当前所有tcp端口·

netstat -ntulp |grep 5432   //查看所有1935端口使用情况·

关闭端口：
sudo lsof -i:5432
kill -9 PID


2020-12-02

c语言知识点

1、段错误
1）段错误是什么？
本质上是指指针错误（地址错误），之所以叫做段错误，是因为C语言中，内存结构是由不同的内存段组成的，所以称为段错误

2）一般导致段错误原因

数组越界、引用空指针

2、函数
strtok（s，","）		//分隔字符串，每次取出一个分割字符串，并指向下一个字符首位


2020-12-4

uxdb知识记录：
1、
uxdb控制台：\i sql文件			//导入sql命令

创建用户hrcm， create role hrcm;
给用户超级权限：alter

2、
benchmark路径：
/home/uxdb/uxdb-ng/test/tools/uxdb_tpcc-tool/benchmarksql-5.0

3、repmgr功能

repmgr配置主备同步异步模式：
synchronous_standby_names ='2(node1,node2)'
https://www.cnblogs.com/tiany1224/p/16199370.html

在备节点克隆数据库
repmgr -h 192.71.0.138 -U uxdb -d uxdb -f /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf standby clone

守护进程：
1、启动守护进程：
repmgr daemon start -f /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf
2、查看守护进程：
repmgr -f /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf daemon status

3、杀掉守护进程
kill `cat /tmp/repmgrd.pid`

4、循环插入多条数据
create table tbl_tests(id int, info text, c_time timestamp) tablespace myspace;
insert into tbl_tests select generate_series(1,10000000),md5(random()::text),clock_timestamp();

5、汉化
进入po同级目录执行：
make update-po

然后修改zh_CN.po.new
vim po/zh_CN.po.new

重新注册主备节点

1、
注册主节点
repmgr -f /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf primary register --force
注销主节点
repmgr primary unregister -f  /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf --node-id=2

2、
注册备节点
repmgr -f  /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf standby register --force
注销备节点
repmgr standby unregister -f  /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf --node-id=3



4、配置
local   replication   uxdb                             trust
host    replication   uxdb      127.0.0.1/32            trust
host    replication   uxdb      192.71.0.0/24           trust
local   uxdb        uxdb                              trust
host    uxdb        uxdb      127.0.0.1/32             trust
host    uxdb        uxdb      192.71.0.0/24            trust


5、
gram.y调试：

修改gram.Y文件
diff --git a/src/backend/parser/gram.y b/src/backend/parser/gram.y
index d1ce2ab042..43d5d5413b 100644
--- a/src/backend/parser/gram.y
+++ b/src/backend/parser/gram.y
@@ -65,6 +65,7 @@
#include "utils/numeric.h"
#include "utils/xml.h"

+int yydebug=1;

/* Precedence: lowest to highest */
+%debug

安全版记录：
1、控制台自动关闭时间控制：
login_idle_timeout




2020-12-6

数据库知识库：

学习内容：
1、大对象clob
2、国密算法，用例只列出sm4
3、增量备份
4、增量恢复
5、表删除后恢复，闪回功能
6、列注释
7、分区表（hash，range分区）
8、merge into
9、+连接符
10、CONNECT BY
11、ROW_NUMBER() OVER
12、UNION/UNION ALL/INTERSECT/MINUS
13、INTERSECT
14、NOT EXISTS/EXISTS/NOT IN/IN
15、ROWID
16、包和包体 PACKAGE PACKAGE BODY
17、Bulk collect
18、VPD技术 Oracle Virtual Private Database
19、列式存储表 用例好像不太一样
20、人资域 数据来源为 oracle11.2.0.1 expdp导出dmp文件
21、oracle 显式游标，隐式游标支持
22、资产域 数据来源为 oracle11204 expdp导出dmp文件 Oracle 11g expdp导出dmp文件
23、rownum
24、集群高可用

一、触发器

1、定义
相当于一个回调函数，在指定的事务发生时，自动触发函数功能。

2、属性
 FOR EACH ROW ：如果选中，每一行修改都会触发一次
 FOR EACH STATEMENT：如果选中，不管修改多少行，每个语句只触发一次

3、用法

删除触发器
drop trigger ${trigger_name} on ${table_of_trigger_dependent};

trigger_name：触发器名字
table_of_trigger_dependent：触发器对应的表名


实例：

insert:
drop trigger example_trigger on student;
drop table student,score,AUDIT;
drop function auditlogfunc;


CREATE TABLE student (
  id   int primary key,
  name varchar(50)
);

CREATE TABLE score (
  studentId  int,
   math     int
);

CREATE TABLE AUDIT(
   EMP_ID INT NOT NULL,
   ENTRY_DATE TEXT NOT NULL
);

INSERT INTO student VALUES(1,'April');
INSERT INTO student VALUES(2,'Harris');

INSERT INTO score VALUES(1, 98);
INSERT INTO score VALUES(2,77);
INSERT INTO score VALUES(3,87);

CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$
   BEGIN
      INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp);
      RETURN NEW;
   END;
$example_table$ LANGUAGE pluxsql;

CREATE TRIGGER example_trigger BEFORE INSERT ON student FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();

MERGE INTO student A USING (select B.studentId,B.math from score B) C ON(A.id=C.studentId)
WHEN NOT MATCHED THEN
INSERT (id, name) VALUES(C.id,C.math);

删除触发器：
drop trigger example_trigger on student;


update:
drop trigger example_trigger on student;
drop table student,score,AUDIT;
drop function auditlogfunc;


CREATE TABLE student (
  id   int primary key,
  name varchar(50)
);

CREATE TABLE score (
  studentId  int,
   math     int
);

CREATE TABLE AUDIT(
   EMP_ID INT NOT NULL,
   ENTRY_DATE TEXT NOT NULL
);

INSERT INTO student VALUES(1,'April');
INSERT INTO student VALUES(2,'Harris');

INSERT INTO score VALUES(1, 98);
INSERT INTO score VALUES(2,77);
INSERT INTO score VALUES(3,87);

CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$
   BEGIN
      INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp);
      RETURN NEW;
   END;
$example_table$ LANGUAGE pluxsql;

CREATE TRIGGER example_trigger BEFORE INSERT ON student FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();

MERGE INTO student A USING (select B.studentId,B.math from score B) C ON(A.id=C.studentId)
WHEN NOT MATCHED THEN
INSERT (id, name) VALUES(C.id,C.math);

2020-12-09

uxdb整理总结：
uxdb资料：

1、查看postgre各个文件关联
https://docs.huihoo.com/doxygen/postgresql/catalog_8c.html

2、gdb打印语法树
call elog_node_display(15,"111",parsetree,1)


uxdb命令：
查看数据库大小：
SELECT ux_size_pretty( ux_database_size('uxdb') );
查看单张表：
SELECT ux_size_pretty( ux_total_relation_size('uxbench_accounts') );

查看表oid：
select oid from ux_class where relname = 'test_name';

查看oid对应的ux_attribute属性
select * from ux_attribute where attrelid = 16391;


uxdb按端口启动集群：
./ux_ctl -o "-p 5433" -D test2 start

安全版功能：

1、身份鉴别：
用户标识：
在服务器端，存储每个用户的身份标识（用户名）、用户口令（具有唯一性，标识该用户）、有效期等

用户鉴别：
鉴别用户的真实性、连接超时处理


2、密码到期
用uxop用户登录数据库
./uxsql -U uxop -d uxdb
修改密码：
alter role uxdb valid until '2022-01-21 16:37:46.085415+08';


3、解密sql语句
export SKIP_WRAPPER=1

4、备份sql、tar数据
-Fp参数以sql输出
./ux_dump -U uxop -d uxdb -Fp -t test_column > hidecolumnsFt.sql
-Fp参数以tar格式输出
./ux_dump -U uxop -d uxdb -Ft -t test_column > hidecolumnsFt.tar

5、打包命令：
cd /home/uxdb/uxdb-ng/install/linux
./release.sh --release=security --version=2.1.0.4 --min_version=03 --license=commercial


6、切换inuser用户：

加载ux_authority插件

7、设置加密信息

select inuser.IU_encrypted_column('uxdb','uxdb','student','sname','keyname1','AES-128','ECB','none',0,'iv1','69,156,226,95,210,79,68,47,193,46,150,98,169,220,63,151','o_data_type1','n_data_type1',1,'2021/02/27'::timestamp,'2021/10/12'::timestamp,1);

安全版数据迁移：
select data_migration('uxdb', 'student', 'sname', 'bytea', 1, 100);

8、grant功能

1、用u2用户访问u1表数据
create user u1;
create user u2;
set session authorization u1;
create table t1(id int);
\c - uxdb
grant u1 to u2;
set session authorization u2;
select * from u1.t1;

9、解锁用户
set_deblocking_user（'用户名'）；

2020-01-14

linux 中文显示修改
1、/etc/profile
添加export LANG=zh_CN.UTF-8
2、/etc/locale.conf
添加LANG=zh_CN.UTF-8

3、/sbin/service
在env -i 后面加上 LANG="$LANG"
LANG="$LANG"

4、显示系统语言
locale

uxdb问题记录：
1）license问题：
带license如果未执行下面命令，生成的license客户端执行命令会提示降级
getcap uxdb 
setcap cap_setuid+ep uxdb

发现问题现象：
安装run包时，初始化db之前执行了ctrl+c中断安装；
问题原因：
安装run包时，中间不要ctrl+c安装中断，正常安装直到初始化完成。原因是之前版本涉及uxdb的权限是在初始化db的时候赋予的



2020-1-21
loadrunner:
1、
loadrunner脚本配置（select与insert）：

Action()
{
	web_url("index.jsp",
		"URL=http://192.71.0.139:8080/HttpTest/index.jsp",
		"Resource=0",
		"RecContentType=text/html",
		"Referer=",
		"Snapshot=t1.inf",
		"Mode=HTML",
		LAST);

	web_add_cookie("JSESSIONID=52CB9C7CE365A5D520FAE1E7A55FED04; DOMAIN=192.71.0.139");

	lr_start_transaction("l1");

	web_reg_find("SaveCount=para_count","Search=Body",
		"Text=successful",
		LAST);
	web_link("执行查询",
		"Text=执行查询",
		"Snapshot=t2.inf",
		LAST);

	web_url("index.jsp_2",
		"URL=http://192.71.0.139:8080/HttpTest/index.jsp",
		"Resource=0",
		"RecContentType=text/html",
		"Referer=",
		"Snapshot=t3.inf",
		"Mode=HTML",
		LAST);

	web_reg_find("SaveCount=para_counts","Search=Body",
		"Text=successful",
		LAST);
	web_link("执行插入",
		"Text=执行插入",
		"Snapshot=t4.inf",
		LAST);
   web_url("index.jsp_2",
		"URL=http://192.71.0.139:8080/HttpTest/index.jsp",
		"Resource=0",
		"RecContentType=text/html",
		"Referer=",
		"Snapshot=t5.inf",
		"Mode=HTML",
		LAST);

if((atoi(lr_eval_string("{para_count}"))>=1)||(atoi(lr_eval_string("{para_counts}"))>=1))
{lr_end_transaction("l1", LR_PASS);}
else
{lr_end_transaction("l1", LR_FAIL);}

return 0;
}

2、loadrunner使用：
https://blog.csdn.net/aijaijgnaw/article/details/122882690

2021-02-05

1、参加企业文化、公司制度、办公系统、财务等新员工培训，并做新员工培训笔记
2、
功能单：
83571、
merge into

问题单：
84308、84307、85967、88022

90557、86469、94056、88558、88734、88737、94937

南网项目支持

93980、94680、94833、98534、97571、98960、97708、95981、

#83571：ux_config增加支持查询打包信息
#84308：root用户图形化界面中文安装2.1.1.2，创建实例界面是英文，没有汉化
#84307：root用户图形化界面中文安装2.1.1.2，创建用户界面是英文，没有汉化
#85967：不能创建第三方插件chkpass
#88022：AK项目支持
#90557：创建分区表后，分区表级别存在问题，hash与主表为同一级别
#86469：一主两备（一同步一异步）流复制，主库所在的服务器（227）在遇到断电并恢复后，主库无法启动，部分wal日志遭到损坏
#94056：merge into、同义词、大小写敏感 代码告警消除
#88558：使用ux_archivecleanup命令清除wal日志，集群实例无法正常启动
#88734：使用ux_diagnose进行数据库恢复，能够正常启动实例，但数据库表丢失，建立新表，之前丢失的表恢复
#88737：使用ux_diagnose进行重置wal日志，完成后实例无法正常启动
#94937：merge into操作分区表 服务器意外关闭
#93980：语法开关前后创建视图同义词失败
#94680：在ignore-case集群下，使用merge into语句与表中字段大小写不一致，报字段不存在错误
#94833：merge into触发器相关函数修改未调用
#98534：tpcc稳定性测试：warehouse=10000仓时，初始化数据报错
#97571：postgres_adaptor 插件更新
#98960：XC测试-验证在线升级和节点故障
#97708：使用简体中文安装完成程序，进行集群实例初始化，提示的语言不统一
#95981：南网项目支持
#
#
#
#
#
#
#
izpack汉化


年度工作总结：

1、izpack安装卸载问题单修复
1、2.1.1.3版本功能开发与修改
2、2.1.1.3版本迭代一、迭代二开发及问题单修复
3、AK、XC、南网测试支持
4、

通过添加merge into语句，对sql处理流程有一定的分析，学习查看postgresql数据库内核分析、、高可用功能学习及了解、
通过处理wal日志问题单，清楚了wal日志、checkout机制、学习了解安全版功能。

总共耗时：
787

学习：104h
对外支持：56h
解决问题单：627h

需研究sql文件：
rules


2021-03-03

84858问题单测试步骤：
set ora_grammar = on;
create table test(id int);
insert into test select generate_series(1,100);
select * from (select id from test where id < 3);
select * from (select id from (select  * from test where id < 3));

问题单处理：

uxdb-2.0:
c=1546270693
1871169857

uxdb-2.1:
c=2326301040
1356382148

hash值处理：
transformAExprOp
	-》make_op
		-》oper
			-》find_oper_cache_entry
				-》hash_search
					-》hash_any					hashfunc.c:307
					-》hash_search_with_hash_value


key值命名空间oid列表获取：
oper
	-》make_oper_cache_key
		-》fetch_search_path_array	namespace.c:4210
			-》recomputeNamespacePath

ka:
uxdb2.0:
{oprname = "=", '\000' <repeats 62 times>, left_arg = 20, right_arg = 16907, search_path = {11, 16957, 2200, 0 <repeats 13 times>}}
uxdb2.1:
oprname = "=", '\000' <repeats 62 times>, left_arg = 20, right_arg = 16384, search_path = {11, 2200, 0 <repeats 14 times>}

问题一：右操作符类型问题

代码流程：
transformAExprOp										parse_expr.c:857
	-》transformExprRecurse											:944
		->transformTypeCast											:207
			->typenameTypeIdAndMod									:2677		//获取oid
				-》typenameType							parse_type.c:298
					->LookupTypeName					parse_type.c:251
			->coerce_to_target_type									:2737
				->coerce_type								parse_coerce.c:102
					-》makeRelabelType									  :456


2021-03-12

大小写敏感：

分为存储和匹配两个过程
pg自身：					按小写存储，匹配时将大小写转化为小写匹配，匹配大小写不敏感；（目的：显示按小写显示）

大小写不敏感改造：			按大写存储，匹配时按大小写不敏感匹配（目的：显示按大写显示）

默认大写：


原理：
1、

1、原生场景：表名、字段名默认转小写，且敏感；字段值敏感。
2、--ignore-case场景：表名、字段名默认不变直接存储，不敏感；字段值不敏感。
3、计划可实现：表名、字段名默认不变直接存储，且敏感；字段值敏感。
4、计划可实现：表名、字段名默认不变直接存储，不敏感；字段值敏感

大小写不敏感：按原文存储，匹配按大小写不敏感匹配

1、将匹配也改为大小写敏感处理（存在以下问题）

2、不修改转换逻辑，只需要在结果集将输入sql的列名做下替换


敏感：调用pg本身函数
不敏感：使用自身封装函数

07887d377bb9ebbb864e6750e0049279fe24ad89

0653fa8c38951ecd9e14a15f7b8bc3a3253e1b8a

#define UX_STRCASE_CMP(s1, s2)  \
		(ignore_case ? ux_strcasecmp(s1, s2) : strcmp(s1, s2))

#define UX_STRNCASE_CMP(s1, s2, len)  \
		(ignore_case ? ux_strncasecmp(s1, s2, len) : strncmp(s1, s2, len))

#define UX_MEMCASE_CMP(s1, s2, len)  \
		(ignore_case ? ux_strncasecmp(s1, s2, len) : memcmp(s1, s2, len))


不敏感测试用例：

/* Case-sensitive table name */
create table oldtable(id int);
create table oLdtaBle(id int);
create table OLDTABLE(id int);

/* Case-sensitive field names */
create table fieldname(num int, nUm int, NUM int);
insert into fieldname values(1, 2, 3);
select num from fieldname;
select nUm from fieldname;
select NUM from fieldname;

/* Case-sensitive table names and field names */
create table fieldtable(ID int, id int);
create table FieldTable(ID int, id int);
create table FIELDTABLE(ID int, id int);

/* Case sensitive field value */
create table t2(name text);
insert into t2 values('zhangsan'),('Zhangsan'),('ZHANGSAN');
select * from t2 where name = 'zhangsan';
select * from t2 where name = 'Zhangsan';
select * from t2 where name = 'ZHANGSAN';

/* Case sensitive name keyword verification */
create table t3(name text,Name text);
\d


make check不敏感：

7154e5971fdd603995e70e3ecac67052d04fadf6

ade2318dfa39f4feb3b1cb5cbf32ede93f392313

uxsql报错：

uxdb-2.1/src/backend/catalog/information_schema.sql
uxdb-2.1/src/backend/catalog/system_views.sql
uxdb-2.1/src/backend/snowball/snowball_func.sql.in
uxdb-2.1/src/bin/initdb/initdb.c


参数：
--ignore-case
--no-downcase






language c：

CREATE FUNCTION ux_catalog.ux_file_write(text, text, bool)
RETURNS bigint
AS 'MODULE_PATHNAME', 'ux_file_write'
LANGUAGE C VOLATILE STRICT;

RECORD：

CREATE FUNCTION dbms_pipe.__list_pipes()
RETURNS SETOF RECORD
AS 'MODULE_PATHNAME','dbms_pipe_list_pipes'
LANGUAGE c VOLATILE STRICT;

大小写实现功能：

字段名不区分大小写：
但字段名显示区分大小写

方案二：

1、按原文存储，
比较用大小写不敏感
语法层给字段名加后缀
2、在字段名处加后缀，strcmp处如果有后缀，不做转换
否则转小写处理
3、在结果集将后缀去掉即可

/home/uxdb/uxdb-ng/uxdb-2.1/src/port/uxstrcasecmp.c
strcmp：

unsigned int ux_num = strlen(s1);
		unsigned char dest[4] = {""};
		strncpy(dest, s1+ux_num-3, 3);

		if(strcmp(dest,"_ux") == 0) {
			strcmp(s1, s2);
			return 0;
		}

字符串显示：

unsigned int ux_num = strlen(att->attname);
		unsigned char dest[4] = {""};
		strncpy(dest, att->attname+ux_num-3, 3);

		if(strcmp(dest,"_ux") == 0) {
			att->attname + ux_num -3 = '\0';
		}

2021-03-16
pg兼容oracle：

1、Postgres兼容Oracle语法研究-extension
https://www.jianshu.com/p/cdb84a9f49a1



新增知识点：

1、target_list分析：
https://www.cnblogs.com/gaojian/tag/gram.y/









邮件1：
猜想1：可能输入sql时，将字段名加了双引号
猜想2：结果集中的值与输入sql的值不一致导致

邮件2（王若楠）：



2021-03-19

初始化数据库：
./initdb -W -D db1 -I -M

./ux_ctl -M -I -o "-I" -D /home/uxdb/uxdbinstall/dbsql/bin/db1 start


create user test with password '1qaz!QAZ'；

rpm安装：
rpm -ivh --force uxsinodb-2.3-1.nfs.x86_64.rpm

打包注意点：
1、打simple包：
编译去掉参数--with-openssl --with-libxml --with-uuid=ossp
configure加参数--without-readline

2、28s使用kylin V4+x86机器，该机器特殊点在于glibc版本问题：
glibc版本是2.23；

3、run包安装提示报错：chmod: cannot access ‘/tmp/uxdb_install_tmp/jre/bin/*’: No such file or directory

打包需要将jre打入，/home/uxdb/db-package/others/jre  在这个路径下放一个可用的jre，
安装完后是这个样子：/home/uxdb/db-package/others/jre/bin/java

jre的包见路径：D:\mywork\mywork_2023\南京28所\添加jre


1、如果有uuid
拷贝/lib64/libossp-uuid.so.16 到安装目录下；
一、rpm打包：
编译：
./build.sh --release=standard --license=internal --version=2.1.1.4 --nouxfs --enable-root
打包：
执行/install/autopkg/rpmpkg/release.sh
~/rpmbuild/RPMS/aarch64/下生成rpm包。

二、打tar包：--useizpack=no: no：打tar包，yes打run包，默认run包

注意：
编译前需要确认以下密码是否正确：
uxdb-2.1/src/Makefile.global.in			//注释掉代码：
echo 123456 | sudo -S setcap cap_setuid+ep '/home/uxdb/uxdbinstall/dbsql/bin/uxdb'
还有以下路径也需要删除：
uxdb-2.1/src/backend/Makefile
src/Makefile.global
编译：
./build.sh --release=standard --license=commercial --version=2.1.1.4 --nouxfs/

打包

1）将uuid动态库拷贝到安装路径下；
2）./release.sh --release=standard --version=2.1.1.4 --license=commercial --nouxfs --useizpack=no

2114p编译：
./build.sh --release=standard --version=2.1.1.4 --license=commercial --extension-adaptor=yes --nouxfs --extended_parameters

pljava编译报错：
1)修改uxdb-2.1/contrib/pljava/build.sh：
#mvn -Dpljava.libjvmdefault=/usr/local/java/jre/lib/amd64/server/libjvm.so                                                                                         \
mvn -Dpljava.libjvmdefault=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.342.b07-0.p01.ky10.aarch64/jre/lib/aarch64/server/libjvm.so    \
    -Duxsql.uxconfig=${UXDB_INSTALL}/dbsql/bin/ux_config                                           \
    -Dnar.aolProperties=./pljava-so/aol.aarch64-gcc.properties                                     \
    -Pwnosign                                                                                                          \
    -Dnar.cores=1                                                                                                      \
    clean install -X
2)uxdb-2.1/contrib/pljava/pljava-so
在以上路径添加文件aol.aarch64-gcc.properties		//文件路径D:\mywork\20220901_137770

uos系统编译，以下参数有问题
--with-pam --with-gssapi  --with-systemd



编译报错处理：
1、对于-Werror报错，相关问题单：
184625 

编译问题：


1、maven编译问题
提示jar找不到：
原因：maven源配置问题
解决方法：
1、修改配置文件：/etc/maven/settings.xml，添加maven阿里源
<mirror>
    <id>aliyunmaven</id>
    <mirrorOf>*</mirrorOf>
    <name>阿里云公共仓库</name>
    <url>https://maven.aliyun.com/repository/public</url>
</mirror>
2、安装jdk，安装可能是jde，需要确定jdk是否安装成功，通过javac命令确定；



jdbc编译打包：
编译打包脚本：
uxdb-drivers/uxdb-jdbc-42.2.12/uxdbjdbc/build.sh
jar包生成路径：
uxdb-drivers/uxdb-jdbc-42.2.12/uxdbjdbc/target/uxdbjdbc-42.2.12.jar
将jar包copy到路径：
uxdbinstall/driver/jdbc/jar/

打包模板：
打包分支：support/#136538
打包要求：
带license
包名：uxdb-std-linux8-x86_64-v2.1.1.4.run
md5：bc848ebd4d417bcaaac94ce3c5cccac5

打包机器/密码：
10.1.108.53   centos8.5/x86_64   root/UXz+lm5Qp05Yw=2022  uxdb/UXV+7iecYy6GQ=2022  port:46722



商密分支：

调查问题的分支 support/support_BM3p

最新分支：
support/#99334_BM4p


bug/support/#99334_BM4p/#103474


commit：

266507b1825af22fb6a86e72fde837ff9fc2ed31
3653b86059c83aca07141a0a758bc828211665d0
bb3cee1c568b95e41a746a5cb341534c2f1a08d6
7b9797d3501fe6344f31b3d4f9043b56f15620b7
933295e65761ef5c17abd1eaafb72a551a669ad0

7088819bf126a0cd43ebd35745036e638e0a8edd

0001-99335-json.patch
0001-modify-define-LOG_NUMBER.patch
0001-devid-created-extensions.patch
0001-.patch
0001-99335.patch
0001-101986.patch


生成包路径：
/home/uxdb/rpmbuild/RPMS/x86_64

打包：
银河麒麟V10+aarch64、中科方德4.0+海光x64、银河麒麟V10+龙芯 mips

uxcloud:
http://10.1.106.210/#/dashboard
http://10.1.106.220/#/Center/111
http://10.1.106.211/#/Center/111			//是arm的uxcloud
http://10.1.106.230/#/Center/111
http://10.1.106.240/#/Center/111
用户名/密码：admin/123456

北京服务器：
10.1.106.61   uxdb/Uxsino@123       银河麒麟V10+aarch64
10.1.106.233  uxdb/123123           中科方德4.0+海光x64


10.1.106.195 root/Uxisno@123		中标麒麟

10.1.106.11   ARM  中科方德     uxdb UXGRfHc*&bX4KC2022    port:46722
10.1.106.61   ARM  银河麒麟V10  uxdb UXFU!qbsJ<gsM+2022    port：46722
10.1.106.98   ARM  银河麒麟V10_海军  xj  1qaz!QAZ   port:46722
10.1.106.67   ARM 中标麒麟v7      uxdb   uxdb   UXQt>Eb_FF9MK22022   port:46722
10.1.106.110  root  UXg9uu$f+Yj7bE2022     uxdb   UXg9uu$f+Yj7bE2022    端口号  46722
龙芯 mips：
10.1.106.51   root/UX3wbl9plq+uA=2022 uxdb/UXZX5FU7/egMs=2022   端口37622
uos arm的机器：
10.1.106.50   ARM  UOS         uxdb  UX<rbfXZR*tkVf2022  port：46722			（arrch64）

10.1.106.252  ARM  银河麒麟V10   uxdb/Uxsino@2021 port:22		（arrch64）

kylin10/x86_64：
10.1.108.110  kylin10/x86_64      root UXg9uu$f+Yj7bE2022 uxdb UXg9uu$f+Yj7bE2022 port:46722
10.1.108.128  kylin10/x86_64      root UX15Bdtwx/AOk=2022 uxdb UXgWjYKJHl+ig=2022 port:46722
UOS/申威：
10.1.106.183  申威  UOS    root/Uxisno@2021  uxdb/Uxsino@2022 端口号22

10.1.108.52   ubuntu20/x86_64    root/UXmey/L/X/Zkw=2022  uxdb/UXxLG7d59/H7c=2022  ssh端口46722

中标麒麟7：
10.1.106.67 uxdb   uxdb   UXQt>Eb_FF9MK22022   port:46722

麒麟V10+arm		192.30.0.54			uxdb/Uxsino@1234

Kylinv4 + arm 192.30.0.50			密码：123456

Kylinv4 + x86： 
10.1.106.92   uxdb/Uxsino@123           银河麒麟V4_x86+海光x64

文件编辑，鼠标不能拷贝
解决方法：打开文件，进入编辑模式，输入以下命令：
set mouse-=a

dev/ver2.1.1.5A_dev修改文件：
        修改：     install/linux/Install_SE.XML
        修改：     install/linux/install.sh
        修改：     install/linux/release.sh
        修改：     uxdb-2.1/build.sh
        修改：     uxdb-2.1/contrib/repmgr/config.h.in
        修改：     uxdb-2.1/contrib/uxgmssl/build_gmssl.sh
        修改：     uxdb-2.1/contrib/uxmpp/src/include/uxmpp_config.h.in

中科方德：
10.1.108.12   nfs4.0/x86_64      uxdb/Uxsino@123 port:46722


10.1.108.50
root/UXnJcEJGltZ+C+Mo2O6fAlz0HTdso=2022
uxdb/UXt85HBkal7jREDG2H4gq/EARmHAg=2022
ssh端口46722



银河麒麟V10+龙芯mips  Gmssl编译方式：
./Configure linux64-mips64




修改uxdb用户报错：
char *cmd = "whoami";
        FILE* pipe = popen(cmd, "r");
        char ebuf[64] = {0};
        fgets(ebuf, 64, pipe);
        pclose(pipe);
        ebuf[strlen(ebuf)-1]='\0';
values[2] = ebuf;


删除dbsql：

UxdbAgent/UxdbAgent/UxdbAgent/debug/bin/Agent_initdb.sh
UxdbAgent/UxdbAgent/UxdbAgent/detection/src/detection.c
UxdbAgent/UxdbAgent/UxdbAgent/service/src/StartOrStopDatabase.c


保密四期研发进度报告：
1、以root用户启动数据库 （ 已修复）
2、备份和恢复权限中没有起作用  （ 已修复）
3、低限告警中插入语句非常缓慢   （未复现）
4、没有默认打开错误登录次数提示  （已修复）
5、审计进程启动失败  （ 未复现）
6、对于密码复杂度校验问题 （已修复）
6、ux_rman 32k   数据目录8k （已修复）
7、用户密码有效时长问题  （已修复）
8、空闲登出时间只针对当前用户生效问题（会话级别设置只对当前会话级别生效，数据库级别设置对所有会话生效）
9、uxsql登录显示logon time不是当前时间 （已修复）
10、后台任务(例如存储过程)运行中，但前台无操作超时后，也会被强制登出（已修复）

昨日进展：
1、用户密码有效时长问题  （已修复）
2、后台任务(例如存储过程)运行中，但前台无操作超时后，也会被强制登出（已修复）
3、带-I-M参数初始化集群后，给数据库中注入100warehouses的数据时，会持续卡在注入数据页面，cpu使用率在80%左右，登录数据库会卡死。（目前正在分析调查）

用户密码有效时长问题
后台任务(例如存储过程)运行中，但前台无操作超时后，也会被强制登出(
目前需分析定时器之前)


connection_timeout作用：
login_idle_timeout 30s
connection_timeout 60s

当操作时间小于30s时，30s断开
当操作时间大于30s时，60s断开
当idle空闲时间大于连接时间，超过连接时间断开


该问题原因：

uxsql在trust时，默认不记录登陆时间，


2021-03-25

打包顺序：

修改版本号为2.1
db:
1、build.sh 块大小为8k
2、编译db和uxdbagent、编译java工具（修改uxdbagent脚本）
3、将uxdbadmin和uxdbweb放到uxdbinstall目录下
4、替换rpmbuild目录下的build.sh
5、编译打包，分别在本地和opt验证

所有工具加可执行权限：
uxdbagent:
1、编译uxdbagent
2、修改shell脚本中root启动报错
uxdb-monitor：


/home/uxdb/uxdbinstall/dbsql/bin/uxdb --single -F -O -j -c search_path=ux_catalog -c exit_on_error=true   template1 >/dev/null
gdb：
set args -Atrust -D data1
b initialize_data_directory
r
b 3959
set follow-fork-mode child
handle SIGUSR1 nostop

报错函数：
setup_conversion

问题单调试：
set follow-fork-mode child
handle SIGUSR1 nostop
b InitUxdb


4590：effective_user = "uxdb";

1、#103871：uxsql登录显示logon time不是当前时间
2、#103820：密码首尾不能输入空格
3、#103666：保密四期要求root能启动数据库
4、#103680：解决龙芯和arm平台gmssl编译问题
5、#103959：审计进程中，log日志写死导致审计日志为空
6、#104108：initdb初始化时无法指定-U 参数
7、#104126：控制台前台无操作超时后，也会被强制登出
8、#104210：修改log_directory路径导致core dump



2021-03-30

ux_rman备份过程：
1、启动数据库
2、初始化备份目录
3、全量备份
4、校验全量备份
5、增量备份
6、校验增量备份


验证结果：
1、目标数据库第一次增量恢复后，目标数据库不能恢复源数据库之后的备份数据

#log_filename = 'uxsinodb-%Y-%m-%d_%H%M%S.log'

log_filename = 'uxsinodb-%a.log'


log_truncate_on_rotation		//等于on时，日志回卷
log_rotation_size				//单位M

测试语句：
create tablespace myspace location '/home/uxdb/tbs';
create table test (id1 int,id2 int) tablespace myspace;
alter tablespace myspace set (max_space_size='10M');
create or replace function insert_test() returns
boolean as
$body$
declare ii integer;
begin
ii:=1;
for ii in 1..1000000 loop
insert into test(id1, id2) values (116, ii);
end loop;
return true;
end;
$body$
language pluxsql;

select insert_test();

pg:
create tablespace myspace location '/home/uxdb/tbs';
create table test (id1 int,id2 int) tablespace myspace;
create or replace function insert_test() returns
boolean as
$body$
declare ii integer;
begin
ii:=1;
for ii in 1..1000000 loop
insert into test(id1, id2) values (116, ii);
end loop;
return true;
end;
$body$
language plpgsql;


问题单记录：

安全版：
99928

标准版：
99334

2021-04-07

cell->rolname
cell->last_login_timestamp
cell->failuretime

select rolname from ux_login_table;



国产平台configure阶段报错“cannot guess build type; you must specify one”问题解决：
方案一：
添加参数 --build=[cpu架构]-[系统类型]  例如：./configure --build=mips64el-linux
方案二：
更新最新版config.sub和config.guess，然后再次执行configure
wget -O ./config.sub "git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD"
wget -O ./config.guess "git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD"

2021-04-08

1、
select rolname from ux_login_table where rolname = 'options.username';

insert into ux_login_table values('','','');

update ux_login_table set last_login_timestamp = 'last_login_timestamp', failuretime = 'failuretime' where rolname = 'uxdb';

char se_buf[256] = "select rolname from ux_login_table where rolname = '";
strcat(se_buf, options.username);
strcat(se_buf, "';");

char in_buf[256] = "insert into ux_login_table values('";
strcat(in_buf, options.username);
strcat(in_buf, "','");
strcat(in_buf, last_login_timestamp);
strcat(in_buf, "','");
strcat(in_buf, failuretime);
strcat(in_buf, "');");

char up_buff[256] = "update ux_login_table set last_login_timestamp =";
strcat(up_buff, last_login_timestamp);
strcat(up_buff, " set failuretime = ");
strcat(up_buff, failuretime);
strcat(up_buff, " where rolname = ");
strcat(up_buff, options.username);
strcat(up_buff, ";");

char se_buf[256] = "select rolname from ux_login_table where rolname = '";
if(options.username != NULL)
{
	strcat(se_buf, options.username);
}
else
{
	strcat(se_buf, "uxdb");
}
strcat(se_buf, "';");

char in_buf[256] = "insert into ux_login_table values('";
if(options.username != NULL)
{
	strcat(in_buf, options.username);
}
else
{
	strcat(in_buf, "uxdb");
}
strcat(in_buf, "','");
if(NULL != last_login_timestamp)
{
	strcat(in_buf, last_login_timestamp);
}
else
{
	strcat(in_buf, "NULL");
}
strcat(in_buf, "','");
if(failuretime != NULL)
{
	strcat(in_buf, failuretime);
}
else
{
	strcat(in_buf, "NULL");
}
strcat(in_buf, "');");


char up_buff[256] = "update ux_login_table set last_login_timestamp = '";
if(NULL != last_login_timestamp)
{
	strcat(up_buff, last_login_timestamp);
}
else
{
	strcat(up_buff, "NULL");
}
strcat(up_buff, "', failuretime = '");
if(failuretime != NULL)
{
	strcat(up_buff, failuretime);
}
else
{
	strcat(up_buff, "NULL");
}
strcat(up_buff, "' where rolname = '");
if(options.username != NULL)
{
	strcat(up_buff, options.username);
}
else
{
	strcat(up_buff, "uxdb");
}
strcat(up_buff, "';");

/* 赋予uxop权限 */

\c - uxdb
grant uxdb to username;

grant all on ux_login_table to u1;
\c - username

char grant_buff[NUM] = "grant uxdb to ";
strcat(grant_buff, options.username);

login那个：
当前登录用户、 当前用户登录失败次数、失败时间戳、自上次成功登录以来密码认证失败的次数、当前登录ip、当前登录时间、上次登录ip、上次登录时间

保密四期研发支持进度：
web/admin：
1、备份恢复目前基本确认页面，剩余各功能的后端编写以及功能联调，预计下周一之前可以完成---宋丽娜；
2、横工具栏中帮助下两项：版权信息描述和关于uxdb中相关内容需要优化：完成代码未合入--宋丽娜；
3、uxdbAdmin查询页面，超时失效之后继续功能不起作用：进度60%(预计时间存在风险)，其他问题详见admin问题汇总表格，总计预估工时3天---林龙涛；

db:
1、昨天提出汉化问题（已解决）；
2、将login文件信息加入表中（预计今天完成）；
3、审计导致benchmark时数据库卡死（审计设计缺陷，处理难度大，暂不处理）；

项目风险：
1、admin备份恢复功能开发完成预计下周一之前完成；
2、admin相关需修改问题需要3天时间处理（预计时间存在风险）。



1、
syscache.c:516
/* {LoginTableRelationId,
		LoginTableIndexId,
		1,
		{
			Anum_ux_login_table_rolname,
			0,
			0,
			0
		},
		16
	},*/ /* wangqiadd */

indexing.h:393
//DECLARE_UNIQUE_INDEX(ux_login_table_index, 4003, on ux_login_table using btree(rolname name_ops));
//#define LoginTableIndexId    4003

catalog.c:287
relationId == LoginTableIndexId)

uxdb-2.0/src/include/utils/syscache.h:69
LOGINTABLE

版本信息：
11：
Linux localhost.localdomain 4.19.113-1.nfs.16.x86_64 #1 SMP Tue Jun 23 16:20:45 CST 2020 x86_64 x86_64 x86_64 GNU/Linux

Linux version 4.19.113-1.nfs.16.x86_64 (mockbuild@localhost.localdomain) (gcc version 8.3.1 20190507 (Red Hat 8.3.1-4) (GCC)) #1 SMP Tue Jun 23 16:20:45 CST 2020

144：
Linux localhost.localdomain 4.19.113-3.nfs.x86_64 #1 SMP Wed Jun 10 17:58:43 CST 2020 x86_64 x86_64 x86_64 GNU/Linux

Linux version 4.19.113-3.nfs.x86_64 (mockbuild@localhost.localdomain) (gcc version 8.3.1 20190507 (Red Hat 8.3.1-4) (GCC)) #1 SMP Wed Jun 10 17:58:43 CST 2020

Linux version 4.19.113-3.nfs.x86_64 (mockbuild@localhost.localdomain) (gcc version 8.3.1 20190507 (Red Hat 8.3.1-4) (GCC)) #1 SMP Wed Jun 10 17:58:43 CST 2020

Datum ux_login_table_update(UX_FUNCTION_ARGS)
{
    HeapTuple oldattTuple;
	Datum		values[Natts_ux_login_table];
	Relation	ux_audit_database_desc;
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);
	bool nulls[Natts_ux_login_table];
	HeapTuple tup;
	Relation	ux_login_table_desc;
	values[Anum_ux_login_table_rolname-1]=NameGetDatum(rolname);
	values[Anum_ux_login_table_last_login_timestamp-1]=NameGetDatum(last_login_timestamp);
	values[Anum_ux_login_table_failuretime-1]=NameGetDatum(last_failuretime);

    oldattTuple = SearchSysCache1(LOGINTABLE,NameGetDatum(rolname));
    if (!HeapTupleIsValid(oldattTuple))
	{
		ux_login_table_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
		tup = heap_form_tuple(RelationGetDescr(ux_login_table_desc), values, nulls);
		CatalogTupleInsert(ux_login_table_desc, tup);
		heap_freetuple(tup);
		heap_close(ux_login_table_desc, RowExclusiveLock);
		UX_RETURN_BOOL(true);
	}
	ux_audit_database_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
	CatalogTupleDelete(ux_audit_database_desc,  &oldattTuple->t_self);
	heap_close(ux_audit_database_desc, RowExclusiveLock);

    /* Free oldattTuple */
	ReleaseSysCache(oldattTuple);

    UX_RETURN_BOOL(true);
}


/* insret wangqi add */
Datum ux_login_table_insert(UX_FUNCTION_ARGS)
{
	Datum		values[Natts_ux_login_table];
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);
	bool nulls[Natts_ux_login_table];

	values[Anum_ux_login_table_rolname-1]=NameGetDatum(rolname);
	values[Anum_ux_login_table_last_login_timestamp-1]=NameGetDatum(last_login_timestamp);
	values[Anum_ux_login_table_failuretime-1]=NameGetDatum(last_failuretime);

	//if rolename don't in table ,insert it

		Relation	ux_login_table_desc;
		HeapTuple tup;
		ux_login_table_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
		tup = heap_form_tuple(RelationGetDescr(ux_login_table_desc), values, nulls);
		CatalogTupleInsert(ux_login_table_desc, tup);
		heap_freetuple(tup);
		heap_close(ux_login_table_desc, RowExclusiveLock);
		UX_RETURN_BOOL(true);
}

/* wangqi add update */

Datum ux_login_table_update(UX_FUNCTION_ARGS)
{
    HeapTuple oldattTuple;
	Relation	ux_audit_database_desc;
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);


    oldattTuple = SearchSysCache1(LOGINTABLE,NameGetDatum(rolname));
    if (!HeapTupleIsValid(oldattTuple))
	{
		UX_RETURN_BOOL(false);
	}
	/* if rolename databasename, delete it */
	ux_audit_database_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
	CatalogTupleDelete(ux_audit_database_desc,  &oldattTuple->t_self);
	heap_close(ux_audit_database_desc, RowExclusiveLock);

    /* Free oldattTuple */
	ReleaseSysCache(oldattTuple);

    UX_RETURN_BOOL(true);
}

Datum ux_login_table_update(UX_FUNCTION_ARGS)
{
    HeapTuple oldattTuple;
	Relation	ux_audit_database_desc;
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);


    oldattTuple = SearchSysCache1(LOGINTABLE,NameGetDatum(rolname));
    if (!HeapTupleIsValid(oldattTuple))
	{
		UX_RETURN_BOOL(false);
	}
	/* if rolename databasename, delete it */
	ux_audit_database_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
	CatalogTupleUpdate(ux_audit_database_desc,  &oldattTuple->t_self, oldattTuple);
	heap_close(ux_audit_database_desc, RowExclusiveLock);

    /* Free oldattTuple */
	ReleaseSysCache(oldattTuple);

    UX_RETURN_BOOL(true);
}

Datum ux_login_table_update(UX_FUNCTION_ARGS)
{
	Relation	ux_login_table_desc;
	HeapTuple newtuple;
	HeapTuple oldattTuple;
	Datum		values[Natts_ux_login_table];
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);
	bool nulls[Natts_ux_login_table];
	bool replaces[Natts_ux_login_table];
	replaces[Natts_ux_login_table - 1] = true;
	replaces[Natts_ux_login_table - 2] = true;
	replaces[Natts_ux_login_table - 3] = true;

	oldattTuple = SearchSysCache1(LOGINTABLE,NameGetDatum(rolname));
    if (!HeapTupleIsValid(oldattTuple))
	{
		UX_RETURN_BOOL(false);
	}
	ux_login_table_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
	newtuple = heap_modify_tuple(oldattTuple, RelationGetDescr(ux_login_table_desc),
										 values, nulls, replaces);
	CatalogTupleUpdate(ux_login_table_desc, &newtuple->t_self, newtuple);
	heap_freetuple(newtuple);

	heap_close(ux_login_table_desc, RowExclusiveLock);
	ReleaseSysCache(oldattTuple);
	UX_RETURN_BOOL(true);
}

/* 系统函数 */

char se_buf[256] = "select rolname from ux_login_table where rolname = '";
if(options.username != NULL)
{
	strcat(in_buf, options.username);
}
else
{
	strcat(in_buf, "uxdb");
}
strcat(se_buf, "';");

char in_buf[256] = "select ux_login_table_insert('";
if(options.username != NULL)
{
	strcat(in_buf, options.username);
}
else
{
	strcat(in_buf, "uxdb");
}
strcat(in_buf, "','");
if(NULL != last_login_timestamp)
{
	strcat(in_buf, last_login_timestamp);
}
else
{
	strcat(in_buf, "NULL");
}
strcat(in_buf, "','");
if(failuretime != NULL)
{
	strcat(in_buf, failuretime);
}
else
{
	strcat(in_buf, "NULL");
}
strcat(in_buf, "');");

char up_buf[256] = "select ux_login_table_delete('";
if(options.username != NULL)
{
	strcat(up_buf, options.username);
}
else
{
	strcat(up_buf, "uxdb");
}
strcat(up_buf, "','");
if(NULL != last_login_timestamp)
{
	strcat(up_buf, last_login_timestamp);
}
else
{
	strcat(up_buf, "NULL");
}
strcat(up_buf, "','");
if(failuretime != NULL)
{
	strcat(up_buf, failuretime);
}
else
{
	strcat(up_buf, "NULL");
}
strcat(up_buf, "');");


2021-04-14

清理审计日志：
68821
104195：
https://cd.uxsino.com:10943/db/uxdb-ng/merge_requests/2911/diffs#4f2683b0d369507f3bb53bbb7581f10ca43dc110
76068

audit_log_keep_start_time这个参数现象我给你说下，
比如设置1，你删除的是前一天零点之前的日志，
像今天15号，那么删除的就是14号0点之前的数据（重启生效，默认0不生效）


2021-04-21

1、用什么链接数据库
2、.net链接是干什么


添加QuartzDataSync


目前计划：
pg+postgres_adaptor

最新问题：
 1、.NET链接 sqlserver 和 pg的差异

换成sqlserver，无报错。
<add name="uxdbEntities1" connectionString="Data Source=.;Initial Catalog=TicketManager.Standard(xbys);User ID=sa;Password=1qaz!QAZ;Connection Timeout=50" providerName="System.Data.SqlClient" />


/*pg*/
<add name="uxdbEntities1" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=Nuxsql;provider connection string=&quot;Host=192.71.0.138;Database=uxdb;Username=uxdb;Password=1qaz!QAZ&quot;" providerName="System.Data.EntityClient" />


问题单：105978
http://cd.uxsino.com:19503/issues/105978

分析：.net连接问题
验证数据源为pg，.NET 通过 EF（EntityFramework）链接pg正常，
验证数据库uxdb，打开插件postgres_adaptor链接uxdb正常，关闭postgres_adaptor插件，链接报错，
故第一种修改方案：可通过添加插件postgres_adaptor解决链接问题；
第二种：通过修改连接字符串方式：
目前需分析app.config配置文件作用， 尝试.net链接原始sqlserve，connectionStrings不起作用


使用pg数据源，打开postgres_adaptor插件

我的问题：
1、原sqlserver字串是什么
2、咱们修改后的字串是什么（替换了Nuxsql）

目前知道的信息：

1、用sqlserver数据库，链接正常

2、修改config配置文件，替换sqlserver字串为nuxsql，报链接报错

实施步骤：

1、查看现场测试方式，了解EF链接方式
2、复现现场问题
3、查看pg与sqlserver字串区别

知识点介绍：
1、EF
EF的简单介绍，EF是一种通过映射操作实现数据交互的ORM框架技术

C#EF的简单使用：
https://www.cnblogs.com/bridgew/p/12709063.html

2、C#链接sqlserver数据库
https://blog.csdn.net/github_39533414/article/details/87949142
ADO.NET连接SQLServer数据库
https://blog.csdn.net/qq_36482772/article/details/70992047
C#使用ADO.NET连接本地sqlserver数据库流程
https://www.cnblogs.com/zgk666/p/13808936.html

3、找不到库：
https://blog.csdn.net/weixin_43617448/article/details/106130236

4、读取 appconfig文件配置数据库连接的方法
1）、https://blog.csdn.net/weixin_33713503/article/details/91495542?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-9&spm=1001.2101.3001.4242
2）、
https://blog.csdn.net/qq15577969/article/details/90040345?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-11.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-11.control



操作系统代码】-【CPU 代码】
打包名：
uxdb-sec-ky10-aarch64-v2.1.002.p2.rpm
uxdb-sec-ky10-mips-v2.1.002.p2.rpm
uxdb-sec-nfs-x86_64-v2.1.002.p2.rpm

昨天通过c#代码链接sqlserver数据库成功，
通过app.config链接sqlserver会报一些依赖的库等报错，正在解决（目前不清楚现场具体操作过程，只了解到修改app.config后链接会报错，现在通过
https://www.cnblogs.com/dfcq/p/12966747.html
这种方式验证字串问题）

C#打印：

using System;

namespace ConsoleApp3
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}


sqlserver配置信息：
sqlservice信息：
10.1.131.31
用户名 sa
密码 :1qaz!QAZ
port 1433
数据库：master

远端uxdb数据库：
ip：
10.1.106.37
数据库名：uxdb
用户名：uxdb
密码：1qaz2wsx

报错内容：
1、c# 未能找到类型或命名空间名“Form”


####################链接完成###############

1、c#链接sqlserver数据库代码：

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Configuration; //连接配置
using System.Data.SqlClient;//数据库类

namespace KeyGen
{
    class Program
    {
        /* public Form1()
        {
            InitializeComponent();
        } */
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            Form1_Load();
        }

        private static void Form1_Load()
        {
            //获取配置文件中的连接字符串
            string myschool = ConfigurationManager.ConnectionStrings["DBConnect"].ConnectionString;
            //建立数据库连接
            SqlConnection conn = new SqlConnection(myschool);
            try
            {
                //开启连接
                conn.Open();
                Console.WriteLine("数据库连接成功!");
                Console.ReadLine();
            }
            catch (Exception)
            {
                Console.WriteLine("数据库连接失败!");
            }
            finally
            {
                //关闭连接
                Console.WriteLine("数据库连接完成！！！！！！！！！！！！！！！！！！！!");
                Console.ReadLine();
                conn.Close();
            }
        }
    }

}


2、C#链接postgresql
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Configuration; //连接配置
using System.Data.SqlClient;//数据库类sqlserver
using System.Data.EntityClient;//pg
using QuartzDataSync.Entity;

namespace KeyGen
{
    class Program
    {
        /* public Form1()
        {
            InitializeComponent();
        } */
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            Form1_Load();
        }

        private static void Form1_Load()
        {
            //获取配置文件中的连接字符串
            //string myschool = ConfigurationManager.ConnectionStrings["uxdbEntities"].ConnectionString;
            string myschool = System.Configuration.ConfigurationManager.ConnectionStrings["uxdbEntities"].ToString();
            MessageBox.Show(myschool);
            //建立数据库连接
            SqlConnection conn = new SqlConnection(myschool);
            try
            {
                //开启连接
                conn.Open();
                Console.WriteLine("数据库连接成功!");
                Console.ReadLine();
            }
            catch (Exception)
            {
                Console.WriteLine("数据库连接失败!");

            }
            finally
            {
                //关闭连接
                Console.WriteLine("数据库连接完成！！！！！！！！！！！！！！！！！！！!");
                Console.ReadLine();
                conn.Close();
            }
        }
    }

}

C#链接pg
https://www.cnblogs.com/qiuzhongyang/p/3874095.html
c#代码
https://www.it610.com/article/1281244350075912192.htm

app.config字串配置：

<add name="DBConnect" connectionString="Data Source=10.1.131.31,1433;Database=master;User ID=sa;Password=1qaz!QAZ"/>

<add name="DBConnect" connectionString="Data Source=10.1.106.37,5432;Database=uxdb;User ID=uxdb;Password=1qaz2wsx"/>

创建实例：
pg生成的字串：
<add name="uxdbEntities" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=Npgsql;provider connection string=&quot;Host=192.71.0.138;Database=uxdb;Username=uxdb;Password=123456;Persist Security Info=True&quot;" providerName="System.Data.EntityClient" />

sqlserver生成的字串：
<connectionStrings>
	<add name="DBConnect" connectionString="Data Source=10.1.131.31,1433;Database=master;User ID=sa;Password=1qaz!QAZ"/>
</connectionStrings>


现场实例字串：
换成sqlserver，无报错。
<add name="uxdbEntities1" connectionString="Data Source=.;Initial Catalog=TicketManager.Standard(xbys);User ID=sa;Password=1qaz!QAZ;Connection Timeout=50" providerName="System.Data.SqlClient" />

/*pg*/
<add name="uxdbEntities1" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=Nuxsql;provider connection string=&quot;Host=192.71.0.138;Database=uxdb;Username=uxdb;Password=1qaz!QAZ&quot;" providerName="System.Data.EntityClient" />


2021-04-25
电子五所：
代码分支： support/#106134

如果是手动加的话， 宏用
#ifdef USE_CDPS
#endif

验证节点：
本节点之前正常
add some file for compile

<connectionStrings><add name="uxdbEntities" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=Npgsql;provider connection string=&quot;Host=10.1.106.37;Database=uxdb;Username=uxdb;Password=1qaz2wsx;Persist Security Info=True&quot;" providerName="System.Data.EntityClient" /></connectionStrings></configuration>

2021-04-26
长沙gfkd项目
1、类型转换问题
varchar到bytea的隐式转换：

测试sql：
create table test(a bytea);
insert into test values('111');
insert into test values('111'::varchar);

oracle用户大小写问题：

用户名读取大小写不敏感, 存储按照大写存储


数据库登录方式：

ftp://uxsino@192.30.1.2/centos_new.zip   之前张庆年传的
dm：

启动达梦：
./dbserver ini文件





oracle:
启动数据库：
https://www.linuxidc.com/Linux/2014-04/100590.htm
sqlplus "/as sysdba"

oracle 安装：

https://blog.csdn.net/ywd1992/article/details/92830401

一、oracle登录及用户创建：
1、打开监听  lsnrctl start
2、打开sqlplus程序  sqlplus /nolog

3、在sqlplus连接数据库 connect /as sysdba
4、启动oracle 数据库 startup

5、创建用户
create user ora_user9 identified by 123456;

授权
grant create session,connect,resource to ora_user9;
grant resource to ora_user9;
grant unlimited tablespace to ora_user9;

6、连接数据库conn
conn ora_user1;

二、进行隐士转换：
select to_char(cast('abcdhjhhh' as varchar(100))) from dual;

三、显示时分秒设置：//设置后需要重启oracle数据库
alter system set nls_date_format= 'yyyy-mm-dd hh24:mi:ss' scope=spfile;


四、oracle下常用的系统表和系统视图
https://blog.51cto.com/jim123/1947872

五、28s现场问题

proc手册：
1、类型长度介绍：在第4章节


ROWID




密码有效时长问题：

设置有效时长参数：
1、超级用户设置有效时长（超级用户）
alter system set role_password_lifetime TO 30;
select ux_reload_conf();

2、修改用户有效时间（uxop）
alter user u1 valid until '2021-05-20 18:11:58';

数据库报错：
the number of days before a password expires should be less than or equal to %d.

密码输错报错：
password authentication failed for user \"%s\" , wrong input \"%d\" times

2021-04-30

1、检查权限
ux_class_aclmask
添加系统表：
ux_audit_infringement

AUDITINFRINGEMENT


添加注释：
/* Begin add by wangqi for #107103 at 2021.04.30 */
/* End add by wangqi for #107103 at 2021.04.30 */

修改lock_choose
bool lock_choose(void)
{
	MemoryContext oldcontext;
	int curr_number = -1;
	ListCell	*lc;
	//  if ( auditfgCxt )
	//  {
	// 	 auditfgCxt = AllocSetContextCreate(TopMemoryContext,
	// 				"audit context",
	// 			  	 ALLOCSET_DEFAULT_SIZES);
	//  }
	//oldcontext = MemoryContextSwitchTo(MessageContext);

	TimestampTz	min_timestamp ;
	TimestampTz	*curptr = NULL;
	TimestampTz currtime = 0;
	TimestampTz *oldtime[10] = { 0 };
	int oldnum = 0;
	curptr = polloc(sizeof(TimestampTz));
	currtime = GetCurrentTimestamp();
	*curptr = currtime;
	int64 		acl_valid_msecs = (int64)acl_fail_interval_time * SECS_PER_MINUTE * INT64CONST(1000) * INT64CONST(1000);
	min_timestamp = currtime - acl_valid_msecs;

	acl_fail_time_list = lappend_int_new(acl_fail_time_list, (void *)curptr);

	foreach(lc, acl_fail_time_list)
	{
		TimestampTz lctime= *(TimestampTz *)lc->data.ptr_value;
		if(min_timestamp -  lctime > 0)
		{
			oldtime[oldnum] = (TimestampTz *)lc->data.ptr_value;
			oldnum++;
		}

	}
	for (int i = 0; i < oldnum; i++)
	{
		acl_fail_time_list = list_delete(acl_fail_time_list, oldtime[i]);
	}

	curr_number = list_length(acl_fail_time_list);
	if(curr_number < acl_fail_lock_number)
	{
		return true;
	}
	else
	{
		return false;
	}

	//MemoryContextSwitchTo(oldcontext);
}


保密四期支持：
目前1个问题：
1、潜在侵害分析：
今天需求新增要求，需要具体到对表做策略；
现行临时方案：
增加结构体（记录表oid、失败时间戳）；
解决malloc问题，增加kill信号退出当前idle；（已修改）

存在风险：1、潜在侵害分析问题（计划在5月7号完成）


国防科大支持：
106884：

---查询表注释


select relname as table_name,cast(obj_description(relfilenode,'ux_class') as varchar) as comments, relkind as table_type from ux_class c  where relkind = 'r' and relname='TB';


---查询列注释

SELECT
a.attname as "字段名",
col_description(a.attrelid,a.attnum) as "注释",
c.relname
FROM
ux_class as c,
ux_attribute as a
WHERE  a.attrelid = c.oid
and a.attnum>0 and c.relkind='r' and c.relname ='TB';




dm实现功能语句：

1、表结构
owner  table_name   table_type   comments(注释)
select * from USER_TAB_COMMENTS;

select * from SYS_CATALOG.USER_COL_COMMENTS ;
select * from SYS_CATALOG.USER_TAB_COMMENTS ;

2、查询列注释信息

owner  table_name   column_name     comments
select * from USER_COL_COMMENTS where table_name = tb;

TEST=# \d+ SYS_CATALOG.USER_TAB_COMMENTS ;
                      View "SYS_CATALOG.USER_TAB_COMMENTS"
   Column   |             Type             | Modifiers | Storage  | Description
------------+------------------------------+-----------+----------+-------------
 TABLE_NAME | CHARACTER VARYING(63 byte)   |           | extended |
 TABLE_TYPE | CHARACTER VARYING(11 byte)   |           | extended |
 COMMENTS   | CHARACTER VARYING(4000 char) |           | extended |
View definition:
 SELECT C.RELNAME::CHARACTER VARYING(63 byte) AS TABLE_NAME,
        CASE C.RELKIND
            WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::CHARACTER VARYING(11 byte) AS TABLE_TYPE,
    D.DESCRIPTION::CHARACTER VARYING(4000 char) AS COMMENTS
   FROM SYS_CLASS C,
    SYS_DESCRIPTION D,
    SYS_USER AU
  WHERE C.OID = D.OBJOID AND D.CLASSOID = 1259::OID AND D.OBJSUBID = 0 AND C.RELOWNER = AU.USESYSID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AU.USENAME = "CURRENT_USER"()::CHARACTER VARYING(63 byte)::NAME;

\d+: extra argument ";" ignored


TEST=# \d+ SYS_CATALOG.USER_COL_COMMENTS ;
                      View "SYS_CATALOG.USER_COL_COMMENTS"
   Column    |             Type             | Modifiers | Storage  | Description
-------------+------------------------------+-----------+----------+-------------
 OWNER       | CHARACTER VARYING(63 byte)   |           | extended |
 TABLE_NAME  | CHARACTER VARYING(63 byte)   |           | extended |
 COLUMN_NAME | CHARACTER VARYING(63 byte)   |           | extended |
 COMMENTS    | CHARACTER VARYING(4000 char) |           | extended |
View definition:
 SELECT A.USENAME::CHARACTER VARYING(63 byte) AS OWNER,
    C.RELNAME::CHARACTER VARYING(63 byte) AS TABLE_NAME,
    AT.ATTNAME::CHARACTER VARYING(63 byte) AS COLUMN_NAME,
    D.DESCRIPTION::CHARACTER VARYING(4000 char) AS COMMENTS
   FROM SYS_USER A,
    SYS_CLASS C,
    SYS_ATTRIBUTE AT
     LEFT JOIN SYS_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJOID = AT.ATTRELID AND AT.ATTNUM = D.OBJSUBID
  WHERE AT.ATTRELID = C.OID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AT.ATTNUM > 0 AND AT.ATTISDROPPED = false AND C.RELOWNER = A.USESYSID AND A.USENAME = "CURRENT_USER"()::CHARACTER VARYING(63 byte)::NAME;

\d+: extra argument ";" ignored

pg实现：
将视图添加到
system_views.sql

1、查询表注释

select relname as table_name,cast(obj_description(relfilenode,'ux_class') as varchar) as comments, relkind as table_type from ux_class c  where relkind = 'r' and relname='TB';

SELECT
A.USENAME::varchar as OWNER，
C.RELNAME::varchar AS TABLE_NAME,
	   CASE C.RELKIND
			WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::CHARACTER VARYING(11 byte) AS TABLE_TYPE,
		cast(obj_description(relfilenode,'ux_class') as varchar) as COMMENTS
	from ux_user A,
		ux_class C where A.usename = "CURRENT_USER"()::varchar::NAME;










/*******************************************
已经验证成功：
*******************************************/
select
A.USENAME as OWNER,
C.RELNAME as TABLE_NAME,
CASE C.RELKIND
			WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::varchar AS TABLE_TYPE,
cast(obj_description(relfilenode,'ux_class') as varchar) as COMMENTS
from
ux_class C,
ux_user A
where relname='TB' and A.usename = "CURRENT_USER"()::varchar::NAME;


人大金仓：
1、人大金仓与uxdb关系
uxdb缩写ux，人大金仓缩写sys；



create view USER_TAB_COMMENTS AS SELECT
	AU.USENAME as OWNER,
	C.RELNAME::varchar AS TABLE_NAME,
        CASE C.RELKIND
            WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::varchar AS TABLE_TYPE,
    D.DESCRIPTION::varchar AS COMMENTS
   FROM UX_CLASS C,
    UX_DESCRIPTION D,
    UX_USER AU
  WHERE C.OID = D.OBJOID AND D.CLASSOID = 1259::OID AND D.OBJSUBID = 0 AND C.RELOWNER = AU.USESYSID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AU.USENAME = "CURRENT_USER"()::varchar::NAME;


2、查询列注释信息

SELECT
A.USENAME as OWNER,
C.RELNAME as TABLE_NAME,
D.attname as COLUMN_NAME,
col_description(D.attrelid,D.attnum) as COMMENTS
FROM
ux_user A,
ux_class as C,
ux_attribute as D
WHERE  D.attrelid = C.oid
and D.attnum>0 and C.relkind='r' and C.relname ='TB' and A.usename = "CURRENT_USER"()::varchar::NAME;



create view USER_COL_COMMENTS AS SELECT A.USENAME::varchar AS OWNER,
    C.RELNAME::varchar AS TABLE_NAME,
    AT.ATTNAME::varchar AS COLUMN_NAME,
    D.DESCRIPTION::varchar AS COMMENTS
   FROM UX_USER A,
    UX_CLASS C,
    UX_ATTRIBUTE AT
     LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJOID = AT.ATTRELID AND AT.ATTNUM = D.OBJSUBID
  WHERE AT.ATTRELID = C.OID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AT.ATTNUM > 0 AND AT.ATTISDROPPED = false AND C.RELOWNER = A.USESYSID AND A.USENAME = "CURRENT_USER"()::varchar::NAME;

objsubid 对于一个表字段的注释，它是字段号，对应于pg_attribute.attnum。对于其它对象类型，它是零。
relowner（所有者）都是用其对应的oid显示





问题：

uxdb的UX_DESCRIPTION中没有CLASSOID=1259，
OBJOID中不存在1259 oid，

1、人大金仓获取所有表结构以及注释，
通过筛选ux_class所属对象的oid在ux_description中，将表名、表类型、注释、列名添加到USER_TAB_COMMENTS、USER_COL_COMMENTS视图中，
但咱数据库uxdb没有ux_description所属对象的oid的注释信息，导致查询结果为空，目前需分析人大金仓ux_description的结构信息

2、人大金仓与达梦获取表结构没有字段owner;

pg_description介绍：
1、pg_description有四个字段
OBJOID：
CLASSOID：		系统目录oid（如：ux_class）
OBJSUBID：
DESCRIPTION：

/*******************************************
已经验证成功：
*******************************************/

添加表注释：



添加列注释：

1、
create view USER_COL_COMMENTS AS SELECT A.USENAME::CHARACTER VARYING(63) AS OWNER,
    C.RELNAME::CHARACTER VARYING(63) AS TABLE_NAME,
    AT.ATTNAME::CHARACTER VARYING(63) AS COLUMN_NAME,
    D.DESCRIPTION::CHARACTER VARYING(4000) AS COMMENTS
   FROM UX_USER A,
    UX_CLASS C,
    UX_ATTRIBUTE AT
     LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJOID = AT.ATTRELID AND AT.ATTNUM = D.OBJSUBID
  WHERE AT.ATTRELID = C.OID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AT.ATTNUM > 0 AND AT.ATTISDROPPED = false AND C.RELOWNER = A.USESYSID AND A.USENAME = "CURRENT_USER"()::CHARACTER VARYING(63)::NAME;

2、
create view USER_COL_COMMENTS AS SELECT A.USENAME::varchar AS OWNER,
    C.RELNAME::varchar AS TABLE_NAME,
    AT.ATTNAME::varchar AS COLUMN_NAME,
    D.DESCRIPTION::varchar AS COMMENTS
   FROM UX_USER A,
    UX_CLASS C,
    UX_ATTRIBUTE AT
     LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJOID = AT.ATTRELID AND AT.ATTNUM = D.OBJSUBID
  WHERE AT.ATTRELID = C.OID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AT.ATTNUM > 0 AND AT.ATTISDROPPED = false AND C.RELOWNER = A.USESYSID AND A.USENAME = "CURRENT_USER"()::varchar::NAME;


添加表注释：
1、
create view USER_TAB_COMMENTS AS SELECT
	C.RELNAME::CHARACTER VARYING(63) AS TABLE_NAME,
        CASE C.RELKIND
            WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::CHARACTER VARYING(11) AS TABLE_TYPE,
    D.DESCRIPTION::CHARACTER VARYING(4000) AS COMMENTS
   FROM UX_USER AU,
	UX_CLASS C
	LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJSUBID = 0 AND D.OBJOID = C.OID
  WHERE  C.RELOWNER = AU.USESYSID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AU.USENAME = "CURRENT_USER"()::CHARACTER VARYING(63)::NAME;

2、
create view USER_TAB_COMMENTS AS SELECT
	AU.USENAME as OWNER,
	C.RELNAME::varchar AS TABLE_NAME,
        CASE C.RELKIND
            WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::varchar AS TABLE_TYPE,
    D.DESCRIPTION::varchar AS COMMENTS
   FROM UX_USER AU,
	UX_CLASS C
	LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJSUBID = 0 AND D.OBJOID = C.OID
  WHERE  C.RELOWNER = AU.USESYSID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AU.USENAME = "CURRENT_USER"()::varchar::NAME;

注意事项：
1、达梦注释为空也会添加到视图USER_TAB_COMMENTS中，

gfkd:
uxdb-std-kylin-aarch64-v2.1.0.3.029.p2.tar.gz


2021-05-10
begin语法改造
1、
begin select 1 from dual;end;

2、
https://www.yiibai.com/manual/postgresql/sql-begin.html

3、语法改造
	j=strlen(query_string);
	for( i=j;i>=5;i--)
	{
		query_string[i+1] = query_string[i];
	}
	query_string[5] = ';';


if (!strncasecmp(sql, "BEGIN", 5))
			{
				memset(dest, 0, MAX_SQL_LEN);
				strcat(dest, "do #_UX_# ");
				strcat(dest, sql);
				strcat(dest, " #_UX_#;");
				strcpy(sql, dest);
				printf("********sql = %s**************\n", sql);
			}

3、匿名块

do $$ begin delete from TB;commit;end;$$

oci.c:OCIStmtExecute

begin语句改造

修改方案：
方案一：在exec_simple_query直接修改sql语句；

  if(!strncasecmp(query_string,"BEGIN ",6))
  {
    strcpy(temp, "do $$ ");
    strcat(temp, sql);
    strcat(temp, " $$;");
    strcpy(query_string, temp);
  }



方案二：
修改OCI语法：
OCI 输入sql语法格式：
begin;begin + sql + end;
将sql语法改造为匿名块语法传到后端（目前分析sql在oci prepare阶段未做拼接，目前不清楚sql拼接代码位置）；


do $$   $$;



2021-05-12

1、begin空格问题

2、
可以在
inputmessage去改

3、
#0  UXAPI_Execute (hstmt=hstmt@entry=0x6293e0, flag=flag@entry=1) at execute.c:939
#1  0x00007ffff6d459f0 in SQLExecute (StatementHandle=0x6293e0) at odbcapi.c:390


4、oci转换
statement.c:
SC_execute

begin语法优化：

static
char *ux_strrpc(char *str, char *oldstr, char *newstr)
{
	char bstr[MAX_SQL_LEN]; //转换缓冲区
	memset(bstr, 0, sizeof(bstr));

	for (int i = 0; i < strlen(str); i++)
	{
		if (!strncmp(str + i, oldstr, strlen(oldstr)))
		{ //查找目标字符串
			strcat(bstr, newstr);
			i += strlen(oldstr) - 1;
		}
		else
		{
			strncat(bstr, str + i, 1); //保存一字节进缓冲区
		}
	}

	strcpy(str, bstr);
	return str;
}


char *ux_strrpc1(char *str, char *oldstr, char *newstr)
{
    char *p1,*p2;
    char *src;
    p1 = strstr(str, oldstr);
    if (p1 == NULL)
     return;  /* do nothing */

    p2 = strstr(p1 + 6, oldstr);
    if (p2 == NULL)
     return;  /* do nothing */
    for (int i=0;i<6;i++)
    {
        *(p1++) = *(p2++) = *(newstr++);
    }
}

改造后：

strcasestr

static
char *ux_strrpc(char *str, char *oldstr, char *newstr)
{
    char *old_p;
	char *new_p;
    char *src;
	int len = strlen(oldstr);

	for(int i = 0; i < strlen(str); i+len)
	{
		old_p = NULL;
		new_p = newstr;
		/* 查找字串str中是否有固定字串oldstr并替换 */
		old_p = strstr(str, oldstr);
		if (old_p == NULL)
			return;  /* do nothing */

		for (int j=0;j<len;j++)
		{
			*(old_p++) = *(new_p++);
		}
	}
}

		for(int i = 0;i< strlen(string); i++)
        {
                string[i] = tolower(string[i]);

        }


最新改造：

void ux_strrpc(char *str, char *oldstr, char *newstr)
{
	char *p = str;
	int len = strlen(oldstr);

	/* 查找字串str中是否有固定字串oldstr并替换 */
	if(NULL != str)
	{
		for (int i = 0; i < strlen(str); i++)
		{
			if (!strncasecmp(p + i, oldstr, strlen(oldstr)))
			{ //查找目标字符串
				for (int j=0;j<len;j++)
					*(p++) = *(newstr++);
			}
		}
	}
}

tatic
char *ux_strrpc(char *str, char *oldstr, char *newstr)
{
	char *p = str; //转换缓冲区

	for (int i = 0; i < strlen(str); i++)
	{
		if (!strncasecmp(p + i, oldstr, strlen(oldstr)))
		{ //查找目标字符串
			for (int j=0;j<len;j++)
			*(p++) = *(newstr++);
		}
	}

}


2021-05-14

1、
CREATE TABLE CONSUMER_DN (
	DOMAIN_NAME					VARCHAR2(159),
	RDN_NAME					VARCHAR2(40),
	VERSION						NUMBER(10),
	CONSUMER_DOMAIN_NAME		VARCHAR2(159),
	SHADOW_FAILURE_TYPE			NUMBER(1),
	VALID_BEGINTIME				TIMESTAMP,
	VALID_ENDTIME				TIMESTAMP,
	SHADOW_BEGINTIME			TIMESTAMP,
	SHADOW_ENDTIME				TIMESTAMP,
	TABLE_NO					NUMBER(2),
	LASTUPDATETIME				TIMESTAMP,
	RECORD_UPDATETIME			TIMESTAMP		DEFAULT SYSDATE);

SQLT_AVC
SQLT_FLT
SQLT_TIMESTAMP


insert into CONSUMER_DN values('a','b',1,'c',2,'2016-05-20','2016-05-20','2016-05-20','2016-05-20',3,'2016-05-20');

2、storage语法支持

void ux_stroage(char *str, char *oldstr, char *newstr)
{
	char *p = str;
	int len = strlen(newstr);

	if(len != strlen(newstr) || len == 0)
		return;  /* do nothing */

	if(NULL == str)
		return;  /* do nothing */
	for (int i = 0; i < strlen(str); i++)
	{
		if (strncasecmp(p + i, oldstr, strlen(oldstr)) == 0)
		{ /* 查找目标字符串 */
			p = p+i;

			for(int j=0;j<len+1;j++)
				*(p++) = *(newstr++);

			return; /* 我们只替换一次 */
		}
	}
}

create table test111 (a name ) storage ( on main, cluetr);

create table test111 (a name ) tablespace main;


char
if(!strncasecmp(sql, "storage", 7))
{


}
for(int j = i + 1; j < strlen(str); j++)
	if(strncasecmp(p +j ,"(",1) == 0)
	{
			p = p+i;

			for(int j=0;j<len+1;j++)
				*(p++) = *(newstr++);
	}


2021-05-18
流复制
1、

主机：192.71.0.138
备机：192.71.0.140

流复制介绍：
https://blog.csdn.net/weixin_39540651/article/details/106122610




























2021-05-18

#!/bin/bash
read -p "please input the time you want count " i
a=$i
for ((b=0;b<$a;b++))
do
uxsql -U uxdb -d uxdb -c "select * from t1 limit 1"
<<EOF
localhost:5432:uxdb:uxdb:1qaz!QAZ
EOF
done
sql脚本
#!/bin/bash

for ((i=0;i<10;))
do
uxsql -U uxdb -d uxdb -c "insert into tb values(1);"
sleep 3
done

wal日志报错信息：
terminating walreceiver process due to administrator command

unexpected pageaddr 1/CC000000 in log segment 000000400000000200000012, offset 0


FATAL:  could not receive data from WAL stream: server closed the connection unexpectedly
                This probably means the server terminated abnormally
                before or while processing the request.

unexpected pageaddr %X/%X in log segment %s, offset %u

invalid magic number %04X in log segment %s, offset %u

确定哪个段文件
 unexpected pageaddr 0/BE01E000 in log segment 0000000100000000000000BE, offset 114688
hdr->xlp_pageaddr >> 32 = 0
hdr->xlp_pageaddr = BE01E000
fname = 0000000100000000000000BE
offset = 114688


offset = recptr % 16M
segno = recptr / 16M

recaddr = segno *16M + offset



wal_level = minimal
archive_mode = on  //备库上已注释掉
#根据实际业务需求配置
archive_command =’ cp %p  /host/postgres/pgarchive/%f’   //备库上已注释掉
#根据实际业务需求配置
max_wal_senders = 5
#根据实际业务需求配置
wal_keep_segments = 50000
hot_standby = on
wal_log_hints = on


5790701d8c695342f79983e1a4529907ecbe9a93

ca88c439c57e1bba725d888448a3e63706831900


xlog日志机制：
https://doc.docsou.com/b30046f8470aab0e97bdbe99fc48147e74fe71353.html

块的头部：
wal日志以8k为一个文件块，16M为一个文件。

块头
XLogPageHeaderData



重庆传晟研发支持进度：
https://www.cnblogs.com/ilifeilong/p/7002687.html
根据现场反馈，主库跑了25GB数据，非必要不想动主库；
目前分析进度：分析流复制原理，流复制通过不断传输应用WAL record实现，
读取流程:startup ->uxmaster(standby模式需要通知uxmaster启动一个walreceiver进程)->walreceiver->读取xlog(WAL record)
目前报错是在xlog record地址校验报错，由于数据报错需压测重现，目前通过打印日志分析流复制地址偏移具体报错位置，具体位置待分析
项目紧急情况：待反馈


区域化研发支持进度：

.net问题，要链接咱uxdb数据库，需要修改链接函数，由于该函数在客户源码中，
客户那边研发较忙，目前无法提供源码，具体适配时间待定



项目紧急情况：待反馈
wal日志学习：
1、流复制
https://www.cnblogs.com/yickel/p/11161706.html

2、预写日志代码详解日志：
http://mysql.taobao.org/monthly/2017/03/02/

主备总体结构
https://www.cnblogs.com/ilifeilong/p/7002687.html


https://blog.csdn.net/iteye_4537/article/details/82394998

预写日志代码详解日志：
http://mysql.taobao.org/monthly/2017/03/02/

XLogBackgroundFlush将xlog日志开始位置和结束位置传递给XLogWrite函数进行写日志操作。

PG主备流复制的核心部分由walsender，walreceiver和startup三个进程组成。
walsender进程是用来发送WAL日志记录的，执行顺序如下：
PostgresMain()->exec_replication_command()->StartReplication()->WalSndLoop()->XLogSendPhysical()
walreceiver进程是用来接收WAL日志记录的，执行顺序如下：
sigusr1_handler()->StartWalReceiver()->AuxiliaryProcessMain()->WalReceiverMain()->walrcv_receive()
startup进程是用来apply日志的，执行顺序如下：
PostmasterMain()->StartupDataBase()->AuxiliaryProcessMain()->StartupProcessMain()->StartupXLOG()

重庆传晟研发支持进度：

通过打印xlog record地址，在读取wal日志时wal日志页多偏移8192字节，通过解读备机wal日志，
根据报错偏移位置获取wal日志对应偏移量与具体偏移值不相等，解读主机存在同样问题，故排除流复制问题，
通过验证单机模式下，同样存在该问题，故该问题在写xlog日志导致，通过查看xlog写日志逻辑，加密写入wal日志的时候，
openLogOff偏移计算不正确，修改后解读wal日志正常



2021-05-31

create table test(id1 int, id2 int ,id3 int, id4 int, id5 int);
insert into test values(1,1,1,1,1);
insert into test values(2,2,2,2,2);
merge into test d using (select  id1,id2,id3 from test) s on (d.id1 = 1 and s.id1 = d.id1)
when matched then update set d.id3 = 999, d.id4 =999 when not matched then insert (id1,id2,id3,id4,id5)  values(9,9,9,9,9);


using搜出来的结果逐条与on条件匹配，根据连接条件，对目标表进行查询，
连接条件匹配上进行update，否则insert，目前功能只

目标和源关系之间

2021-06-04

vacuum机制

#109226问题复现，问题定位在语法分析时，type类型未分配内存导致；

vacuum机制了解，分析查看Lazy_vacuum_rel函数功能

参加内存管理培训讨论

2021-06-07

OdirectWrite
if(buf非按512字节对齐)
else（buf地址按512字节对齐）

buf：
1、判断buf是否按512字节对齐

2、AlignedCountSize  按字节对齐（如：count小于512，AlignedCountSize = 512）

3、

main.c:

./s fw ./t1 2 2 2 2
fw:
./t1:  打开的文件
2：多少个512
2：文件内容
2：buf偏移多少
2：指针偏移多少

2021-06-08
ux_control
1、ux_control介绍
https://zhuanlan.zhihu.com/p/359402697

2、ux_control文件代码
https://blog.csdn.net/xichenguan/article/details/109339556

ux_control的结构体：ControlFileData

查看当前检查点状态信息
select *from ux_control_checkpoint();

借助工具查看ux_control中的数据
./ux_controldata -D master

WriteControlFile			//创建ux_control文件

	memset(buffer, 0, PG_CONTROL_FILE_SIZE);
	memcpy(buffer, ControlFile, sizeof(ControlFileData));

__O_DIRECT:字节对齐参数

posix_memalign：
int posix_memalign (void **memptr,
                    size_t alignment,
                    size_t size);

申请size大小字节的内存，memptr地址是alignment的倍数

initdb源码分析：
https://www.cnblogs.com/gaojian/p/3173776.html





1 odirect封装模块加入db代码,使用ux_control文件的odirect读写进行测试。
2 编写odirect封装模块文档(10%)。
3 参加研发内存管理培训



super_rac.auto.conf



ux_hba.conf
ux_ident.conf

2021-06-11

1、fputs
定义：
int fputs(const char *s, FILE *stream);

pg初始化写入配置文件数据通过fputs函数行数据写入，与write实现差异较大，
fputs传字符串到一个文件流中，也就是在缓冲区进行读写操作，与write实现差异较大，

fputs传字符串到一个文件流中，数据在缓冲区进行读写操作，pg初始化写入配置文件数据通过行数据写入，

fopen学习：
https://blog.csdn.net/weixin_39770592/article/details/117206063

fputs细节：
https://blog.csdn.net/weixin_30677073/article/details/96883311





initdb初始化写入配置文件数据通过fputs函数行数据写入，故不能单独封装fputs，
在fputs写入数据后，修改为512对齐，目前修改针对写入数据后对齐，本地demo验证通过




        int offset = fputs(s, fp);
        offset = ftell(fp);
        fseek(fp, offset, SEEK_SET);
        int offset2 = fputs(s1, fp);
        offset2 = ftell(fp);
共享存储问题单：
 #109187
代码分支：
feature/v2.1.0.6.01r/#109187

#110114：表文件读写接入direct io
 pg_logdir_ls()、pg_ls_dir()、pg_file_rename()、ux_file_write()、 pg_read_file()、pg_length_file()

问题单：
#110114：6.15完成
mdwrite/mdread/mdopen


#110118：6.18日完成
在线恢复：
在线恢复文件:recovery_set.c
入口：
ScanWalConstructRecoverySet




全局控制文件/本实例控制文件的读写操作和文件初始化时的字节对齐

1、全局控制文件和本实例控制文件初始化位置
控制文件初始化：
函数：
WriteControlFile
2、全局控制文件读写
xlog.c: 9418  ReadNeedRecoveryList（已修改）
UpdateGlobalControlFile（已修改）
ReadControlFileByPath（已修改）
UpdateControlFileByPath（已修改）


3、实例控制文件读写（本地控制文件）
xlog.c: OpControlFileByInstID（已修改）
ReadControlFileByPath（已修改）

wal日志相关接口：

XLogFileOpen

写wal日志：
XLogWrite

读wal日志：
在线恢复：
ReadCheckpointRecord

wal日志读取接口：
https://www.ofweek.com/ai/2021-05/ART-201713-11000-30499302.html
StartupXLOG		//启动恢复函数，该函数从ux_control文件中读取checkpoint记录，然后从checkpoint记录的redo点开始进行恢复


读取接口：
XLogPageRead

control文件：
1、ReadControlFileDataByPath

wal日志写日志通过函数XLogWrite，
wal日志读取流程：
StartupXLOG	//启动恢复函数，该函数从ux_control文件中读取checkpoint记录，然后从checkpoint记录的redo点开始进行恢复
	ReadRecord		//循环读取wal记录
		XLogReadRecord
			ReadPageInternal
				state->read_page	//回调指针调用XLogPageRead函数读取wal日志信息


dopne/dwrite/dread代码
1、open：UX_DIRECTIO
2、read：
read(fd, ControlFile, sizeof(ControlFileData)) != sizeof(ControlFileData)
OdirectRead(fd, ControlFile, sizeof(ControlFileData)) != sizeof(ControlFileData)

3、write
write(fd, ControlFile, sizeof(ControlFileData)) != sizeof(ControlFileData)
OdirectWrite(fd, ControlFile, sizeof(ControlFileData)) != sizeof(ControlFileData)

4、close
OdirectCloseFile

4、添加宏
#if UXDB_RAC_ODIRECT1
#else
#endif

wal日志修改函数：
XLogWritePages
XLogFileInit
XLogFileOpen
XLogPageRead

在线恢复：
总接口
ExcuteOnlineRecovery

在线恢复相关控制文件接口，
ReadControlFileByPath
ReadControlFileDataByPath
ReadControlFileTo
目前代码中已经修改，
修改wal日志direct接口，
主要修改XLogWrite写日志函数、XLogPageRead读日志接口，
修改验证通过，代码已提交


1. 梳理了control文件要改的几个地方：
controldata_utils.c :44   get_controlfile
xlog.c: 9418  ReadNeedRecoveryList
UpdateControlFileByPath  更新全局control文件
OpControlFileByInstID 更新实例control文件 (先不管)
uxmaster.c:2463  fp = AllocateFile(path, UX_BINARY_R);

2、
1 uxmaster.c中使用AllocateFile函数调用fopen进行了打开，直接修改fopen改动较大，添加AllocateFileOdirect函数实现替换。
2 uxmaster.c中使用regular_copy_file_odirect函数进行文件拷贝时，修改其中接口为Odirect。
  问题：
  修改regular_copy_file_odirect函数测试发现启动实例时提示uxsinodb.conf文件有错误标识符，分析得知拷贝函数拷贝了ux_control、uxsinodb.conf、uxsinodb.auto.conf三个文件，因conf文件为普通文本文件，且文件大小未512对齐，所以OdirectWrite写入时进行了对齐，文件末尾增加了一些空字符(assicci的0)导致错误，ux_control文件本身就是二进制文件所以未报错。
  目前处理是加了判断，只有拷贝ux_control文件时才调用odirect接口，其他文件拷贝走原流程。
明天进一步分析解决方法。


问题单110148：
服务器：
192.30.0.246,
192.30.0.249

用户/密码：uxdb/uxdb_rac123456

InitiatorName=iqn.1994-05.com.redhat:75a2cffb76c

mkpart sdd4 300GB 400GB


2021-6-21

共享存储任务：
svn://192.30.1.2/svn/uxdb/30.项目/01.SRAC/03.SRACv2.1.0.6/02.管理域/01 项目计划

1、离线恢复：StartupXLOGMultiInst
9653-11497行

读取控制文件：
ReadControlFile
traverseControlFiles
OpControlFileByInstID



底层控制文件：
ReadControlFileByPath
ReadNeedRecoveryList
UpdateControlFileByPath
UpdateControlFile

任务：
Clog文件启动时的拷贝方式 后续需要调整为网络传输文件字节流的方式

clog日志管理器

1个字节可存储4个事物的CLOG记录，所以一个页面（8KB）可记录2的15次方；
由于一个日志段由32个页面组成，故一个clog日志记录2的20次方个事物；

事物ID为32比特，因此事物数有2的32次方个。


2021-06-22

initdb.c:1505
super_rac.auto.conf
19503

110801
查看带宽命令：
https://blog.51cto.com/u_13718210/2418661


linux:

查看磁盘读写性能/io
sudo fio -filename=/var/test.file -direct=1 -iodepth 1 -thread -rw=randrw -rwmixread=70 -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=100 -group_reporting -name=mytest1

查看带宽：
首先安装工具：
yum install epel-release
yum install libpcap nethogs

通过 nethogs 查看

python测试带宽
https://www.cnblogs.com/setout/p/10315082.html

磁盘转速命令：
sginfo -g /dev/sdf

测试网络带宽：
ethtool em2

1、super_rac.auto.conf 集群配置参数信息记录文件的读写操作和文件初始化时的字节对齐，分析fgets函数替换方案，由于该问题优先级低，暂不处理
2、分析共享磁盘读写io性能问题， 通过sar命令查看 CPU 、内存、磁盘、网络等性能


uxbench性能为什么变低？

查看磁盘IO性能：
https://www.cnblogs.com/mauricewei/p/10502539.html

iops(每秒执行的IO次数)、
bw（带宽，每秒的吞吐量）

request the lock mode(12) timeout from instance 2 for block 5444 of relation base/13231/16389

读写磁盘：
tps: 每秒向磁盘设备请求数据的次数，包括读、写请求，为rtps与wtps的和。
rtps: 每秒向磁盘设备的读请求次数

wtps: 每秒向磁盘设备的写请求次数

bread: 每秒从磁盘读的bytes数量

bwrtn: 每秒向磁盘写的bytes数量

共享存储问题单 109913：


测试写性能命令：
本地：
direct | sync：
time dd if=/dev/zero of=test.file bs=10M count=2 oflag=direct oflag=sync
非direct
time dd if=/dev/zero of=test.file bs=10M count=2

共享盘：
direct | sync：
time dd if=/dev/zero of=test.file bs=10M count=2 oflag=direct oflag=sync
非direct
time dd if=/dev/zero of=test.file bs=10M count=2

测试读性能命令：
本地：
direct | sync：
dd if=test.file if=/dev/null  iflag=direct oflag=sync
非direct：
dd if=test.file if=/dev/null

共享盘：
direct | sync：
dd if=test.file if=/dev/null  iflag=direct oflag=sync
非direct：
dd if=test.file if=/dev/null

fio：

fio -filename=test.file -direct=1 -iodepth 1 -thread -rw=read -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=test_r




旧盘（109）
异步
顺序读：
READ: bw=1066MiB/s (1117MB/s), 1066MiB/s-1066MiB/s (1117MB/s-1117MB/s)    , io=30.0GiB (32.2GB), run=28830-28830msec		IOPS=68.2k

顺序写：
WRITE: bw=60.9MiB/s (63.9MB/s), 60.9MiB/s-60.9MiB/s (63.9MB/s-63.9MB/s), io=3654MiB (3832MB), run=60004-60004msec			IOPS=3897


随机读：
READ: bw=1015MiB/s (1064MB/s), 1015MiB/s-1015MiB/s (1064MB/s-1064MB/s), io=30.0GiB (32.2GB), run=30271-30271msec			IOPS=64.9k

随机写：
WRITE: bw=60.0MiB/s (63.9MB/s), 60.0MiB/s-60.0MiB/s (63.9MB/s-63.9MB/s), io=3670MiB (3848MB), run=60198-60198msec			IOPS=3901

混合读写：
READ: bw=22.9MiB/s (24.0MB/s), 22.9MiB/s-22.9MiB/s (24.0MB/s-24.0MB/s), io=2293MiB (2405MB), run=100002-100002msec			IOPS=1467
  WRITE: bw=9.84MiB/s (10.3MB/s), 9.84MiB/s-9.84MiB/s (10.3MB/s-10.3MB/s), io=984MiB (1032MB), run=100002-100002msec		IOPS=629

模式：同步
顺序读：
READ: bw=1057MiB/s (1108MB/s), 1057MiB/s-1057MiB/s (1108MB/s-1108MB/s), io=30.0GiB (32.2GB), run=29073-29073msec		IOPS=67.6k

顺序写：
WRITE: bw=87.8MiB/s (92.1MB/s), 87.8MiB/s-87.8MiB/s (92.1MB/s-92.1MB/s), io=5268MiB (5524MB), run=60006-60006msec		IOPS=5619

随机读：
READ: bw=252MiB/s (265MB/s), 252MiB/s-252MiB/s (265MB/s-265MB/s), io=14.8GiB (15.9GB), run=60006-60006msec			IOPS=16.2k

随机写：
WRITE: bw=109MiB/s (114MB/s), 109MiB/s-109MiB/s (114MB/s-114MB/s), io=6525MiB (6842MB), run=60018-60018msec			IOPS=6957

混合读写：
READ: bw=164MiB/s (172MB/s), 164MiB/s-164MiB/s (172MB/s-172MB/s), io=16.1GiB (17.2GB), run=100005-100005msec					IOPS=10.5k
WRITE: bw=70.5MiB/s (73.9MB/s), 70.5MiB/s-70.5MiB/s (73.9MB/s-73.9MB/s), io=7050MiB (7392MB), run=100005-100005msec				IOPS=4511


顺序读：
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=read -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

READ: bw=181MiB/s (189MB/s), 181MiB/s-181MiB/s (189MB/s-189MB/s), io=10.6GiB (11.4GB), run=60002-60002msec

顺序写：
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=write -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

WRITE: bw=132MiB/s (138MB/s), 132MiB/s-132MiB/s (138MB/s-138MB/s), io=7896MiB (8280MB), run=60003-60003msec

随机读：
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=randread -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

READ: bw=129MiB/s (135MB/s), 129MiB/s-129MiB/s (135MB/s-135MB/s), io=7753MiB (8129MB), run=60004-60004msec

随机写：
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=randwrite -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

混合读写
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=randrw -rwmixread=70 -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=100 -group_reporting -name=mytest1




新盘（107异步）
顺序读：
READ: bw=182MiB/s (191MB/s), 182MiB/s-182MiB/s (191MB/s-191MB/s), io=10.7GiB (11.5GB), run=60004-60004msec						IOPS=11.6k

顺序写：
WRITE: bw=380MiB/s (398MB/s), 380MiB/s-380MiB/s (398MB/s-398MB/s), io=22.3GiB (23.9GB), run=60001-60001msec						IOPS=24.3k


随机读：
READ: bw=76.1MiB/s (79.8MB/s), 76.1MiB/s-76.1MiB/s (79.8MB/s-79.8MB/s), io=4569MiB (4790MB), run=60006-60006msec				IOPS=4872

随机写：
WRITE: bw=44.1MiB/s (46.2MB/s), 44.1MiB/s-44.1MiB/s (46.2MB/s-46.2MB/s), io=2646MiB (2775MB), run=60007-60007msec				IOPS=2822

混合读写：
READ: bw=41.9MiB/s (43.9MB/s), 41.9MiB/s-41.9MiB/s (43.9MB/s-43.9MB/s), io=4191MiB (4395MB), run=100005-100005msec				IOPS=2682
  WRITE: bw=18.0MiB/s (18.9MB/s), 18.0MiB/s-18.0MiB/s (18.9MB/s-18.9MB/s), io=1800MiB (1888MB), run=100005-100005msec			IOPS=1152
  
  


新盘（107同步）
顺序读：
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=read -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

READ: bw=181MiB/s (189MB/s), 181MiB/s-181MiB/s (189MB/s-189MB/s), io=10.6GiB (11.4GB), run=60002-60002msec		IOPS=11.6k

顺序写：
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=write -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

WRITE: bw=132MiB/s (138MB/s), 132MiB/s-132MiB/s (138MB/s-138MB/s), io=7896MiB (8280MB), run=60003-60003msec		IOPS=8422

随机读：
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=randread -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

READ: bw=129MiB/s (135MB/s), 129MiB/s-129MiB/s (135MB/s-135MB/s), io=7753MiB (8129MB), run=60004-60004msec		IOPS=8268

随机写：
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=randwrite -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

WRITE: bw=21.7MiB/s (22.8MB/s), 21.7MiB/s-21.7MiB/s (22.8MB/s-22.8MB/s), io=1613MiB (1691MB), run=74318-74318msec		IOPS=1388

混合读写
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=randrw -rwmixread=70 -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=100 -group_reporting -name=mytest1

READ: bw=35.0MiB/s (37.7MB/s), 35.0MiB/s-35.0MiB/s (37.7MB/s-37.7MB/s), io=3597MiB (3772MB), run=100006-100006msec			IOPS=2302
 WRITE: bw=15.5MiB/s (16.2MB/s), 15.5MiB/s-15.5MiB/s (16.2MB/s-16.2MB/s), io=1547MiB (1622MB), run=100006-100006msec		IOPS=989

2021-06-24

1、查看磁盘转速
sginfo -g /dev/sdc

2、磁盘型号
华为oceanstor 5110 v5



永久生成core
#vim /etc/profile，然后进入编辑模式，在profile文件中加入
ulimit -c unlimited
保存退出，重启服务器，改文件就长久生效，或者#source /etc/profile，不重启服务器，使用source使文件马上生效。
指定生成文件的路径和名字；执行# vim /etc/sysctl.conf，进入编辑模式，加入下面两行
kernel.core_pattern=/home/uxdb/coreFile/core-%e-%p-%t
kernel.core_uses_pid=1

1：添加pid作为扩展名，生成的core文件名称为core.pid
0：不添加pid作为扩展名，生成的core文件名称为core

sudo sysctl -p /etc/sysctl.conf 使其生效



2021-07-06

高速缓存
1、访问表的模式、列属性、OID、统计信息等
2、模式在系统表中，所以首先访问系统表模式信息（故设立Cache，包含系统表元祖SysCache和表模式信息RelCache，RelCache中存放的是RelationData结构体，每一个RelationData表示一个表模式信息）
SysCache:（CatCache SysCache[64]）
1、SysCache 主要缓存系统表元祖，是一个数组，每个元素是一个CatCache数据结构（每个CatCache对应一个系统表），该结构体内使用Hash存储系统表元祖；
2、CatCache中有若干个查找关键字，用来查找系统表元祖；
3、CatCache通过其cc_next字段构成一个单向链表，其头部用全局变量CacheHdr记录；
4、SysCache.c已经将所有系统表CatCache信息存储在cacheinfo的静态数组中；
5、CatCache中的cc_bucket数组中的每个元素都表示一个Hash桶，

一、SysCache初始化
初始化在InitProgres函数中，初始化主要是填充CatCache的过程（将查找系统表元祖关键字信息写入数组中）；

1、初始化如下：
postgres进程初始化时，会调用InitCatalogCache函数对SysCache数组进行初始化，并建立由CacheHdr记录的CatCache链表。
初始化主要分为以下几步：
1）根据cacheinfo为SysCache数组分配空间；
2）初始化第一阶段
循环调用InitCatchche函数根据cacheinfo生成CatCache结构并放入SysCache数组对应位置。
InitCatchche首先确保CacheMemoryContext存在，然后切换到CacheMemoryContext中；
接下来检查CacheHdr是否存在，不存在则先建立CacheHdr；
然后根据cachedesc中要求的Hash桶数为即将建立的CatCache结构分配内存，并根据cachedesc结构中信息填充CatCache各个字段；

3）初始化第二阶段
RelationCacheInitializePhase2（负责RelCache的初始化）还将调用InitCatcachePhase2进行第二阶段初始化：
InitCatcachePhase2：将依次完善SysCache数组中的CatCache结构；
主要填充CatCache元祖描述符(cc_tupdesc)、系统表名(cc_relname)、查找关键字的相关字段（cc_hashfunc、cc_isname、cc_skey）；

SysCache数组初始化完成后，CatCache内是没有任何元祖的，随着系统运行时对系统表元祖的访问，CatCache中系统表元祖会逐渐增多；

2、CatCache中缓存元祖组织
1）CatCache中的cc_bucket数组中的每个元素都表示一个Hash桶，元祖键值映射到cc_bucket数组下标；
hash桶节点类型Dlelem类型，其dle_val字段指向CatCTup，dle_list用来记录缓存元祖头部；

3、在CatCache中查找元祖
CatCache中查找元祖有两种方式：精准匹配和部分匹配


RelCache

1、插入新打开的表
将RelationData值赋值给reldesc字段；

2、查找Hash表
通过函数hash_search查找，若找到将reldesc字段值赋给RELATION，否则RELATION等于NULL；

3、从Hash表中删除元素




ReadBuffer_common函数介绍：
1、条件

是否扩展：		isExtend
是否临时表：	isLocalBuf
是否已在缓冲池中：found

2、
BufferAlloc：获取共享缓冲区




rac：

问题单验证：
缺陷单验证注意事项：
1、格式
【当前流程】自测
【是否自验通过】Y/N
【自验报告】视频或截图
【转测版本号】v2.1.0.6.01r
【其他信息】如果没验证通过，需要写明错误现象，日志、截图等信息

本地搭建共享存储
1、扩展硬盘
https://jingyan.baidu.com/article/335530da65c0be59ca41c31f.html

2、

iqn.2021-07.com.racshared:server

iqn.2021-07.com.racshared:client1
iqn.2021-07.com.racshared:client2




/home/uxdb/uxdbinstall/dbsql/bin/ux_ctl stop -D /mnt/sd4/racdata -o "-c uxdb_rac=on -c instance_id=1"

/home/uxdb/uxdbinstall/dbsql/bin/ux_ctl stop -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=2"



2021-07-21

输出rac各进程id与对应共享内存段

PostmasterMain
https://www.docin.com/p-477394708.html


1. 设置进程ID
2. 初始化内存池
3. 设置路径、时间等变量
4. 初始化GUC选项，处理输入参数并载入hba和ident
5. 设置共享内存和信号量，初始化共享数据结构
6. 设置信号处理句柄
7. 启动守护进程：
   (1) syslogger：收集其他其他进程的日志输出，写入到文件
   (2) stats daemon：通过UDP获取各backend的运行时统计信息
   (3) autovacuum launcher：定期进行表空间的自动清理
8. 由参数forkboot启动一个backend
9. 绑定到TCP socket，监听连接请求

AuxiliaryProcessMain

记录PID变量：
StartupPID



辅助进程启动：
系统日志：
SysLogger_Start						//2078

其他辅助进程函数入口：
ServerLoop（在监听循环中执行）		//2258

master启动进程：
PostmasterMain			//1218-2268
	SubPostmasterMain

获取共享内存函数：
https://blog.csdn.net/iteye_4537/article/details/82374618?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control

https://www.jianshu.com/p/96d9f6be9913

https://blog.csdn.net/iteye_4537/article/details/82294291
CreateSharedMemoryAndSemaphores
	->UXSharedMemoryCreate
	->cirdSnapShmemInit
各进程相关函数：

reset_shared						//1972：分配共享内存
SysLogger_Start
uxdb      27714  27622  0 20:09 ?        00:00:00 uxdb: logger process

start_controller					//2107
uxdb      33969  33950  0 09:56 ?        00:00:00 uxdb: rac: clusterd-controller process
uxdb      33970  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-evtd process
uxdb      33971  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-nsrd process
uxdb      33972  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-dhbd process
uxdb      33973  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-nhbd process
uxdb      33974  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-arbitrator process

start_lrmd						//2130
uxdb      34011  33950  0 09:57 ?        00:00:00 uxdb: rac: lrmd process

start_rac_process				//2141
uxdb      34022  33950  0 09:59 ?        00:00:00 uxdb: rac: message-listen process
uxdb      34023  33950  0 09:59 ?        00:00:00 uxdb: rac: message-send process
uxdb      34024  33950  0 09:59 ?        00:00:00 uxdb: rac: cache sync process
uxdb      34025  33950  0 09:59 ?        00:00:00 uxdb: rac: ges request process   migrating
uxdb      34026  33950  0 09:59 ?        00:00:00 uxdb: rac: ges reply process
uxdb      34027  33950  0 09:59 ?        00:00:00 uxdb: rac: gcs request process   migrating
uxdb      34028  33950  0 09:59 ?        00:00:00 uxdb: rac: gcs reply process
uxdb      34029  33950  0 09:59 ?        00:00:00 uxdb: rac: cluster node recovery process
uxdb      34030  33950  0 09:59 ?        00:00:00 uxdb: rac: cluster sync conf process
uxdb      34031  33950  0 09:59 ?        00:00:00 uxdb: rac: global xactid request services
uxdb      34032  33950  0 09:59 ?        00:00:00 uxdb: rac: pi manager process
ServerLoop
	-》signal_processor				//2988
uxdb      27908  27622  0 20:15 ?        00:00:00 uxdb: rac: global xactid reply services
uxdb      27909  27622  0 20:15 ?        00:00:00 uxdb: checkpointer process
uxdb      27910  27622  0 20:15 ?        00:00:00 uxdb: writer process
uxdb      27911  27622  0 20:15 ?        00:00:00 uxdb: wal writer process
uxdb      27912  27622  0 20:15 ?        00:00:00 uxdb: autovacuum launcher process
uxdb      27913  27622  0 20:15 ?        00:00:00 uxdb: global stats collector process
uxdb      27914  27622  0 20:15 ?        00:00:00 uxdb: stats collector process

ServerLoop 		//3136
uxdb      28015  27622  0 20:21 ?        00:00:00 uxdb: rac: global deadlock detect process

ServerLoop 		//3142
uxdb      28028  27622  0 20:22 ?        00:00:00 uxdb: rac: online recovery process

共享内存开始、结束
	ShmemBase = (void *) shmhdr;
	ShmemEnd = (char *) ShmemBase + shmhdr->totalsize;


ux_ctl解析配置文件：
http://blog.chinaunix.net/uid-30132132-id-4826450.html

https://www.pianshen.com/article/5402466843/
SelectConfigFiles
  ProcessConfigFile
    ProcessConfigFileInternal
      ParseConfigFile
        ParseConfigFp

申请共享内存函数：
ShmemInitStruct

全局变量：
ShmemSegHdr->freeoffset

总大小：
813105152

起始地址：
(gdb) p ShmemBase
$4 = (void *) 0x7f42b17ee000
(gdb) p ShmemEnd
$5 = (void *) 0x7f42e1f5e000

InitShmemAllocation					//freeoffset = 7040，	size = 5376，		ShmemBase = 0x7f42b17efb80

CreateLWLocks						//freeoffset = 12416，	size = 73348，		ShmemBase = 0x7f42b17f1080
primaryMirrorModeShmemInit			//freeoffset = 96000，	size = 5376，		ShmemBase = 0x7f42b1805700
XLOGShmemInit						//freeoffset = 101376，	size1=384			ShmemBase = 0x7f42b1806c00 && 0x7f42b1806d80
CLOGShmemInit
CommitTsShmemInit					//freeoffset = 475136，	size = 128，		ShmemBase = 0x7f42b1862000
SUBTRANSShmemInit					//freeoffset = 475264，	size = 267136，		ShmemBase = 0x7f42b1862080
MultiXactShmemInit					//freeoffset = 742400， size = 66944, 		ShmemBase = 0x7f42b18a3400
InitBufferPool
									1//freeoffset = 944768， size = 90112, 		ShmemBase = 0x7f42b18d4a80
									2//freeoffset = 1034880， size = 8388608, 		ShmemBase = 0x7f42b18eaa80
									3//freeoffset = 9423488， size = 32768, 		ShmemBase = 0x7f42b20eaa80
									4//freeoffset = 9456256， size = 20480, 		ShmemBase = 0x7f42b20f2a80
									5//freeoffset = 9476736， size = 2944, 		ShmemBase = 0x7f42b20f7a80
									6//freeoffset = 9545216， size = 128, 		ShmemBase = 0x7f42b2108600
InitLocks							1//freeoffset = 9545344， size = 2944, 		ShmemBase = 0x7f42b2108680
									2//freeoffset = 10756608， size = 2944, 		ShmemBase = 0x7f42b2230200
									3//freeoffset = 11976064， size = 4224, 		ShmemBase = 0x7f42b2359d80
InitAppendOnlyWriter				1//freeoffset = 11980288， size = 128, 		ShmemBase = 0x7f42b235ae00
									2//freeoffset = 11980416， size = 2944, 		ShmemBase = 0x7f42b235ae80
PersistentFileSysObj_ShmemInit							//freeoffset = 20437504， size = 128, 		ShmemBase = 0x7f42b2b6ba00
PersistentFilespace_ShmemInit							1//freeoffset = 20437632， size = 128, 		ShmemBase = 0x7f42b2b6ba80
														2//freeoffset = 20437760， size = 2944, 		ShmemBase = 0x7f42b2b6bb00
PersistentTablespace_ShmemInit							1//freeoffset = 20459520， size = 128, 		ShmemBase = 0x7f42b2b71000
														2//freeoffset = 20459648， size = 2944, 		ShmemBase = 0x7f42b2b71080
PersistentDatabase_ShmemInit							//freeoffset = 20465408， size = 16000, 		ShmemBase = 0x7f42b2b72700
PersistentRelation_ShmemInit							//freeoffset = 20481408， size = 128, 		ShmemBase = 0x7f42b2b76580
InitPredicateLocks										1//freeoffset = 20481536， size = 2944, 		ShmemBase = 0x7f42b2b76600
														2//freeoffset = 21266816， size = 2944, 		ShmemBase = 0x7f42b2c36180
														3//freeoffset = 23485696， size = 128, 		ShmemBase = 0x7f42b2e53d00
														4//freeoffset = 23808128， size = 2944, 		ShmemBase = 0x7f42b2ea2880
														5//freeoffset = 23911680， size = 128, 		ShmemBase = 0x7f42b2ebbd00
														6//freeoffset = 24420608， size = 128, 		ShmemBase = 0x7f42b2f38100
														7//freeoffset = 24420736， size = 133632, 		ShmemBase = 0x7f42b2f38180
														8//freeoffset = 24554368， size = 128, 		ShmemBase = 0x7f42b2f58b80

InitProcGlobal									//freeoffset = 24554496， size = 128, 		ShmemBase = 0x7f42b2f58c00
CreateSharedProcArray							1//freeoffset = 24735360， size = 896, 		ShmemBase = 0x7f42b2f84e80
												2//freeoffset = 24736256， size = 55168, 		ShmemBase = 0x7f42b2f85200
												3//freeoffset = 24791424， size = 13824, 		ShmemBase = 0x7f42b2f92980
CreateSharedBackendStatus							//freeoffset = 24805248， size = 72832, 		ShmemBase = 0x7f42b2f95f80
													//freeoffset = 24878080， size = 13568, 		ShmemBase = 0x7f42b2fa7c00
													//freeoffset = 24905216， size = 227328, 		ShmemBase = 0x7f42b2fae600
													//freeoffset = 25132544， size = 44416, 		ShmemBase = 0x7f42b2fe5e00
TwoPhaseShmemInit									//freeoffset = 25176960， size = 128, 		ShmemBase = 0x7f42b2ff0b80
BackgroundWorkerShmemInit							//freeoffset = 25177088， size = 3072, 		ShmemBase = 0x7f42b2ff0c00
CreateSharedInvalidationState							//freeoffset = 25180160， size = 72448, 		ShmemBase = 0x7f42b2ff1800
PMSignalShmemInit								//freeoffset = 25252608， size = 2304, 		ShmemBase = 0x7f42b3003300
ProcSignalShmemInit								//freeoffset = 25254912， size = 9856, 		ShmemBase = 0x7f42b3003c00
CheckpointerShmemInit							//freeoffset = 25264768， size = 20608, 		ShmemBase = 0x7f42b3006280
AutoVacuumShmemInit							//freeoffset = 25285376， size = 5376, 		ShmemBase = 0x7f42b300b300
ReplicationSlotsShmemInit							//freeoffset = 25290752， size = 2432, 		ShmemBase = 0x7f42b300c800
ReplicationOriginShmemInit							//freeoffset = 25293184， size = 640, 		ShmemBase = 0x7f42b300d180
WalSndShmemInit										//freeoffset = 25293824， size = 1152, 		ShmemBase = 0x7f42b300d400
WalRcvShmemInit										//freeoffset = 25294976， size = 1280, 		ShmemBase = 0x7f42b300d880
ApplyLauncherShmemInit								//freeoffset = 25296256， size = 512, 		ShmemBase = 0x7f42b300dd80
FileRepResync_ShmemInit								1//freeoffset = 25296768， size = 128, 		ShmemBase = 0x7f42b300df80
													2//freeoffset = 25296896， size = 2944, 		ShmemBase = 0x7f42b300e000
SnapMgrInit											//freeoffset = 25447296， size = 128, 		ShmemBase = 0x7f42b3032b80
BTreeShmemInit											//freeoffset = 25447424， size = 2560, 		ShmemBase = 0x7f42b3032c00
SyncScanShmemInit											//freeoffset = 25449984， size = 768, 		ShmemBase = 0x7f42b3033600
AsyncShmemInit											1//freeoffset = 25450752， size = 3456, 		ShmemBase = 0x7f42b3033900
														2//freeoffset = 25454208， size = 66944, 		ShmemBase = 0x7f42b3034680
workfile_mgr_cache_init								1//freeoffset = 25525248， size = 2944, 		ShmemBase = 0x7f42b3045c00
													2//freeoffset = 25986944， size = 9437440, 		ShmemBase = 0x7f42b30b6780
													3//freeoffset = 35424384， size = 2944, 		ShmemBase = 0x7f42b39b6880
													4//freeoffset = 35442560， size = 128, 		ShmemBase = 0x7f42b39baf80
BackendRandomShmemInit								//无内存
RacShmemInit											1//freeoffset = 35442688， size = 124160, 		ShmemBase = 0x7f42b39bb000
														2//freeoffset = 35566848， size = 45440, 		ShmemBase = 0x7f42b39d9500
														3//freeoffset = 35612288， size = 128, 		ShmemBase = 0x7f42b39e4680
														4//freeoffset = 35612416， size = 45440, 		ShmemBase = 0x7f42b39e4700
														5//freeoffset = 35657856， size = 128, 		ShmemBase = 0x7f42b39ef880
														6//freeoffset = 35657984， size = 45440, 		ShmemBase = 0x7f42b39ef900
														7//freeoffset = 35703424， size = 128, 		ShmemBase = 0x7f42b39faa80
														8//freeoffset = 35703552， size = 45440, 		ShmemBase = 0x7f42b39fab00
														9//freeoffset = 35748992， size = 128, 		ShmemBase = 0x7f42b3a05c80
														10//freeoffset = 35749120， size = 45440, 		ShmemBase = 0x7f42b3a05d00
														11//freeoffset = 35794560， size = 128, 		ShmemBase = 0x7f42b3a10e80
														12//freeoffset = 35794688， size = 45440, 		ShmemBase = 0x7f42b3a10f00
														13//freeoffset = 35840128， size = 128, 		ShmemBase = 0x7f42b3a1c080
														14//freeoffset = 35840256， size = 45440, 		ShmemBase = 0x7f42b3a1c100
														15//freeoffset = 35885696， size = 128, 		ShmemBase = 0x7f42b3a27280
														16//freeoffset = 35885824， size = 45440, 		ShmemBase = 0x7f42b3a27300
														17//freeoffset = 35931264， size = 128, 		ShmemBase = 0x7f42b3a32480
														18//freeoffset = 35931392， size = 45440, 		ShmemBase = 0x7f42b3a32500
														19//freeoffset = 35976832， size = 128, 		ShmemBase = 0x7f42b3a3d680
														20//freeoffset = 35976960， size = 45440, 		ShmemBase = 0x7f42b3a3d700
														21//freeoffset = 36022400， size = 128, 		ShmemBase = 0x7f42b3a48880
														22//freeoffset = 36022528， size = 45440, 		ShmemBase = 0x7f42b3a48900
														23//freeoffset = 36067968， size = 128, 		ShmemBase = 0x7f42b3a53a80
														24//freeoffset = 36068096， size = 45440, 		ShmemBase = 0x7f42b3a53b00
														25//freeoffset = 36113536， size = 128, 		ShmemBase = 0x7f42b3a5ec80
														26//freeoffset = 36113664， size = 45440, 		ShmemBase = 0x7f42b3a5ed00
														27//freeoffset = 36113664， size = 45440, 		ShmemBase = 0x7f42b3a5ed00
						InitVacWorkerResponseQueue				28//freeoffset = 760029056， size = 256, 		ShmemBase = 0x7f42decbff80
																29//freeoffset = 760029312， size = 143360, 		ShmemBase = 0x7f42decc0080
XidDispatcherInstNumShmemInit							//freeoffset = 793446144， size = 128, 		ShmemBase = 0x7f42e0c9e700
lrmdChashShmemInit										1//freeoffset = 793446272， size = 551168, 		ShmemBase = 0x7f42e0c9e780
														2//freeoffset = 793997440， size = 551168, 		ShmemBase = 0x7f42e0d25080
														3//freeoffset = 794548608， size = 128, 		ShmemBase = 0x7f42e0dab980
														4//freeoffset = 794548736， size = 128, 		ShmemBase = 0x7f42e0daba00
cirdSnapShmemInit										//freeoffset = 794548864， size = 3456, 		ShmemBase = 0x7f42e0daba80
evtdShmemInit											//freeoffset = 794552320， size = 512, 		ShmemBase = 0x7f42e0dac800
commShmemInit											//freeoffset = 794552832， size = 128, 		ShmemBase = 0x7f42e0daca00

申请空间大小
 UXSemaphoreShmemSize(numSemas);														//6976
 SpinlockSemaSize();																	//0
 hash_estimate_size(SHMEM_INDEX_SIZE, sizeof(ShmemIndexEnt));							//13112
 BufferShmemSize();																	//8598464
 LockShmemSize();																		//5341353
 PredicateLockShmemSize();																//4377564
 ProcGlobalShmemSize();																//180601
 XLOGShmemSize();																		//273336
 CLOGShmemSize();																		//66272
 CommitTsShmemSize();																	//33536
 SUBTRANSShmemSize();																	//267040
 TwoPhaseShmemSize();																	//16
 BackgroundWorkerShmemSize();															//2960
 MultiXactShmemSize();																	//202196
 LWLockShmemSize();																	//73348
 ProcArrayShmemSize();																	//69788
 BackendStatusShmemSize();																//372960
 SInvalShmemSize();																	//72344
 PMSignalShmemSize();																	//2272
 ProcSignalShmemSize();																//9768
 CheckpointerShmemSize();																//20520
 AutoVacuumShmemSize();																//5344
 ReplicationSlotsShmemSize();															//2400
 ReplicationOriginShmemSize();															//568
 WalSndShmemSize();																	//1040
 WalRcvShmemSize();																	//1192
 ApplyLauncherShmemSize();																//424
 SnapMgrShmemSize();																	//68
 BTreeShmemSize();																		//2556
 SyncScanShmemSize();																	//656
 AsyncShmemSize();																		//70280
 BackendRandomShmemSize();																//0
 PersistentFileSysObj_ShmemSize();														//8
 PersistentFilespace_ShmemSize();														//134952
 PersistentTablespace_ShmemSize();														//7016
 PersistentDatabase_ShmemSize();														//15952
 PersistentRelation_ShmemSize();														//48
 workfile_mgr_shmem_size();															//9935008
 primaryMirrorModeShmemSize();															//5280
 AppendOnlyWriterShmemSize();															//9443249
 FileRepResync_ShmemSize(); 															//199304
 RacShmemSize();																		//772087056
 sizeof(int); 																			//4
lrmdShmemSize();																		//1102352
 cirdSnapShmemSize();		 															//3456
evtdShmemSize();																		//512
commShmemSize();																		//8


初始化实际大小：
ShmemSegHdr->freeoffset = 56
UXReserveSemaphores(numSemas, port);							//6976			ShmemSegHdr->freeoffset=7032
InitShmemAllocation();											//5,384										12416
CreateLWLocks();												//73,472										85888
InitShmemIndex();												//10,112										96000
primaryMirrorModeShmemInit();									//5,376										101376
XLOGShmemInit();												//273,920										375296
CLOGShmemInit();												//66,304										441600
CommitTsShmemInit();											//33,664										475264
SUBTRANSShmemInit();											//267,136										742400
MultiXactShmemInit();											202,368										944768
InitBufferPool();												8,600,576										9545344
InitLocks();													2,434,944										11980288
InitAppendOnlyWriter();											8,457,216										20437504
PersistentFileSysObj_ShmemInit();									128									20437632
PersistentFilespace_ShmemInit();								21,888										20459520
PersistentTablespace_ShmemInit();								5,888										20465408
PersistentDatabase_ShmemInit();									16,000										20481408
PersistentRelation_ShmemInit();									128											20481536

InitPredicateLocks();											4,072,960									24554496
InitProcGlobal();												180,864										24735360
CreateSharedProcArray();										69,888										24805248
CreateSharedBackendStatus();									371,712										25176960
TwoPhaseShmemInit();											128											25177088
BackgroundWorkerShmemInit();									3,072										25180160
CreateSharedInvalidationState();								72,448										25252608
PMSignalShmemInit();											2,304										25254912
ProcSignalShmemInit();											9,856										25264768
CheckpointerShmemInit();										20,608										25285376
AutoVacuumShmemInit();											5,376										25290752
ReplicationSlotsShmemInit();									2,432										25293184
ReplicationOriginShmemInit();									640										25293824
WalSndShmemInit();												1,152										25294976
WalRcvShmemInit();												1,280										25296256
ApplyLauncherShmemInit();										512										25296768
FileRepResync_ShmemInit();										150,528										25447296
SnapMgrInit();													128										25447424
BTreeShmemInit();												2,560										25449984
SyncScanShmemInit();											768										25450752
AsyncShmemInit();												70,400										25521152
workfile_mgr_cache_init();										9,921,536										35442688
BackendRandomShmemInit();										0										35442688
RacShmemInit();													758,003,456										793446144

XidDispatcherInstNumShmemInit();								128										793446272
lrmdChashShmemInit();											1,102,592										794548864
cirdSnapShmemInit();											3,456										794552320
evtdShmemInit();												512										794552832
commShmemInit();												128										794552960


代码修改：
共享内存：

void
GetshmemSize(TupOutputState *tstate, char *name, int applysize, const char *initsize)
{
	Datum			values[3];
	bool			isnull[3] = {false, false, false};
	char        	value_text[256];

	values[0] = PointerGetDatum(cstring_to_text(name));
	memset(value_text, 0, sizeof(value_text));

	snprintf(value_text, sizeof(value_text) - 1, "%u", applysize);
	values[1] = PointerGetDatum(cstring_to_text(value_text));

	values[2] = PointerGetDatum(cstring_to_text(initsize));
	do_tup_output(tstate, values, isnull);
	pfree(DatumGetPointer(values[0]));
	pfree(DatumGetPointer(values[1]));
	pfree(DatumGetPointer(values[2]));

}

static void
ShowShmemSize(DestReceiver *dest)
{

	TupOutputState *tstate;
	TupleDesc	tupdesc;
	int			numSemas;
	int all_shmem_size[48] = {0};

	/* need a tuple descriptor representing three TEXT columns */
	tupdesc = CreateTemplateTupleDesc(3, false);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 1, "name",
							  TEXTOID, -1, 0);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 2, "applysize",
							  TEXTOID, -1, 0);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 3, "realsize",
							  TEXTOID, -1, 0);



	numSemas = ProcGlobalSemas();
	numSemas += SpinlockSemas();
	all_shmem_size[0] = UXSemaphoreShmemSize(numSemas);
	all_shmem_size[1] =  SpinlockSemaSize();
	all_shmem_size[2] =  hash_estimate_size(SHMEM_INDEX_SIZE, sizeof(ShmemIndexEnt));
	all_shmem_size[3] =  BufferShmemSize();
	all_shmem_size[4] =  LockShmemSize();
	all_shmem_size[5] =  PredicateLockShmemSize();
	all_shmem_size[6] =  ProcGlobalShmemSize();
	all_shmem_size[7] =  XLOGShmemSize();

	all_shmem_size[8] =  CLOGShmemSize();
	all_shmem_size[9] =  CommitTsShmemSize();
	all_shmem_size[10] =  SUBTRANSShmemSize();
	all_shmem_size[11] =  TwoPhaseShmemSize();
	all_shmem_size[12] =  BackgroundWorkerShmemSize();
	all_shmem_size[13] =  MultiXactShmemSize();
	all_shmem_size[14] =  LWLockShmemSize();
	all_shmem_size[15] =  ProcArrayShmemSize();
	all_shmem_size[16] =  BackendStatusShmemSize();
	all_shmem_size[17] =  SInvalShmemSize();
	all_shmem_size[18] =  PMSignalShmemSize();
	all_shmem_size[19] =  ProcSignalShmemSize();
	all_shmem_size[20] =  CheckpointerShmemSize();
	all_shmem_size[21] =  AutoVacuumShmemSize();
	all_shmem_size[22] =  ReplicationSlotsShmemSize();
	all_shmem_size[23] =  ReplicationOriginShmemSize();
	all_shmem_size[24] =  WalSndShmemSize();
	all_shmem_size[25] =  WalRcvShmemSize();
	all_shmem_size[26] =  ApplyLauncherShmemSize();
	all_shmem_size[27] =  SnapMgrShmemSize();
	all_shmem_size[28] =  BTreeShmemSize();
	all_shmem_size[29] =  SyncScanShmemSize();
	all_shmem_size[30] =  AsyncShmemSize();
	all_shmem_size[31] =  BackendRandomShmemSize();
	all_shmem_size[32] =  PersistentFileSysObj_ShmemSize();
	all_shmem_size[33] =  PersistentFilespace_ShmemSize();
	all_shmem_size[34] =  PersistentTablespace_ShmemSize();
	all_shmem_size[35] =  PersistentDatabase_ShmemSize();
	all_shmem_size[36] =  PersistentRelation_ShmemSize();
	all_shmem_size[37] =  workfile_mgr_shmem_size();
	all_shmem_size[38] =  primaryMirrorModeShmemSize();
	all_shmem_size[39] =  AppendOnlyWriterShmemSize();
	all_shmem_size[40] =  FileRepResync_ShmemSize();
	all_shmem_size[41] =  RacShmemSize();
	all_shmem_size[42] =  sizeof(int);
	all_shmem_size[43] =  lrmdShmemSize();
	all_shmem_size[44] =  cirdSnapShmemSize();
	all_shmem_size[45] =  evtdShmemSize();
	all_shmem_size[46] =  commShmemSize();
	/* prepare for projection of tuples */
	tstate = begin_tup_output_tupdesc(dest, tupdesc);



	/* assign to the values array */
	GetshmemSize(tstate, "UXSemaphoreShmemSize", all_shmem_size[0], "6976");
	GetshmemSize(tstate, "SpinlockSemaSize", all_shmem_size[1], "0");
	GetshmemSize(tstate, "hash_estimate_size", all_shmem_size[2], "10112");
	GetshmemSize(tstate, "BufferShmemSize", all_shmem_size[3], "8600576");
	GetshmemSize(tstate, "LockShmemSize", all_shmem_size[4], "2434944");
	GetshmemSize(tstate, "PredicateLockShmemSize", all_shmem_size[5], "4072960");
	GetshmemSize(tstate, "ProcGlobalShmemSize", all_shmem_size[6], "180864");
	GetshmemSize(tstate, "XLOGShmemSize", all_shmem_size[7], "273920");
	GetshmemSize(tstate, "CLOGShmemSize", all_shmem_size[8], "66304");
	GetshmemSize(tstate, "CommitTsShmemSize", all_shmem_size[9], "33664");
	GetshmemSize(tstate, "SUBTRANSShmemSize", all_shmem_size[10], "267136");
	GetshmemSize(tstate, "TwoPhaseShmemSize", all_shmem_size[11], "128");
	GetshmemSize(tstate, "BackgroundWorkerShmemSize", all_shmem_size[12], "3072");
	GetshmemSize(tstate, "MultiXactShmemSize", all_shmem_size[13], "202368");
	GetshmemSize(tstate, "LWLockShmemSize", all_shmem_size[14], "73472");
	GetshmemSize(tstate, "ProcArrayShmemSize", all_shmem_size[15], "69888");
	GetshmemSize(tstate, "BackendStatusShmemSize", all_shmem_size[16], "371712");
	GetshmemSize(tstate, "SInvalShmemSize", all_shmem_size[17], "72448");
	GetshmemSize(tstate, "PMSignalShmemSize", all_shmem_size[18], "2304");
	GetshmemSize(tstate, "ProcSignalShmemSize", all_shmem_size[19], "9856");
	GetshmemSize(tstate, "CheckpointerShmemSize", all_shmem_size[20], "20608");
	GetshmemSize(tstate, "AutoVacuumShmemSize", all_shmem_size[21], "5376");
	GetshmemSize(tstate, "ReplicationSlotsShmemSize", all_shmem_size[22], "2432");
	GetshmemSize(tstate, "ReplicationOriginShmemSize", all_shmem_size[23], "640");
	GetshmemSize(tstate, "WalSndShmemSize", all_shmem_size[24], "1152");
	GetshmemSize(tstate, "WalRcvShmemSize", all_shmem_size[25], "1280");
	GetshmemSize(tstate, "ApplyLauncherShmemSize", all_shmem_size[26], "512");
	GetshmemSize(tstate, "SnapMgrShmemSize", all_shmem_size[27], "128");
	GetshmemSize(tstate, "BTreeShmemSize", all_shmem_size[28], "2560");
	GetshmemSize(tstate, "SyncScanShmemSize", all_shmem_size[29], "768");
	GetshmemSize(tstate, "AsyncShmemSize", all_shmem_size[30], "70400");
	GetshmemSize(tstate, "BackendRandomShmemSize", all_shmem_size[31], "0");
	GetshmemSize(tstate, "PersistentFileSysObj_ShmemSize", all_shmem_size[32], "128");
	GetshmemSize(tstate, "PersistentFilespace_ShmemSize", all_shmem_size[33], "21888");
	GetshmemSize(tstate, "PersistentTablespace_ShmemSize", all_shmem_size[34], "5888");
	GetshmemSize(tstate, "PersistentDatabase_ShmemSize", all_shmem_size[35], "16000");
	GetshmemSize(tstate, "PersistentRelation_ShmemSize", all_shmem_size[36], "128");
	GetshmemSize(tstate, "workfile_mgr_shmem_size", all_shmem_size[37], "9921536");
	GetshmemSize(tstate, "primaryMirrorModeShmemSize", all_shmem_size[38], "5376");
	GetshmemSize(tstate, "AppendOnlyWriterShmemSize", all_shmem_size[39], "8457216");
	GetshmemSize(tstate, "FileRepResync_ShmemSize", all_shmem_size[40], "150528");
	GetshmemSize(tstate, "RacShmemSize", all_shmem_size[41], "758003456");
	GetshmemSize(tstate, "pXidDispatcherInstNum", all_shmem_size[42], "128");
	GetshmemSize(tstate, "lrmdShmemSize", all_shmem_size[43], "1102592");
	GetshmemSize(tstate, "cirdSnapShmemSize", all_shmem_size[44], "3456");
	GetshmemSize(tstate, "evtdShmemSize", all_shmem_size[45], "512");
	GetshmemSize(tstate, "commShmemSize", all_shmem_size[46], "128");


	end_tup_output(tstate);
}

内存大小写死：

void
GetshmemSize(TupOutputState *tstate, const char *name, const char *applysize, const char *initsize)
{
	Datum			values[3];
	bool			isnull[3] = {false, false, false};

	values[0] = PointerGetDatum(cstring_to_text(name));

	values[1] = PointerGetDatum(cstring_to_text(applysize));

	values[2] = PointerGetDatum(cstring_to_text(initsize));
	do_tup_output(tstate, values, isnull);
	pfree(DatumGetPointer(values[0]));
	pfree(DatumGetPointer(values[1]));
	pfree(DatumGetPointer(values[2]));

}

static void
ShowShmemSize(DestReceiver *dest)
{

	TupOutputState *tstate;
	TupleDesc	tupdesc;

	/* need a tuple descriptor representing three TEXT columns */
	tupdesc = CreateTemplateTupleDesc(3, false);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 1, "name",
							  TEXTOID, -1, 0);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 2, "applysize",
							  TEXTOID, -1, 0);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 3, "realsize",
							  TEXTOID, -1, 0);

	/* prepare for projection of tuples */
	tstate = begin_tup_output_tupdesc(dest, tupdesc);



	/* assign to the values array */
	GetshmemSize(tstate, "UXSemaphoreShmemSize", "6976", "6976");
	GetshmemSize(tstate, "SpinlockSemaSize", "0", "0");
	GetshmemSize(tstate, "hash_estimate_size", "13112", "10112");
	GetshmemSize(tstate, "BufferShmemSize", "8598464", "8600576");
	GetshmemSize(tstate, "LockShmemSize", "5341353", "2434944");
	GetshmemSize(tstate, "PredicateLockShmemSize", "4377564", "4072960");
	GetshmemSize(tstate, "ProcGlobalShmemSize", "180601", "180864");
	GetshmemSize(tstate, "XLOGShmemSize", "273336", "273920");
	GetshmemSize(tstate, "CLOGShmemSize", "66272", "66304");
	GetshmemSize(tstate, "CommitTsShmemSize", "33536", "33664");
	GetshmemSize(tstate, "SUBTRANSShmemSize", "267040", "267136");
	GetshmemSize(tstate, "TwoPhaseShmemSize", "16", "128");
	GetshmemSize(tstate, "BackgroundWorkerShmemSize", "2960", "3072");
	GetshmemSize(tstate, "MultiXactShmemSize", "202196", "202368");
	GetshmemSize(tstate, "LWLockShmemSize", "73348", "73472");
	GetshmemSize(tstate, "ProcArrayShmemSize", "69788", "69888");
	GetshmemSize(tstate, "BackendStatusShmemSize", "372960", "371712");
	GetshmemSize(tstate, "SInvalShmemSize", "72344", "72448");
	GetshmemSize(tstate, "PMSignalShmemSize", "2272", "2304");
	GetshmemSize(tstate, "ProcSignalShmemSize", "9768", "9856");
	GetshmemSize(tstate, "CheckpointerShmemSize", "20520", "20608");
	GetshmemSize(tstate, "AutoVacuumShmemSize", "5344", "5376");
	GetshmemSize(tstate, "ReplicationSlotsShmemSize", "2400", "2432");
	GetshmemSize(tstate, "ReplicationOriginShmemSize", "568", "640");
	GetshmemSize(tstate, "WalSndShmemSize", "1040", "1152");
	GetshmemSize(tstate, "WalRcvShmemSize", "1192", "1280");
	GetshmemSize(tstate, "ApplyLauncherShmemSize", "424", "512");
	GetshmemSize(tstate, "SnapMgrShmemSize", "68", "128");
	GetshmemSize(tstate, "BTreeShmemSize", "2556", "2560");
	GetshmemSize(tstate, "SyncScanShmemSize", "656", "768");
	GetshmemSize(tstate, "AsyncShmemSize", "70280", "70400");
	GetshmemSize(tstate, "BackendRandomShmemSize", "0", "0");
	GetshmemSize(tstate, "PersistentFileSysObj_ShmemSize", "8", "128");
	GetshmemSize(tstate, "PersistentFilespace_ShmemSize", "134952", "21888");
	GetshmemSize(tstate, "PersistentTablespace_ShmemSize", "7016", "5888");
	GetshmemSize(tstate, "PersistentDatabase_ShmemSize", "15952", "16000");
	GetshmemSize(tstate, "PersistentRelation_ShmemSize", "48", "128");
	GetshmemSize(tstate, "workfile_mgr_shmem_size", "9935008", "9921536");
	GetshmemSize(tstate, "primaryMirrorModeShmemSize", "5280", "5376");
	GetshmemSize(tstate, "AppendOnlyWriterShmemSize", "9443249", "8457216");
	GetshmemSize(tstate, "FileRepResync_ShmemSize", "199304", "150528");
	GetshmemSize(tstate, "RacShmemSize", "772087056", "758003456");
	GetshmemSize(tstate, "pXidDispatcherInstNum", "4", "128");
	GetshmemSize(tstate, "lrmdShmemSize", "1102352", "1102592");
	GetshmemSize(tstate, "cirdSnapShmemSize", "3456", "3456");
	GetshmemSize(tstate, "evtdShmemSize", "512", "512");
	GetshmemSize(tstate, "commShmemSize", "8", "128");


	end_tup_output(tstate);
}
加log打印
ereport(LOG, (errmsg("successfully leave service_group_isready: group_id:%d wait_count:%d processed_count:%d success_count:%d fatal_count:%d failed_count:%d",
	    group_id, wait_count, processed_count, success_count, fatal_count, failed_count)));


gb18030代码移植：

91121

/* Begin add by QiWang for #116109 at 2021/08/11 reviewer:wangbocai*/
/* End add by QiWang for #116109 at 2021/08/11 reviewer:wangbocai*/
/* Begin modify by QiWang for #116109 at 2021/08/11 reviewer:wangbocai*/
/* End modify by QiWang for #116109 at 2021/08/11 reviewer:wangbocai*/

zh_CN.UTF-8
set client_encoding=GB18030;
set client_encoding=GBK;
set client_encoding=UTF8;

create table t1(sno integer, sname character(10),sage integer,ssex character(10));
create table t2(sno integer, sname character(10),sage integer,ssex character(10));

insert into t1 values('1005', '张三', 16, '男');
insert into t1 values('1005', '陈武', 16, '男');
insert into t1 values('1005', '李四', 16, '男');
insert into t1 values('1005', '王麻子', 16, '男');
insert into t2 values('1003', '李丽', 16, '女');
select * from t1;

select * from t1 where sname='李四';
select * from t1 order by sname;

export LANG=zh_CN.GB18030

select * from t1;
insert into t1 values('1005', '李丽', 18, '女');
select * from t1;

select * from t1 where sname like '李%';

select * from t1 INNER JOIN t2 ON t1.sname = t2.sname;
select * from t1 LEFT JOIN t2 ON t1.sname = t2.sname;
select * from t1 cross join t2;
select * from t1 RIGHT JOIN t2 ON t1.sname = t2.sname;


该功能主要获取共享申请大小，以及共享内存实际使用大小：
共享内存获取接口CreateSharedMemoryAndSemaphores，函数功能：
调用多个sizeof计算需要共享内存大小， 然后通过ShmemInitStruct申请实际共享内存，实际申请内存通过ShmemAlloc去申请，
具体通过ShmemSegHdr->freeoffset全局变量获取；
故该函数主要实现获取共享内存大小，以及申请内存;
修改方案：
添加关键字SHMEMSIZE，添加语法SHOW ALL SHMEMSIZE显示共享内存获取信息，也可以通过show shmem_size;
分别获取sizeof申请的内存字节大小到all_shmem_size数组，获取ShmemInitStruct实际共享内存到init_shmem_size数组中，
将数组信息填充到对应元祖中；

通过SHOW ALL SHMEMSIZE显示共享内存获取信息，也可以通过show shmem_size;获取

使用方法：
前提：启动数据库集群；
登录客户端，执行sql命令：
show shmem_size;

登录后会显示三列数据，分别是内存申请名称name、内存获取大小applysize，内存实际申请大小initsize；




initdb初始化：

初始化数据集簇包括创建数据目录（模板数据库template1和template0、默认用户数据库uxdb）、配置文件（uxsino.conf等）、控制文件（ux_control文件）；

1、以后用户创建数据库，template1数据库都会拷贝过来，template0和uxdb都是从template1拷贝的；
2、数据库对应文件目录：在PFDATA/base里都对应有一个子目录，目录名对应ux_database里的oid；
3、表和索引：表和索引也以oid命名文件放在数据库目录下，表、索引oid对应ux_class对应元祖的relfilenode属性中；
4、initdb使用：
1）、通过uxdb进入bootstrap模式创建数据集簇，并读取后端接口uxdb.bki文件创建模板数据库template1；
5、bki文件生成：
src/backend/catalog目录下的genbki.sh通过读取src/include/catalog目录下以.h结尾的系统表定义文件创建；
ux_*.h头文件中包含内容：
1）定义CATALOG宏；
2）通过宏DATA(x)和DESCR(x)来定义insert操作，用于定义系统表初始数据；


链接：
https://blog.csdn.net/weixin_34405354/article/details/86110204

1、getopt_long
该函数除了获取参数外，就是给全局变量optarg 赋值

2、effective_user = get_id();
获取此程序用户名称（防止用root运行）

3、setup_locale_encoding

设置服务器编码

4、initialize_data_directory
set_null_conf：成了一个 空的 postgresql.conf文件
test_config_settings：
是给出 max_connections 参数和 shared_buffers参数，带给postgres，让它执行，试探出最大允许的max_connections 和 shared_buffers参数。
setup_config：
确定各种参数，分别写入 postgresql.conf 、pg_hba.conf、pg_indent.conf 文件
bootstrap_template1：跑bki文件创建template1数据库

write_version_file：就是在base/1目录下，生成一个  PG_VERSION 文件
setup_auth：
setup_description：就是要把 share/postgres.description 文件的内容读入到 pg_description 和 pg_shdescription
setup_collation：其实质就是，向 pg_collation 表中插入数据
setup_conversion：传递参数：/home/pgsql/project/share/conversion_create.sql
setup_dictionary：dictionary_file 是：/home/pgsql/project/share/snowball_create.sql
setup_schema：
实质就是创建info_schema。
infor_schem_file是：/home/pgsql/project/share/information_schema.sql

load_pluxsql：
就是让postgres 执行 create extension plpgsql；

vacuum_db：
其目的很明确，就是 对 template1 数据库执行
ANALYZE;
VACUUM FULL;
VACUUM FREEZE;

create_tupleid_sequence：支持tupleid

make_template0：创建template0数据库
make_uxdb：创建uxdb数据库



















2021-08-04
初始化审计：
init_audit

rac版：
#0  _UX_init () at uxaudit.c:1824
#1  0x0000000000aab236 in internal_load_library (libname=0xa7bba78 "/home/uxdb/uxdbinstall/dbsql/lib/uxaudit.so") at dfmgr.c:281
#2  0x0000000000aaac98 in load_external_function (filename=0xa7c98d8 "$libdir/uxaudit",
    funcname=0xa7c9cd8 "uxaudit_ddl_command_end", signalNotFound=1 '\001', filehandle=0x7fff2ec29300) at dfmgr.c:105
#3  0x00000000005eb490 in fmgr_c_validator (fcinfo=0x7fff2ec29350) at ux_proc.c:819
#4  0x0000000000aae781 in OidFunctionCall1Coll (functionId=2247, collation=0, arg1=13243) at fmgr.c:1332
#5  0x00000000005eb12b in ProcedureCreate (procedureName=0xa7c48d8 "uxaudit_ddl_command_end", procNamespace=2200,
    replace=0 '\000', returnsSet=0 '\000', returnType=3838, proowner=10, languageObjectId=13, languageValidator=2247,
    prosrc=0xa7c8f00 "uxaudit_ddl_command_end", probin=0xa7c8ee0 "$libdir/uxaudit", isAgg=0 '\000', isWindowFunc=0 '\000',
    security_definer=0 '\000', isLeakProof=0 '\000', isStrict=0 '\000', volatility=118 'v', parallel=117 'u',
    parameterTypes=0xa7c98a8, allParameterTypes=0, parameterModes=0, parameterNames=0, parameterDefaults=0x0, trftypes=0,
    proconfig=0, procost=1, prorows=0) at ux_proc.c:722
#6  0x000000000069fb78 in CreateFunction (pstate=0xa7c4798, stmt=0xa7c04a0) at functioncmds.c:1083
#7  0x000000000093b1e3 in ProcessUtilitySlow (pstate=0xa7c4798, pstmt=0xa7c63a8,
    queryString=0xa7c5140 "/* uxaudit/uxaudit--1.2.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE FUNCTION uxaudit_ddl_command_end()\n\tRETURNS event_trigger\n\tLANGUAGE C\n\tAS '$libdir/u"...,
    context=PROCESS_UTILITY_QUERY, params=0x0, queryEnv=0x0, dest=0x8c90c20 <donothingDR>, completionTag=0x0) at utility.c:1682
#8  0x000000000093a28a in standard_ProcessUtility (pstmt=0xa7c63a8,
    queryString=0xa7c5140 "/* uxaudit/uxaudit--1.2.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE FUNCTION uxaudit_ddl_command_end()\n\tRETURNS event_trigger\n\tLANGUAGE C\n\tAS '$libdir/u"...,
    context=PROCESS_UTILITY_QUERY, params=0x0, queryEnv=0x0, dest=0x8c90c20 <donothingDR>, completionTag=0x0) at utility.c:1030
#9  0x000000000093924e in ProcessUtility (pstmt=0xa7c63a8,
    queryString=0xa7c5140 "/* uxaudit/uxaudit--1.2.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE FUNCTION uxaudit_ddl_command_end()\n\tRETURNS event_trigger\n\tLANGUAGE C\n\tAS '$libdir/u"...,
    context=PROCESS_UTILITY_QUERY, params=0x0, queryEnv=0x0, dest=0x8c90c20 <donothingDR>, completionTag=0x0) at utility.c:360
#10 0x0000000000694308 in execute_sql_string (
    sql=0xa7c5140 "/* uxaudit/uxaudit--1.2.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE FUNCTION uxaudit_ddl_command_end()\n\tRETURNS event_trigger\n\tLANGUAGE C\n\tAS '$libdir/u"...,
    filename=0xa7bffb8 "/home/uxdb/uxdbinstall/dbsql/share/extension/uxaudit--1.2.sql") at extension.c:763
#11 0x00000000006947d8 in execute_extension_script (extensionOid=13242, control=0xa7c0608, from_version=0x0,
    version=0xa7c06d8 "1.2", requiredSchemas=0x0, schemaName=0xa7c05f0 "public", schemaOid=2200) at extension.c:924
#12 0x00000000006956f6 in CreateExtensionInternal (extensionName=0xa79c290 "uxaudit", schemaName=0xa7c05f0 "public",
    versionName=0xa7c06d8 "1.2", oldVersionName=0x0, cascade=0 '\000', parents=0x0, is_create=1 '\001') at extension.c:1529
#13 0x0000000000695eca in CreateExtension (pstate=0xa7bb778, stmt=0xa79c2a8) at extension.c:1718
#14 0x000000000093af33 in ProcessUtilitySlow (pstate=0xa7bb778, pstmt=0xa79c358,
    queryString=0xa79b888 "create extension uxaudit;\n", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0,
    dest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "") at utility.c:1579
---Type <return> to continue, or q <return> to quit---
#15 0x000000000093a28a in standard_ProcessUtility (pstmt=0xa79c358, queryString=0xa79b888 "create extension uxaudit;\n",
    context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "")
    at utility.c:1030
#16 0x000000000093924e in ProcessUtility (pstmt=0xa79c358, queryString=0xa79b888 "create extension uxaudit;\n",
    context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "")
    at utility.c:360
#17 0x000000000093839c in PortalRunUtility (portal=0xa7b7758, pstmt=0xa79c358, isTopLevel=1 '\001', setHoldSnapshot=0 '\000',
    dest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "") at uxsqluery.c:1179
#18 0x0000000000938596 in PortalRunMulti (portal=0xa7b7758, isTopLevel=1 '\001', setHoldSnapshot=0 '\000',
    dest=0x8c90c60 <debugtupDR>, altdest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "") at uxsqluery.c:1325
#19 0x0000000000937ad0 in PortalRun (portal=0xa7b7758, count=9223372036854775807, isTopLevel=1 '\001', run_once=1 '\001',
    dest=0x8c90c60 <debugtupDR>, altdest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "") at uxsqluery.c:799
#20 0x0000000000931243 in exec_simple_query (query_string=0xa79b888 "create extension uxaudit;\n") at uxdb.c:1156
#21 0x0000000000935dee in UxdbMain (argc=7, argv=0xa6d5990, dbname=0xa6f7ce0 "uxdb", username=0xa6db3e0 "uxdb") at uxdb.c:4351
#22 0x000000000077aa2d in main (argc=7, argv=0xa6d5990) at main.c:235



标准版：
#0  _UX_init () at uxaudit.c:1846
#1  0x0000000000a5db51 in internal_load_library (libname=0x10cae80 "/home/uxdb/uxdbinstall/dbsql/lib/uxaudit.so")
    at dfmgr.c:349
#2  0x0000000000a5d63d in load_file (filename=0x108c2f8 "uxaudit", restricted=false) at dfmgr.c:187
#3  0x0000000000a69f92 in load_libraries (libraries=0x10acbd0 "uxaudit", gucname=0xd110ed "shared_preload_libraries",
    restricted=false, pluginname=0x0) at miscinit.c:1680
#4  0x0000000000a6a057 in process_shared_preload_libraries (extensionName=0x0) at miscinit.c:1699
#5  0x00000000008ec8a0 in UxdbMain (argc=7, argv=0x108c000, dbname=0x10ad4a0 "uxdb", username=0x1091990 "uxdb")
    at uxdb.c:4172
#6  0x000000000076f770 in main (argc=7, argv=0x108c000) at main.c:292

shared_preload_libraries


PostmasterMain
	SysLogger_Start
	Log_destination

审计功能移植：
40909

alter system set log_destination = 'csvlog';

init_audit
uxdb_config_auto_file
uxsinodb.auto.conf
ux_data
sprintf(autodestfile, "%s/%s", ux_data, "ux_template/uxsinodb.auto.conf");
regular_copy_file
PostmasterMain

DataDir

2021-08-09

1、
%s. epoll_add. group_id:%d start_id:%d  cidx:%d pid:%d eventfd:%d service_state:%d
循环告警：
WARNING:  grd: lrm is frozen

ResetLoadlibrary



2021-08-13

./ux_ctl -D uxdb_rac -o "-c uxdb_rac=on -c instance_id=1 -p 5432"

1、32

15:43:51,678 [main] INFO   jTPCC : Term-00,    Term-00, Running Average tpmTOTAL: 3425115:48:52,036 [Thread-17] INFO   jTPCC : Term-00, e: 285MB / 1461MB                     15:48:52,037 [Thread-17] INFO   jTPCC : Term-00,
15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 153953.7
15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Measured tpmTOTAL = 342362.26         15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Session Start     = 2021-08-13 15:43:51
15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Session End       = 2021-08-13 15:48:52
15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Transaction Count = 1712632

2、128

2021-08-17

work_mem：越大排序速度越快
effective_cache_size：是postgresql能够使用的最大缓存
maintenance_work_mem：这里定义的内存只是在CREATE INDEX, VACUUM等时用到，一般设置512M







数据库初始化时间：
2021-08-18 06:41:53.478
2021-08-18 06:47:30.997
tpcc加载时间：
2021-08-19 10:10:49.668

tpcc执行时间：
09:45:17,458

tpcc任务：
B) DIO在共享存储的增长率 (102,101,105 使用万兆网卡)
    1. DIO单实例在共享存储与本地磁盘(SSD)上性能比对
        TPCC： 执行 五分钟  terminal 64,96
     收集cpu<用户， 系统> 与 存储的网络状况 与火焰图；统计数据块请求消息
  2. 两实例在共享存储上的tpcc
      TPCC： 执行 五分钟   terminal 64,96
       收集cpu<用户， 系统> 与 存储的网络状况 与火焰图；统计数据块请求消息
  3. 三实例在共享存储上的tpcc
       TPCC： 执行 五分钟  terminal 64,96
       收集cpu<用户， 系统> 与 存储的网络状况 与火焰图；统计数据块请求消息


create table bmsql_order_line (
  ol_w_id         integer   not null,
  ol_d_id         integer   not null,
  ol_o_id         integer   not null,
  ol_number       integer   not null,
  ol_i_id         integer   not null,
  ol_delivery_d   timestamp,
  ol_amount       decimal(6,2),
  ol_supply_w_id  integer,
  ol_quantity     integer,
  ol_dist_info    char(24)
);

foreignKeys.sql
alter table bmsql_order_line add constraint ol_order_fkey
    foreign key (ol_w_id, ol_d_id, ol_o_id)
    references bmsql_oorder (o_w_id, o_d_id, o_id);
alter table bmsql_order_line add constraint ol_stock_fkey
    foreign key (ol_supply_w_id, ol_i_id)
    references bmsql_stock (s_w_id, s_i_id);

./sql.common/indexCreates.sql
alter table bmsql_order_line add constraint bmsql_order_line_pkey
  primary key (ol_w_id, ol_d_id, ol_o_id, ol_number);
insert into bmsql_order_line values(1,1,1,1,1,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(2,2,2,2,2,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(3,3,3,3,3,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(4,4,4,4,4,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(5,5,5,5,5,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(6,6,6,6,6,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(7,7,7,7,7,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(8,8,8,8,8,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(9,9,9,9,9,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(10,10,10,10,10,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(11,11,11,11,11,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(12,12,12,12,12,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(13,13,13,13,13,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(14,14,14,14,14,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(15,15,15,15,15,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(16,16,16,16,16,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(17,17,17,17,17,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(18,18,18,18,18,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(19,19,19,19,19,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(20,20,20,20,20,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(21,21,21,21,21,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(22,22,22,22,22,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(23,23,23,23,23,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(24,24,24,24,24,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(25,25,25,25,25,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(26,26,26,26,26,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(27,27,27,27,27,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(28,28,28,28,28,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(29,29,29,29,29,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(30,30,30,30,30,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(31,31,31,31,31,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(32,32,32,32,32,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(33,33,33,33,33,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(34,34,34,34,34,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(35,35,35,35,35,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(36,36,36,36,36,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(37,37,37,37,37,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(38,38,38,38,38,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(39,39,39,39,39,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(40,40,40,40,40,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
select ux_relation_size('bmsql_order_line_pkey');
827392

问题单：116464


tpcc问题：

1、扩展块问题（查看索引是否扩展）
2、tpcc报错问题


表空间：
uxdb=# select ux_relation_size('bmsql_stock');
 ux_relation_size
------------------
       1073725440
(1 row)

索引大小：
uxdb=# select ux_relation_size('bmsql_stock_pkey');
 ux_relation_size
------------------
       1096269824
(1 row)


uxdb=# \dt+
                              List of relations
 Schema |       Name       | Type  | Owner | Storage |  Size   | Description
--------+------------------+-------+-------+---------+---------+-------------
 public | bmsql_config     | table | uxdb  | heap    | 1024 MB |
 public | bmsql_customer   | table | uxdb  | heap    | 2049 MB |
 public | bmsql_district   | table | uxdb  | heap    | 1024 MB |
 public | bmsql_history    | table | uxdb  | heap    | 1024 MB |
 public | bmsql_item       | table | uxdb  | heap    | 1024 MB |
 public | bmsql_new_order  | table | uxdb  | heap    | 1024 MB |
 public | bmsql_oorder     | table | uxdb  | heap    | 1024 MB |
 public | bmsql_order_line | table | uxdb  | heap    | 1024 MB |
 public | bmsql_stock      | table | uxdb  | heap    | 1188 MB |
 public | bmsql_warehouse  | table | uxdb  | heap    | 1024 MB |

bmsql_order_line 索引增加

uxdb=# select ux_relation_size('bmsql_config_pkey');
 ux_relation_size
------------------
       1073733632
(1 row)

uxdb=# select ux_relation_size('bmsql_customer_pkey');
 ux_relation_size
------------------
       1083211776
(1 row)

uxdb=# select ux_relation_size('bmsql_district_pkey');
 ux_relation_size
------------------
       1073741824
(1 row)

uxdb=# select ux_relation_size('bmsql_history_pkey');
 ux_relation_size
------------------
       1080500224
(1 row)

uxdb=#
uxdb=# select ux_relation_size('bmsql_item_pkey');
 ux_relation_size
------------------
       1075986432
(1 row)

uxdb=# select ux_relation_size('bmsql_new_order_pkey');
 ux_relation_size
------------------
       1076584448
(1 row)

uxdb=# select ux_relation_size('bmsql_oorder_pkey');
 ux_relation_size
------------------
       1083211776
(1 row)

uxdb=# select ux_relation_size('bmsql_order_line_pkey');
 ux_relation_size
------------------
       1168359424
(1 row)


uxdb=# select ux_relation_size('bmsql_stock_pkey');
 ux_relation_size
------------------
       1096269824
(1 row)

uxdb=# select ux_relation_size('bmsql_warehouse_pkey');
 ux_relation_size
------------------
       1073741824
(1 row)

tpcc报错：
FATAL: failed to re-find parent key in index "227236" for split pages 370/371


修复分区
https://forum.ubuntu.org.cn/viewtopic.php?t=382482
sudo e2fsck -b 32768 -y /dev/sda6


iqn.2021-08.com.uxsino:104server

索引
right sibling's left-link doesn't match: block 11698 links to 7588 instead of expected 4616 in index "bmsql_order_line_pkey"

共享存储tpcc报错：
1、        edge----> (instId %u, pid %d, xid %u)


2、

2021-08-24 10:28:31.514 CST [41311] WARNING:  clog msg resend: src_id:1, des_id:2, events:8, index:[2-9], xid:[618-623]
2021-08-24 10:28:43.518 CST [41311] WARNING:  clog msg resend: src_id:1, des_id:2, events:8, index:[3027-3034], xid:[6885-6908]
2021-08-24 10:28:55.523 CST [41311] WARNING:  clog msg resend: src_id:1, des_id:2, events:8, index:[5851-5858], xid:[12348-12356]
2021-08-24 10:29:07.529 CST [41311] WARNING:  clog msg resend: src_id:1, des_id:2, events:8, index:[6923-6930], xid:[14333-14350]
2021-08-24 10:29:18.010 CST [41321] LOG:  GDD-GlobalDeadLockDetect-detect: finish collect 1 instances reply msg packet. allInstanceDependsCount 37
2021-08-24 10:29:18.010 CST [41321] LOG:  GDD-ShowLDG: HAS CIRCLES, after delete, remain 1 vertexs on the circle.
2021-08-24 10:29:18.010 CST [41321] LOG:  GDD-ShowLDG: vexnum 1 arcnum 3
2021-08-24 10:29:18.010 CST [41321] LOG:  GDD-ShowLDG: vextex info:


3、unexpected EOF on client connection with an open transaction

4、bmsql_order_line_pkey

注释：
 mdextend file:


2021-08-25

偶先共享锁问题；

[Thread-58] ERROR  jTPCCTData : Unexpected SQLException in NEW_ORDER Usage:18:06:57,785 [Thread-58] ERROR  jTPCCTData : Batch entry 8 INSERT INTO bmsql_order_line (    ol_o_id, ol_d_id, ol_w_id, ol_number,     ol_i_id, ol_supply_w_id, ol_quantity,     ol_amount, ol_dist_info) VALUES (3021, 5, 6, 9, 49825, 6, 5, 206.4, 'XRlf2qVwQzUZEHOTlqvnBuAL') was aborted: ERROR: right sibling's left-link doesn't match: block 11594 links to 10361 instead of expected 6350 in index "bmsql_order_line_pkey"  Call getNextException to see other errors in the batch.
18:06:57,786 [Thread-58] ERROR  jTPCCTData : ERROR: right sibling's left-link doesn't match: block 11594 links to 10361 instead of expected 6350 in index "bmsql_order_line_pkey"
java.sql.BatchUpdateException: Batch entry 8 INSERT INTO bmsql_order_line (    ol_o_id, ol_d_id, ol_w_id, ol_number,     ol_i_id, ol_supply_w_id, ol_quantity,     ol_amount, ol_dist_info) VALUES (3021, 5, 6, 9, 49825, 6, 5, 206.4, 'XRlf2qVwQzUZEHOTlqvnBuAL') was aborted: ERROR: right sibling's left-link doesn't match: block 11594 links to 10361 instead of expected 6350 in index "bmsql_order_line_pkey"  Call getNextException to see other errors in the batch.
        at com.uxdb.jdbc.BatchResultHandler.handleError(BatchResultHandler.java:148)
        at com.uxdb.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2126)
        at com.uxdb.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:469)
        at com.uxdb.jdbc.PgStatement.executeBatch(PgStatement.java:791)
        at com.uxdb.jdbc.PgPreparedStatement.executeBatch(PgPreparedStatement.java:1547)
        at jTPCCTData.executeNewOrder(jTPCCTData.java:566)
        at jTPCCTData.execute(jTPCCTData.java:95)
        at jTPCCTerminal.executeTransactions(jTPCCTerminal.java:261)
        at jTPCCTerminal.run(jTPCCTerminal.java:88)
        at java.lang.Thread.run(Thread.java:748)
Caused by: com.uxdb.util.PSQLException: ERROR: right sibling's left-link doesn't match: block 11594 links to 10361 instead of expected 6350 in index "bmsql_order_line_pkey"
        at com.uxdb.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2412)
        at com.uxdb.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2125)


首先查看 FSM 是否知道任何空闲页面。
*
* 我们不能毫无保留地相信 FSM 的报告；我们必须检查该页面是否仍然可用。 （例如，一个已经空闲的页面可能在上次 VACUUM 扫描它的时间和 VACUUM 进行 FSM 更新的时间之间被重新使用。）
*
* 事实上，情况比这更糟糕：我们甚至不能假设锁定报告页面是安全的。如果其他人锁定了它，或者更糟糕的是我们自己的调用者锁定了它，我们可能会死锁。 （自己的调用者场景实际上并非不可能。考虑在串行或时间戳列上的索引。几乎所有拆分都将在最右边的页面，因此 _bt_split 完全有可能在持有最近获取的页面上的锁的同时调用我们来自 FSM。与前一个拆分同时运行的 VACUUM 很可能将该页面放回 FSM。）
*
* 为了解决这个问题，我们只要求对报告页面进行条件锁定。如果我们失败了，那么其他人正在使用该页面，我们可以合理地假设它不是免费的。 （如果我们碰巧错了，最坏的后果是页面将丢失，直到下一次 VACUUM 才能使用，这没什么大问题。）

设置扩展块大小：
expand_block_number=262200


bmsql_config：11:41 - 11:45
bmsql_warehouse
bmsql_district
bmsql_customer
bmsql_history
bmsql_new_order
bmsql_oorder			11:56
bmsql_order_line
bmsql_stock
bmsql_warehouse




uxdb=# select * from pcm_request_statistics();
 instanceid | requests | resourcerequests | readrequests | writerequests | retryrequests | timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+---------------+---------+----------+-------------+----------
          1 |  4540122 |           288793 |      2136171 |       2115158 |             0 |       0 |  2328112 |     2076547 |   135463
          2 |  4640344 |           300063 |      1980443 |       2359838 |             0 |       0 |  2108604 |     2348700 |   183040


15:59:07,477 [main] INFO   jTPCTerm-00, Running Average tpmTOTAL: 88223.10    Current tpmTOTAL: 2918484    Me16:04:09,405 [Thread-69] INFO   jTPCC : Term-00, 1484MB                                                      16:04:09,418 [Thread-69] INFO   jTPCC : Term-00,                                                             16:04:09,420 [Thread-69] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 39687.43                        16:04:09,420 [Thread-69] INFO   jTPCC : Term-00, Measured tpmTOTAL = 88172.47                                16:04:09,421 [Thread-69] INFO   jTPCC : Term-00, Session Start     = 2021-08-26 15:59:09
16:04:09,421 [Thread-69] INFO   jTPCC : Term-00, Session End       = 2021-08-26 16:04:09
16:04:09,421 [Thread-69] INFO   jTPCC : Term-00, Transaction Count = 441192


tpcc  100仓数据：
uxdb=# \d+
                                 List of relations
 Schema |       Name        |   Type   | Owner | Storage |    Size    | Description
--------+-------------------+----------+-------+---------+------------+-------------
 public | bmsql_config      | table    | uxdb  | heap    | 8192 bytes |
 public | bmsql_customer    | table    | uxdb  | heap    | 1775 MB    |
 public | bmsql_district    | table    | uxdb  | heap    | 192 kB     |
 public | bmsql_hist_id_seq | sequence | uxdb  | heap    | 8192 bytes |
 public | bmsql_history     | table    | uxdb  | heap    | 253 MB     |
 public | bmsql_item        | table    | uxdb  | heap    | 10 MB      |
 public | bmsql_new_order   | table    | uxdb  | heap    | 38 MB      |
 public | bmsql_oorder      | table    | uxdb  | heap    | 190 MB     |
 public | bmsql_order_line  | table    | uxdb  | heap    | 2894 MB    |
 public | bmsql_stock       | table    | uxdb  | heap    | 3397 MB    |
 public | bmsql_warehouse   | table    | uxdb  | heap    | 112 kB     |
(11 rows)

https://www.cnblogs.com/wqcheng/p/6618068.html
/dev/sdg
/dev/sdf

pvcreate /dev/sdb //硬盘1
pvcreate /dev/sdc //硬盘2

vgcreate LVM /dev/sdb

vgextend LVM /dev/sdc

lvcreate -L5.0T -nDB_DATA LVM


SELECT
procpid,
start,
now() - start AS lap,
current_query
FROM
(SELECT
backendid,
ux_stat_get_backend_pid(S.backendid) AS procpid,
ux_stat_get_backend_activity_start(S.backendid) AS start,
ux_stat_get_backend_activity(S.backendid) AS current_query
FROM
(SELECT ux_stat_get_backend_idset() AS backendid) AS S
) AS S
WHERE
current_query <> '<IDLE>'
ORDER BY
lap DESC;


with
t_wait as
(
  select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted,
  a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,
  b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name
    from ux_locks a,ux_stat_activity b where a.pid=b.pid and not a.granted
),
t_run as
(
  select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted,
  a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,
  b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name
    from ux_locks a,ux_stat_activity b where a.pid=b.pid and a.granted
),
t_overlap as
(
  select r.* from t_wait w join t_run r on
  (
    r.locktype is not distinct from w.locktype and
    r.database is not distinct from w.database and
    r.relation is not distinct from w.relation and
    r.page is not distinct from w.page and
    r.tuple is not distinct from w.tuple and
    r.virtualxid is not distinct from w.virtualxid and
    r.transactionid is not distinct from w.transactionid and
    r.classid is not distinct from w.classid and
    r.objid is not distinct from w.objid and
    r.objsubid is not distinct from w.objsubid and
    r.pid <> w.pid
  )
),
t_unionall as
(
  select r.* from t_overlap r
  union all
  select w.* from t_wait w
)
select locktype,datname,relation::regclass,page,tuple,virtualxid,transactionid::text,classid::regclass,objid,objsubid,
string_agg(
'Pid: '||case when pid is null then 'NULL' else pid::text end||chr(10)||
'Lock_Granted: '||case when granted is null then 'NULL' else granted::text end||' , Mode: '||case when mode is null then 'NULL' else mode::text end||' , FastPath: '||case when fastpath is null then 'NULL' else fastpath::text end||' , VirtualTransaction: '||case when virtualtransaction is null then 'NULL' else virtualtransaction::text end||' , Session_State: '||case when state is null then 'NULL' else state::text end||chr(10)||
'Username: '||case when usename is null then 'NULL' else usename::text end||' , Database: '||case when datname is null then 'NULL' else datname::text end||' , Client_Addr: '||case when client_addr is null then 'NULL' else client_addr::text end||' , Client_Port: '||case when client_port is null then 'NULL' else client_port::text end||' , Application_Name: '||case when application_name is null then 'NULL' else application_name::text end||chr(10)||
'Xact_Start: '||case when xact_start is null then 'NULL' else xact_start::text end||' , Query_Start: '||case when query_start is null then 'NULL' else query_start::text end||' , Xact_Elapse: '||case when (now()-xact_start) is null then 'NULL' else (now()-xact_start)::text end||' , Query_Elapse: '||case when (now()-query_start) is null then 'NULL' else (now()-query_start)::text end||chr(10)||
'SQL (Current SQL in Transaction): '||chr(10)||
case when query is null then 'NULL' else query::text end,
chr(10)||'--------'||chr(10)
order by
  (  case mode
    when 'INVALID' then 0
    when 'AccessShareLock' then 1
    when 'RowShareLock' then 2
    when 'RowExclusiveLock' then 3
    when 'ShareUpdateExclusiveLock' then 4
    when 'ShareLock' then 5
    when 'ShareRowExclusiveLock' then 6
    when 'ExclusiveLock' then 7
    when 'AccessExclusiveLock' then 8
    else 0
  end  ) desc,
  (case when granted then 0 else 1 end)
) as lock_conflict
from t_unionall
group by
locktype,datname,relation,page,tuple,virtualxid,transactionid::text,classid,objid,objsubid ;

合并硬盘：
/dev/sdg
/dev/sdf

pvcreate /dev/sdg
pvcreate /dev/sdf

vgcreate LVM /dev/sdg1
移除vg：
vgremove  LVM

vgextend LVM /dev/sdf

lvcreate -L186G -nDB_DATA LVM

479.0

958


lvcreate -l 47683  -n DB_DATA LVM


2021-09-01

bmsql_config
bmsql_item
bmsql_new_order
bmsql_warehouse

1GB
set expand_block_number=131070;
1000仓, (跑10分钟)
 public | bmsql_config      |
 public | bmsql_customer    | 30GB		3932100
 public | bmsql_district    | 2GB		262140
 public | bmsql_hist_id_seq |
 public | bmsql_history     | 4GB		524280
 public | bmsql_item        | 100MB		12800
 public | bmsql_new_order   | 1GB		131070
 public | bmsql_oorder      | 4GB		524280
 public | bmsql_order_line  | 50GB		6553500
 public | bmsql_stock       | 60GB		7864200
 public | bmsql_warehouse   | 1GB		131070



 20GB=2621400

1000仓, (跑20分钟)

 public | bmsql_config      |
 public | bmsql_customer    | 40GB		5242800
 public | bmsql_district    | 5GB		655350
 public | bmsql_hist_id_seq |
 public | bmsql_history     | 5GB		655350
 public | bmsql_item        | 100MB		12800
 public | bmsql_new_order   | 1.5GB		196605
 public | bmsql_oorder      | 4.5GB		589815
 public | bmsql_order_line  | 65GB		8519550
 public | bmsql_stock       | 100GB		13107000
 public | bmsql_warehouse   | 2.5GB		327675
 


 select expand_fsm_block(16384,3,0); | bmsql_config                                                   
 select expand_fsm_block(16389,3,0); | bmsql_warehouse                                                
 select expand_fsm_block(16392,3,0); | bmsql_district                                                 
 select expand_fsm_block(16395,3,0); | bmsql_customer                                                 
 select expand_fsm_block(16403,3,0); | bmsql_history
 select expand_fsm_block(16406,3,0); | bmsql_new_order
 select expand_fsm_block(16409,3,0); | bmsql_oorder
 select expand_fsm_block(16412,3,0); | bmsql_order_line
 select expand_fsm_block(16415,3,0); | bmsql_item
 select expand_fsm_block(16418,3,0); | bmsql_stock







ux_prewarm.sql,1000仓加载块大小

select expand_fsm_block(16389,8,512);
select expand_fsm_block(16392,8,512);			（6等分）		（4等份）
select expand_fsm_block(16395,8,2290688);		381781			572672			bmsql_customer
select expand_fsm_block(16403,8,324608);		54101			81152			bmsql_history
select expand_fsm_block(16406,8,49152);			8192			12288			bmsql_new_order	
select expand_fsm_block(16409,8,243200);		40533			60800			bmsql_oorder
select expand_fsm_block(16412,8,3703808);		617301			925952			bmsql_order_line
select expand_fsm_block(16415,8,1536);			256				384				bmsql_item
select expand_fsm_block(16418,8,4347904);		724650			1086976			bmsql_stock
select expand_fsm_block(16435,8,275456);		45,909			68864			bmsql_stock_pkey

1000仓总大小													总大小			加载后块开始大小		剩余大小   剩余6等分    剩余4等份
select ux_prewarm('bmsql_customer',0,381781);					5242800			2290689					2952112		492018			738028
select ux_prewarm('bmsql_history',0,54101);						655350			324609					330742		55123			82685
select ux_prewarm('bmsql_new_order',0,8192);					196605			49153					147453		24575			36863
select ux_prewarm('bmsql_oorder',0,40533);						589815			243201					346615		57769			86653
select ux_prewarm('bmsql_order_line',0,617301);					8519550			3703809					4815742		802623			1203935
select ux_prewarm('bmsql_item',0,256);							12800			1537					11264		1877			2816
select ux_prewarm('bmsql_stock',0,724650);						13107000		4347905					8759096		1459849			2189774
select ux_prewarm('bmsql_stock_pkey',0,45909);					8519550			275457					8244094		1374015			2061023

select expand_fsm_block(16435,8,275456);		45909
select ux_prewarm('bmsql_config_PKEY');			总块号		4等份		6等分			
select ux_prewarm('bmsql_customer_idx1');		2621400		655350			436900
select ux_prewarm('bmsql_customer_pkey');		2621400
select ux_prewarm('bmsql_district_pkey');		327675		81918			54612
select ux_prewarm('bmsql_item_pkey');			12800		3200			2133
select ux_prewarm('bmsql_new_order_pkey');		196605		49151			32767
select ux_prewarm('bmsql_oorder_idx1');			327675
select ux_prewarm('bmsql_oorder_pkey');			327675
select ux_prewarm('bmsql_order_line_pkey');		5242800		1310700			873800
select ux_prewarm('bmsql_warehouse_pkey');		327675

bmsql_warehouse									327675					54612						
bmsql_district									655350					109225			


四等份
节点1：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',0,81918);
select ux_prewarm('bmsql_district','buffer','main',0,163837);

select ux_prewarm('bmsql_customer','buffer','main',0,572672);
select ux_prewarm('bmsql_history','buffer','main',0,81152);
select ux_prewarm('bmsql_new_order','buffer','main',0,12288);
select ux_prewarm('bmsql_oorder','buffer','main',0,60800);
select ux_prewarm('bmsql_order_line','buffer','main',0,925952);
select ux_prewarm('bmsql_item','buffer','main',0,384);
select ux_prewarm('bmsql_stock','buffer','main',0,1086976);
select ux_prewarm('bmsql_stock_pkey','buffer','main',0,68864);

select ux_prewarm('bmsql_customer','buffer','main',2290689,3028717);
select ux_prewarm('bmsql_history','buffer','main',324609,407294);
select ux_prewarm('bmsql_new_order','buffer','main',49153,86016);
select ux_prewarm('bmsql_oorder','buffer','main',243201,329854);
select ux_prewarm('bmsql_order_line','buffer','main',3703809,4907744);
select ux_prewarm('bmsql_item','buffer','main',1537,4353);
select ux_prewarm('bmsql_stock','buffer','main',4347905,6537679);
select ux_prewarm('bmsql_stock_pkey','buffer','main',275457,2336480);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',0,655350);
select ux_prewarm('bmsql_customer_pkey','buffer','main',0,655350);
select ux_prewarm('bmsql_district_pkey','buffer','main',0,81918);
select ux_prewarm('bmsql_item_pkey','buffer','main',0,3200);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',0,49151);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',0,81918);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',0,81918);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',0,1310700);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',0,81918);

checkpoint;

节点2：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',81919,163836);
select ux_prewarm('bmsql_district','buffer','main',163838,327674);

select ux_prewarm('bmsql_customer','buffer','main',572673,1145344);
select ux_prewarm('bmsql_history','buffer','main',81153, 162304);
select ux_prewarm('bmsql_new_order','buffer','main',12289, 24576);
select ux_prewarm('bmsql_oorder','buffer','main',60801,121600);
select ux_prewarm('bmsql_order_line','buffer','main',925953,1851904);
select ux_prewarm('bmsql_item','buffer','main',385,768);
select ux_prewarm('bmsql_stock','buffer','main',1086977, 2173952);
select ux_prewarm('bmsql_stock_pkey','buffer','main',68865,137728);

select ux_prewarm('bmsql_customer','buffer','main',3028718,3766745);
select ux_prewarm('bmsql_history','buffer','main',407295, 489979);
select ux_prewarm('bmsql_new_order','buffer','main',86017, 122879);
select ux_prewarm('bmsql_oorder','buffer','main',329855,416507);
select ux_prewarm('bmsql_order_line','buffer','main',4907745,6111679);
select ux_prewarm('bmsql_item','buffer','main',4354,7169);
select ux_prewarm('bmsql_stock','buffer','main',6537680, 8727453);
select ux_prewarm('bmsql_stock_pkey','buffer','main',2336481,4397503);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',655351,1310700);
select ux_prewarm('bmsql_customer_pkey','buffer','main',655351,1310700);
select ux_prewarm('bmsql_district_pkey','buffer','main',81919,163836);
select ux_prewarm('bmsql_item_pkey','buffer','main',3201,6400);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',49152,98302);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',81919,163836);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',81919,163836);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',1310701,2621400);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',81919,163836);
checkpoint;
节点3：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',163837,245754);
select ux_prewarm('bmsql_district','buffer','main',327675,491511);

select ux_prewarm('bmsql_customer','buffer','main',1145345,1718016);
select ux_prewarm('bmsql_history','buffer','main',162305, 243456);
select ux_prewarm('bmsql_new_order','buffer','main',24577,36864);
select ux_prewarm('bmsql_oorder','buffer','main',121601,182400);
select ux_prewarm('bmsql_order_line','buffer','main',1851905,2777856);
select ux_prewarm('bmsql_item','buffer','main',769,1152);
select ux_prewarm('bmsql_stock','buffer','main',2173953,3260928);
select ux_prewarm('bmsql_stock_pkey','buffer','main',137729,206592);

select ux_prewarm('bmsql_customer','buffer','main',3766746,4504773);
select ux_prewarm('bmsql_history','buffer','main',489980, 572664);
select ux_prewarm('bmsql_new_order','buffer','main',122880,159742);
select ux_prewarm('bmsql_oorder','buffer','main',416508,503160);
select ux_prewarm('bmsql_order_line','buffer','main',6111680,7315614);
select ux_prewarm('bmsql_item','buffer','main',7170,9985);
select ux_prewarm('bmsql_stock','buffer','main',8727454,10917227);
select ux_prewarm('bmsql_stock_pkey','buffer','main',4397504,6458526);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',1310701,1966050);
select ux_prewarm('bmsql_customer_pkey','buffer','main',1310701,1966050);
select ux_prewarm('bmsql_district_pkey','buffer','main',163837,245754);
select ux_prewarm('bmsql_item_pkey','buffer','main',6401,9600);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',98303,147453);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',163837,245754);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',163837,245754);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',2621401,3932100);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',163837,245754);
checkpoint;
节点4：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',245755,327674);
select ux_prewarm('bmsql_district','buffer','main',491512,655349);

select ux_prewarm('bmsql_customer','buffer','main',1718017, 2290688);
select ux_prewarm('bmsql_history','buffer','main', 243457, 324608);
select ux_prewarm('bmsql_new_order','buffer','main',36865, 49152);
select ux_prewarm('bmsql_oorder','buffer','main',182401,243200);
select ux_prewarm('bmsql_order_line','buffer','main',2777857, 3703808);
select ux_prewarm('bmsql_item','buffer','main',1153,1536);
select ux_prewarm('bmsql_stock','buffer','main',3260929, 4347904);
select ux_prewarm('bmsql_stock_pkey','buffer','main',206593,275456);

select ux_prewarm('bmsql_customer','buffer','main',3766744, 5242799);
select ux_prewarm('bmsql_history','buffer','main', 572665, 655349);
select ux_prewarm('bmsql_new_order','buffer','main',159743, 196604);
select ux_prewarm('bmsql_oorder','buffer','main',503161,589814);
select ux_prewarm('bmsql_order_line','buffer','main',7315615, 8519549);
select ux_prewarm('bmsql_item','buffer','main',9986,12799);
select ux_prewarm('bmsql_stock','buffer','main',10917228, 13106999);
select ux_prewarm('bmsql_stock_pkey','buffer','main',6458527,8519549);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',1966051,2621399);
select ux_prewarm('bmsql_customer_pkey','buffer','main',1966051,2621399);
select ux_prewarm('bmsql_district_pkey','buffer','main',245755,327674);
select ux_prewarm('bmsql_item_pkey','buffer','main',9601,12799);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',147454,196604);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',245755,327674);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',245755,327674);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',3932101,5242799);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',245755,327674);
checkpoint;

select ux_prewarm('bmsql_config_PKEY');			总块号		4等份		6等分			
select ux_prewarm('bmsql_customer_idx1');		2621400		655350			436900
select ux_prewarm('bmsql_customer_pkey');		2621400
select ux_prewarm('bmsql_district_pkey');		327675		81918			54612
select ux_prewarm('bmsql_item_pkey');			12800		3200			2133
select ux_prewarm('bmsql_new_order_pkey');		196605		49151			32767
select ux_prewarm('bmsql_oorder_idx1');			327675
select ux_prewarm('bmsql_oorder_pkey');			327675
select ux_prewarm('bmsql_order_line_pkey');		5242800		1310700			873800
select ux_prewarm('bmsql_warehouse_pkey');		327675

1000仓总大小													总大小			加载后块开始大小		剩余大小   剩余6等分    剩余4等份
select ux_prewarm('bmsql_customer',0,381781);					5242800			2290689					2952112		492018			738028
select ux_prewarm('bmsql_history',0,54101);						655350			324609					330742		55123			82685
select ux_prewarm('bmsql_new_order',0,8192);					196605			49153					147453		24575			36863
select ux_prewarm('bmsql_oorder',0,40533);						589815			243201					346615		57769			86653
select ux_prewarm('bmsql_order_line',0,617301);					8519550			3703809					4815742		802623			1203935
select ux_prewarm('bmsql_item',0,256);							12800			1537					11264		1877			2816
select ux_prewarm('bmsql_stock',0,724650);						13107000		4347905					8759096		1459849			2189774
select ux_prewarm('bmsql_stock_pkey',0,45909);					8519550			275457					8244094		1374015			2061023






















六等份
节点1：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',0,54612);
select ux_prewarm('bmsql_district','buffer','main',0,109225);

select ux_prewarm('bmsql_customer','buffer','main',0,381781);
select ux_prewarm('bmsql_history','buffer','main',0,54101);
select ux_prewarm('bmsql_new_order','buffer','main',0,8192);
select ux_prewarm('bmsql_oorder','buffer','main',0,40533);
select ux_prewarm('bmsql_order_line','buffer','main',0,617301);
select ux_prewarm('bmsql_item','buffer','main',0,256);
select ux_prewarm('bmsql_stock','buffer','main',0,724650);
select ux_prewarm('bmsql_stock_pkey','buffer','main',0,45909);

select ux_prewarm('bmsql_customer','buffer','main',2290689,2782707);
select ux_prewarm('bmsql_history','buffer','main',324609,379732);
select ux_prewarm('bmsql_new_order','buffer','main',49153,73728);
select ux_prewarm('bmsql_oorder','buffer','main',243201,300970);
select ux_prewarm('bmsql_order_line','buffer','main',3703809,4506432);
select ux_prewarm('bmsql_item','buffer','main',1537,3414);
select ux_prewarm('bmsql_stock','buffer','main',4347905,5807754);
select ux_prewarm('bmsql_stock_pkey','buffer','main',275457,1649472);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',0,436900);
select ux_prewarm('bmsql_customer_pkey','buffer','main',0,436900);
select ux_prewarm('bmsql_district_pkey','buffer','main',0,54612);
select ux_prewarm('bmsql_item_pkey','buffer','main',0,2133);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',0,32767);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',0,54612);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',0,54612);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',0,873800);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',0,54612);

checkpoint;

节点2：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',54613,109224);
select ux_prewarm('bmsql_district','buffer','main',109226,218450);

select ux_prewarm('bmsql_customer','buffer','main',381782,763562);
select ux_prewarm('bmsql_history','buffer','main',54102, 108202);
select ux_prewarm('bmsql_new_order','buffer','main',8193, 16384);
select ux_prewarm('bmsql_oorder','buffer','main',40534,81066);
select ux_prewarm('bmsql_order_line','buffer','main',617302,1234602);
select ux_prewarm('bmsql_item','buffer','main',257,512);
select ux_prewarm('bmsql_stock','buffer','main',724651, 1449300);
select ux_prewarm('bmsql_stock_pkey','buffer','main',45910,91818);

select ux_prewarm('bmsql_customer','buffer','main',2782708,3274725);
select ux_prewarm('bmsql_history','buffer','main',379733, 434855);
select ux_prewarm('bmsql_new_order','buffer','main',73729, 98303);
select ux_prewarm('bmsql_oorder','buffer','main',300971,358739);
select ux_prewarm('bmsql_order_line','buffer','main',4506433,5309055);
select ux_prewarm('bmsql_item','buffer','main',3415,5291);
select ux_prewarm('bmsql_stock','buffer','main',5807755, 7267603);
select ux_prewarm('bmsql_stock_pkey','buffer','main',1649473,3023487);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',436901,873800);
select ux_prewarm('bmsql_customer_pkey','buffer','main',436901,873800);
select ux_prewarm('bmsql_district_pkey','buffer','main',54613,109224);
select ux_prewarm('bmsql_item_pkey','buffer','main',2134,4266);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',32768,65534);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',54613,109224);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',54613,109224);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',873801,1747600);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',54613,109224);
checkpoint;
节点3：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',109225,163836);
select ux_prewarm('bmsql_district','buffer','main',218451,327675);

select ux_prewarm('bmsql_customer','buffer','main',763563,1145343);
select ux_prewarm('bmsql_history','buffer','main',108203, 162303);
select ux_prewarm('bmsql_new_order','buffer','main',16385,24576);
select ux_prewarm('bmsql_oorder','buffer','main',81067,121599);
select ux_prewarm('bmsql_order_line','buffer','main',234603,1851903);
select ux_prewarm('bmsql_item','buffer','main',513,768);
select ux_prewarm('bmsql_stock','buffer','main',1449301,2173950);
select ux_prewarm('bmsql_stock_pkey','buffer','main',91818,137727);

select ux_prewarm('bmsql_customer','buffer','main',3274726,3766743);
select ux_prewarm('bmsql_history','buffer','main',434856, 489978);
select ux_prewarm('bmsql_new_order','buffer','main',98304,122878);
select ux_prewarm('bmsql_oorder','buffer','main',358740,416508);
select ux_prewarm('bmsql_order_line','buffer','main',5309056,6111678);
select ux_prewarm('bmsql_item','buffer','main',5292,7168);
select ux_prewarm('bmsql_stock','buffer','main',7267604,8727452);
select ux_prewarm('bmsql_stock_pkey','buffer','main',3023488,4397502);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',873801,1310700);
select ux_prewarm('bmsql_customer_pkey','buffer','main',873801,1310700);
select ux_prewarm('bmsql_district_pkey','buffer','main',109225,163836);
select ux_prewarm('bmsql_item_pkey','buffer','main',4267,6399);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',65535,98301);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',109225,163836);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',109225,163836);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',1747601,2621400);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',109225,163836);
checkpoint;
节点4：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',163837,218448);
select ux_prewarm('bmsql_district','buffer','main',327676,436900);

select ux_prewarm('bmsql_customer','buffer','main',1145344, 1527124);
select ux_prewarm('bmsql_history','buffer','main', 162304, 216404);
select ux_prewarm('bmsql_new_order','buffer','main',24577, 32768);
select ux_prewarm('bmsql_oorder','buffer','main',121600,162132);
select ux_prewarm('bmsql_order_line','buffer','main',1851904, 2469204);
select ux_prewarm('bmsql_item','buffer','main',769,1024);
select ux_prewarm('bmsql_stock','buffer','main',2173951, 2898600);
select ux_prewarm('bmsql_stock_pkey','buffer','main',137728,183636);

select ux_prewarm('bmsql_customer','buffer','main',3766744, 4258761);
select ux_prewarm('bmsql_history','buffer','main', 489979, 545101);
select ux_prewarm('bmsql_new_order','buffer','main',122879, 147453);
select ux_prewarm('bmsql_oorder','buffer','main',416509,474277);
select ux_prewarm('bmsql_order_line','buffer','main',6111679, 6914301);
select ux_prewarm('bmsql_item','buffer','main',7169,9045);
select ux_prewarm('bmsql_stock','buffer','main',8727453, 10187301);
select ux_prewarm('bmsql_stock_pkey','buffer','main',4397503,5771517);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',1310701,1747600);
select ux_prewarm('bmsql_customer_pkey','buffer','main',1310701,1747600);
select ux_prewarm('bmsql_district_pkey','buffer','main',163837,218448);
select ux_prewarm('bmsql_item_pkey','buffer','main',6400,8532);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',98302,131068);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',163837,218448);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',163837,218448);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',2621401,3495200);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',163837,218448);
checkpoint;
节点5：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',218449,273060);
select ux_prewarm('bmsql_district','buffer','main',436901,546125);

select ux_prewarm('bmsql_customer','buffer','main',4258762, 4750779);
select ux_prewarm('bmsql_history','buffer','main',216405, 270505);
select ux_prewarm('bmsql_new_order','buffer','main',32769, 40960);
select ux_prewarm('bmsql_oorder','buffer','main',162133, 202665);
select ux_prewarm('bmsql_order_line','buffer','main',2469205,3086505);
select ux_prewarm('bmsql_item','buffer','main',1025,1280);
select ux_prewarm('bmsql_stock','buffer','main',2898601,3623250);
select ux_prewarm('bmsql_stock_pkey','buffer','main',183637,229545);

select ux_prewarm('bmsql_customer','buffer','main',1527124, 1908905);
select ux_prewarm('bmsql_history','buffer','main',545102, 600224);
select ux_prewarm('bmsql_new_order','buffer','main',147454, 172028);
select ux_prewarm('bmsql_oorder','buffer','main',474278, 532046);
select ux_prewarm('bmsql_order_line','buffer','main',6914302,7716924);
select ux_prewarm('bmsql_item','buffer','main',9046,10922);
select ux_prewarm('bmsql_stock','buffer','main',10187302,11647150);
select ux_prewarm('bmsql_stock_pkey','buffer','main',5771518,7145532);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',1747601,2184500);
select ux_prewarm('bmsql_customer_pkey','buffer','main',1747601,2184500);
select ux_prewarm('bmsql_district_pkey','buffer','main',218449,273060);
select ux_prewarm('bmsql_item_pkey','buffer','main',8533,10665);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',131069,163835);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',218449,273060);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',218449,273060);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',3495201,4369000);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',218449,273060);
checkpoint;
节点6：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',273061, 327674);
select ux_prewarm('bmsql_district','buffer','main',546125, 655349);

select ux_prewarm('bmsql_customer','buffer','main',1908906,2290688);
select ux_prewarm('bmsql_history','buffer','main',270505, 324608);
select ux_prewarm('bmsql_new_order','buffer','main',40960, 49152);
select ux_prewarm('bmsql_oorder','buffer','main',202666, 243200);
select ux_prewarm('bmsql_order_line','buffer','main',3086506,3703808);
select ux_prewarm('bmsql_item','buffer','main',1280,1536);
select ux_prewarm('bmsql_stock','buffer','main',3623251,4347904);
select ux_prewarm('bmsql_stock_pkey','buffer','main',229546,275456);

select ux_prewarm('bmsql_customer','buffer','main',4750780,5242799);
select ux_prewarm('bmsql_history','buffer','main',600225, 655349);
select ux_prewarm('bmsql_new_order','buffer','main',172029, 196604);
select ux_prewarm('bmsql_oorder','buffer','main',532047, 589814);
select ux_prewarm('bmsql_order_line','buffer','main',7716925,8519549);
select ux_prewarm('bmsql_item','buffer','main',10923,12799);
select ux_prewarm('bmsql_stock','buffer','main',11647151,13106999);
select ux_prewarm('bmsql_stock_pkey','buffer','main',7145533,8519549);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',2184501, 2621400);
select ux_prewarm('bmsql_customer_pkey','buffer','main',2184501, 2621400);
select ux_prewarm('bmsql_district_pkey','buffer','main',273061, 327675);
select ux_prewarm('bmsql_item_pkey','buffer','main',10666,12800);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',163835,196605);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',273061, 327675);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',273061, 327675);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',4369000,5242800);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',273061, 327675);
checkpoint;


1000仓总大小													总大小			加载后块开始大小		剩余大小   剩余6等分
select ux_prewarm('bmsql_customer',0,381781);					5242800			2290689					2952112		492018
select ux_prewarm('bmsql_history',0,54101);						655350			324609					330742		55123
select ux_prewarm('bmsql_new_order',0,8192);					196604			49153					147453		24575
select ux_prewarm('bmsql_oorder',0,40533);						589814			243201					346615		57769
select ux_prewarm('bmsql_order_line',0,617301);					8519549			3703809					4815742		802623
select ux_prewarm('bmsql_item',0,256);							12799			1537					11264		1877
select ux_prewarm('bmsql_stock',0,724650);						13106999		4347905					8759096		1459849
select ux_prewarm('bmsql_stock_pkey',0,45909);					8519549			275457					8244094		1374015

select ux_prewarm('bmsql_config_PKEY');			总块号		6等分
select ux_prewarm('bmsql_customer_idx1');		2621400		436900
select ux_prewarm('bmsql_customer_pkey');		2621400
select ux_prewarm('bmsql_district_pkey');		327675		54612
select ux_prewarm('bmsql_item_pkey');			12800		2133
select ux_prewarm('bmsql_new_order_pkey');		196605		32767
select ux_prewarm('bmsql_oorder_idx1');			327675
select ux_prewarm('bmsql_oorder_pkey');			327675
select ux_prewarm('bmsql_order_line_pkey');		5242800		873800
select ux_prewarm('bmsql_stock_pkey');			8519550		1419925
select ux_prewarm('bmsql_warehouse_pkey');		327675

1000仓，（跑30分钟）

  扩块时间    
单机单实例    15min左右
2机2实例    25min左右
3机3实例    35min左右
3机4实例    45min左右


 run/sql.common/tableCreates.sql

105（节点1）：
%Cpu(s): 34.7 us,  4.4 sy,  0.0 ni, 58.4 id,  1.5 wa,  0.0 hi,  1.1 si,  0.0 st

102：
%Cpu(s): 11.9 us, 26.8 sy,  0.0 ni, 59.4 id,  1.3 wa,  0.0 hi,  0.6 si,  0.0 st

Measured tpmC (NewOrders) = 145319.52
Measured tpmTOTAL = 323154.34
Session Start     = 2021-09-01 18:16:25
Session End       = 2021-09-01 18:26:25
Transaction Count = 3231871

uxdb=# select * from pcm_request_statistics();
 instanceid | requests | resourcerequests | readrequests | writerequests | retryrequests
| timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+---------------
+---------+----------+-------------+----------
          1 |  6561874 |          1333647 |      1805817 |       3422410 |             0
|       0 |  2180604 |     3251921 |  1129349
          2 |  5674684 |           920102 |      1868037 |       2886545 |             0
|       0 |  2275581 |     2691235 |   707868

ps -ef|grep "uxdb uxdb" | grep -v grep| wc -l

./sql.common/tableCreates.sql
./sql.common/indexCreates.sql
./sql.common/foreignKeys.sql
./sql.postgres/extraHistID.sql


共享存储rebase合并目前最优代码；
tpcc初始化1000仓报错，loadWorkers设置多并发存在死锁问题，暂不解决；

2021-09-06

select expand_fsm_block(16384);

 16395 | tb2
 16398 | tb2_pkey


fsm空闲空间查找：
heap_insert
	RelationGetBufferForTuple
		GetPageWithFreeSpace
			fsm_search
				fsm_search_avail


2切份：
	splitBlock = totalBlocks / 2 - 1;
	treesplitBlock = splitBlock / 2;
	for(nBlock = 0; nBlock < totalBlocks; nBlock ++)
	{
		if(1 == MyInstanceId && nBlock > splitBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 0);
		}
		else if (2 == MyInstanceId && nBlock > splitBlock && nBlock <= (splitBlock + treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
		else if (3 == MyInstanceId && nBlock > (splitBlock + treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
	}

	// if(1 == MyInstanceId)
	// {
	// 	UpdateFreeSpaceMap(rel, splitBlock+1, totalBlocks-1, 0);
	// }
	if(2 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock+1, splitBlock + treesplitBlock, 8152);
	}
	if(3 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock + treesplitBlock + 1, totalBlocks-1, 8152);
	}

splitBlock = （splitBlock/512 + 1）*512 - 1；




 14 select expand_fsm_block(16425);
 15 select expand_fsm_block(16427);
 16 select expand_fsm_block(16428);
 select expand_fsm_block(16430);
 select expand_fsm_block(16435)

create sequence bmsql_hist_id_seq;

ALTER SEQUENCE bmsql_hist_id_seq
CACHE 10000；

CREATE [ TEMPORARY | TEMP ] SEQUENCE name [ INCREMENT [ BY ] increment ]
    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]
    [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]
    [ OWNED BY { table.column | NONE }

alter table bmsql_history drop constraint bmsql_history_pkey;


alter table bmsql_history drop constraint h_customer_fkey;
alter table bmsql_history drop constraint "h_district_fkey";
alter table bmsql_customer drop constraint c_district_fkey;
alter table bmsql_district drop constraint bmsql_district_pkey;


2021-09-09

1、
 relfilenode |        relname
-------------+-----------------------
       16384 | bmsql_config
       16387 | bmsql_config_pkey
       16389 | bmsql_warehouse
       16392 | bmsql_district
       16395 | bmsql_customer
       16398 | ux_toast_16395
       16400 | ux_toast_16395_index
       16403 | bmsql_history
       16406 | bmsql_new_order
       16409 | bmsql_oorder
       16412 | bmsql_order_line
       16415 | bmsql_item
       16418 | bmsql_stock

       16421 | bmsql_warehouse_pkey
       16425 | bmsql_customer_pkey
       16427 | bmsql_customer_idx1
       16428 | bmsql_oorder_pkey
       16430 | bmsql_oorder_idx1
       16431 | bmsql_new_order_pkey
       16433 | bmsql_order_line_pkey
       16435 | bmsql_stock_pkey
       16437 | bmsql_item_pkey
       16495 | bmsql_hist_id_seq

修改事物锁：


10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 3128.77
10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Measured tpmTOTAL = 6932.53
10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Session Start     = 2021-09-09 09:55:52
10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Session End       = 2021-09-09 10:00:53
10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Transaction Count = 34673



4节点代码：
1432：

	totalBlocks = RelationGetNumberOfBlocks(rel);
	splitBlock = totalBlocks / 3 - 1;
	if(splitBlock > 512)
	{
		splitBlock = (splitBlock/512 + 1) * 512 - 1;
	}
	treesplitBlock = totalBlocks - splitBlock - 1;
	treesplitBlock = treesplitBlock / 3;
	if(treesplitBlock > 512)
	{
		treesplitBlock = (treesplitBlock/512 + 1) * 512;
	}

	for(nBlock = 0; nBlock < totalBlocks; nBlock ++)
	{
		if(1 == MyInstanceId && nBlock > splitBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 0);
		}
		else if (2 == MyInstanceId && nBlock > splitBlock && nBlock <= (splitBlock + treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
		else if (3 == MyInstanceId && nBlock > (splitBlock + treesplitBlock) && nBlock <= (splitBlock +  2 * treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
		else if (4 == MyInstanceId && nBlock > (splitBlock + 2 * treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
	}

	// if(1 == MyInstanceId)
	// {
	// 	UpdateFreeSpaceMap(rel, splitBlock+1, totalBlocks-1, 0);
	// }
	if(2 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock+1, splitBlock + treesplitBlock, 8152);
	}
	if(3 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock + treesplitBlock + 1, splitBlock +  2 * treesplitBlock, 8152);
	}
	if(4 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock +  2 * treesplitBlock + 1, totalBlocks-1, 8152);
	}


select 'select expand_fsm_block(' || oid || ',3,0);' from ux_class where oid>=16384;

2021-09-12
3实例：
%Cpu(s): 34.6 us,  4.1 sy,  0.0 ni, 57.5 id,  2.8 wa,  0.0 hi,  1.0 si,  0.0 st
%Cpu(s): 33.7 us,  3.6 sy,  0.0 ni, 60.0 id,  1.4 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu(s): 25.6 us,  3.2 sy,  0.0 ni, 69.6 id,  1.0 wa,  0.0 hi,  0.6 si,  0.0 st

Term-00, Measured tpmC (NewOrders) = 160037.46
Term-00, Measured tpmTOTAL = 355540.79
Term-00, Session Start     = 2021-09-12 13:55:32
Term-00, Session End       = 2021-09-12 14:00:32
Term-00, Transaction Count = 1777940

instanceid | requests | resourcerequests | readrequests | writerequests | retryreques
ts | timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+------------
---+---------+----------+-------------+----------
          1 |  2534558 |           927789 |       621460 |        985309 |
 0 |       0 |   200771 |     1448349 |   885438
          2 |  1874238 |           644437 |       535416 |        694385 |
 0 |       0 |   205330 |     1058468 |   610440
          3 |  1616932 |           554403 |       455342 |        607187 |
 0 |       0 |   189698 |      906856 |   520378


select ux_freespace(16389, 64525);
select ux_freespace(16389, 96781);


%Cpu(s): 47.5 us,  4.3 sy,  0.0 ni, 44.5 id,  2.5 wa,  0.0 hi,  1.2 si,  0.0 st
%Cpu(s): 29.9 us,  3.8 sy,  0.0 ni, 64.0 id,  1.2 wa,  0.0 hi,  1.1 si,  0.0 st
%Cpu(s): 19.1 us,  2.3 sy,  0.0 ni, 76.7 id,  1.3 wa,  0.0 hi,  0.6 si,  0.0

Term-00, Measured tpmC (NewOrders) = 173692.5
Term-00, Measured tpmTOTAL = 385921.88
Term-00, Session Start     = 2021-09-12 16:27:33
Term-00, Session End       = 2021-09-12 16:32:33
Term-00, Transaction Count = 1929885

 instanceid | requests | resourcerequests | readrequests | writerequests | retryreques
ts | timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+------------
---+---------+----------+-------------+----------
          1 |  2968254 |          1064232 |       764180 |       1139842 |
 0 |       0 |   250344 |     1695279 |  1022631
          2 |  1812045 |           617215 |       521801 |        673029 |
 0 |       0 |   220517 |     1011693 |   579835
          3 |  1712883 |           590232 |       472366 |        650285 |
 0 |       0 |   220011 |      943783 |   549089

2实例：
%Cpu(s): 58.9 us,  4.4 sy,  0.0 ni, 33.0 id,  2.4 wa,  0.0 hi,  1.2 si,  0.0 st
%Cpu(s): 39.2 us,  3.6 sy,  0.0 ni, 54.9 id,  1.1 wa,  0.0 hi,  1.3 si,  0.0 st

17:03:26,759 [Thread-59] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 115596.89
17:03:26,760 [Thread-59] INFO   jTPCC : Term-00, Measured tpmTOTAL = 256940.08
17:03:26,760 [Thread-59] INFO   jTPCC : Term-00, Session Start     = 2021-09-12 16:58:26
17:03:26,760 [Thread-59] INFO   jTPCC : Term-00, Session End       = 2021-09-12 17:03:26
17:03:26,760 [Thread-59] INFO   jTPCC : Term-00, Transaction Count = 1284845

instanceid | requests | resourcerequests | readrequests | writerequests | retryreques
ts | timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+------------
---+---------+----------+-------------+----------
          1 |  3054367 |          1147262 |       744314 |       1162791 |
 0 |       0 |   122827 |     1805878 |  1125662
          2 |  1593832 |           548302 |       465161 |        580369 |
 0 |       0 |   144476 |      923921 |   525435
(2 rows)




select ux_freespace(16389, 64513);
select ux_freespace(16389, 96770);


2021-09-13

1、查看共享盘分区
ll /dev/disk/by-id

2、登录10.10.10.11服务器配置lun组；


2021-09-14

zhongyou优化后的代码：
Datum
expand_fsm_block(UX_FUNCTION_ARGS)
{
	Oid relOid = UX_GETARG_OID(0);  /* 表的oid */
	int insNum = UX_GETARG_INT32(1); /*实例总数*/
	int blkno = UX_GETARG_INT32(2);  /* 已用掉的块号，实例1无效，其他实例是等值，通过实例1查询select ux_freespace(oid) */
	Relation rel = NULL;
	BlockNumber totalBlocks;
	BlockNumber splitBlock;
	BlockNumber nBlock;
	BlockNumber startBlock,endBlock;
	uint32		alignNum = 512;
	char		result[128] = {0};

	if (!OidIsValid(relOid))
	{
		UX_RETURN_TEXT_P(cstring_to_text("Failed"));
	}

	if (insNum <= InvalidInstanceId || insNum > MAX_INSTANCE_COUNT)
	{
		UX_RETURN_TEXT_P(cstring_to_text("Failed"));
	}

	rel = relation_open(relOid,AccessExclusiveLock);
	if(rel == NULL)
	{
		UX_RETURN_TEXT_P(cstring_to_text("relation_open Failed"));
	}

	totalBlocks = RelationGetNumberOfBlocks(rel);
	/*
	 * 由于数据是在实例1上初始化的，所以分块的时候，要把实例1上用掉的数据块除外
	 * 其他实例，则通过参数传进来，入参的值是在实例1上通过select ux_freespace(oid)可以得出
	 */
	if(1 == MyInstanceId)
	{
		blkno = GetPageWithFreeSpace(rel,8152);
		blkno = (blkno / alignNum + 1) * alignNum;
		sprintf(result,"select expand_fsm_block(%d,%d,%d);",relOid,insNum,blkno);
	}
	else
	{
		sprintf(result,"expand success");
	}

	/*需要分配的总块*/
	 if(blkno > 0)
	 	totalBlocks = totalBlocks - blkno;
	/*开始计算分块*/
	splitBlock = totalBlocks / (insNum + 1);
	//tmpBlock = totalBlocks % (insNum + 1);
	/*
	 * 如果不够512，则采用均分原则
	 * 如果够512，则以512对齐分配，分完后，还有剩余，则分给实例1
	 */
	if(splitBlock >= alignNum)
	{
		/* 512对齐 */
		splitBlock = (splitBlock / alignNum) * alignNum;
	}
	/*开始块号*/
	startBlock = (MyInstanceId) * splitBlock + blkno;
	endBlock = (MyInstanceId+1) * splitBlock + blkno;

	if(1 == MyInstanceId)
	{
		nBlock = endBlock;
		/*
		 * 把剩余的留给实例1
		 * 如果剩余的块号大于512，是不是还需要再进行一次分配呢
		 *    如： 剩下1000，给1分 512 ，给2 分 488，(这种情况暂时没考虑)
		 */
		endBlock = (insNum + 1) * splitBlock + blkno - 1;
		/*清除不在1实例的块*/
		while(nBlock < endBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 0);
			nBlock ++;
		}
		/*UpdateFreeSpaceMap(rel, startBlock, nBlock, 0);*/
	}
	else
	{
		nBlock = startBlock;
		/*标记自己实例的块*/
		while(nBlock < endBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
			nBlock ++;
		}
		UpdateFreeSpaceMap(rel, startBlock, nBlock, 8152);
	}

	relation_close(rel,AccessExclusiveLock);
	UX_RETURN_TEXT_P(cstring_to_text(result));
}



longzhongyou：

Datum
expand_fsm_block(UX_FUNCTION_ARGS)
{
	Oid relOid = UX_GETARG_OID(0);  /* 表的oid */
	int insNum = UX_GETARG_INT32(1); /*实例总数*/
	int blkno = UX_GETARG_INT32(2);  /* 已用掉的块号，实例1无效，其他实例是等值，通过实例1查询select ux_freespace(oid) */
	Relation rel = NULL;
	BlockNumber totalBlocks;
	BlockNumber perBlockAlin;
	BlockNumber nBlock;
	BlockNumber startBlock,endBlock;
	uint32		alignNum = 512;
	uint32		perInsAlin = 0;
	uint32		leftAlinBlock = 0;
	char		result[128] = {0};
	int 		i = 0;
	int			startIndex = 0,endIndex = 0;

	if (!OidIsValid(relOid))
	{
		UX_RETURN_TEXT_P(cstring_to_text("Failed"));
	}

	if (insNum <= InvalidInstanceId || insNum > MAX_INSTANCE_COUNT)
	{
		UX_RETURN_TEXT_P(cstring_to_text("Failed"));
	}

	rel = relation_open(relOid,AccessExclusiveLock);
	if(rel == NULL)
	{
		UX_RETURN_TEXT_P(cstring_to_text("relation_open Failed"));
	}

	totalBlocks = RelationGetNumberOfBlocks(rel);
	/*
	 * 由于数据是在实例1上初始化的，所以分块的时候，要把实例1上用掉的数据块除外
	 * 其他实例，则通过参数传进来，入参的值是在实例1上通过select ux_freespace(oid)可以得出
	 */
	if(1 == MyInstanceId)
	{
		blkno = GetPageWithFreeSpace(rel,8152);
		blkno = (blkno / alignNum + 1) * alignNum; /* 实例1用掉的块号以512对齐 */
		sprintf(result,"select expand_fsm_block(%d,%d,%d);",relOid,insNum,blkno);
	}
	else
	{
		sprintf(result,"expand success");
	}

	/*需要分配的总块*/
	totalBlocks = totalBlocks - blkno;

	/*开始计算分块*/

	perBlockAlin = totalBlocks / alignNum;  /*总块够多少个512 */
	perInsAlin = perBlockAlin / insNum;     /* 每个实例能分多少个512块 */
	leftAlinBlock = perBlockAlin % insNum;  /* 剩多少个512块没有被分 */

	for(i = 1; i <= insNum; i ++)
	{
		int tmpIndex = 0;
		startIndex = endIndex;
		tmpIndex = (i <= leftAlinBlock) ? perInsAlin+1 : perInsAlin;
		endIndex  +=  tmpIndex;
		if(i == MyInstanceId)
		{
			break;
		}
	}

	/*开始块号*/
	startBlock = blkno + startIndex *  alignNum;
	endBlock = blkno + endIndex *  alignNum;

	if(1 == MyInstanceId)
	{

		 nBlock = endBlock;
		/*清除不在1实例的块*/
		while(nBlock < totalBlocks+blkno)
		{
			RecordPageWithFreeSpace(rel, nBlock, 0);
			nBlock ++;
		}
		/*UpdateFreeSpaceMap(rel, startBlock, nBlock, 0);*/
	}
	else
	{
		nBlock = startBlock;
		/*标记自己实例的块*/
		while(nBlock < endBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
			nBlock ++;
		}
		UpdateFreeSpaceMap(rel, startBlock, nBlock, 8152);
	}

	relation_close(rel,AccessExclusiveLock);
	UX_RETURN_TEXT_P(cstring_to_text(result));
}


955:
if (!found && (forkNum != FSM_FORKNUM || res_tag.rnode.relNode >= 16421))
1230:
	if (!isLocalBuf && uxdb_rac && (forkNum != FSM_FORKNUM || res_tag.rnode.relNode >= 16421))


select expand_fsm_block(16389,3,15);
select expand_fsm_block(16392,3,156);
select expand_fsm_block(16395,3,2290763);
select expand_fsm_block(16403,3,324159);
select expand_fsm_block(16406,3,48649);
select expand_fsm_block(16409,3,243091);
select expand_fsm_block(16412,3,3703595);
select expand_fsm_block(16415,3,1302);
select expand_fsm_block(16418,3,4347495);

int avedbnum = numTerminals / dbNums;
conn = DriverManager.getConnection(dbfarms. get(i/avedbnum), dbProps);


uxdb流程规范整理：


2021-09-16

1、
V5代码
117154之后

conn = DriverManager.getConnection(dbfarms. get(i/avedbnum), dbProps);

i：客户端
wareHouseIds.get(i % wareHouseIds.size())  ：仓数
dbfarms.get(terminalWarehouseID % dbNums)  ：jdbc:uxdb://192.72.0.77:5432/uxdb


un.request_msg.masterid;


rebase feature/v2.1.0.6.03r/##118592_v2这个分支代码到目前最新共享存储分支；
修改for update为for share，tpcc测试正常；
分析tpcc warehouseid随机分配问题；


2021-09-16

1、对外项目
http://cd.uxsino.com:19503/projects/dev_uxdb/wiki/%E5%AF%B9%E5%A4%96%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B

对于需要立项研发的项目，需要评估项目工期，确定参与人员；
在readmine建立任务单；


gcs.c:932
	epoch = request_msg->un.pcm_request.epoch;
	managerId = request_msg->header.dest_uuid;

	:2264
	managerId = reply_msg->un.pcm_authorized_reply.masterid;
	:4595
	auth_reply.un.pcm_authorized_reply.masterid = master_instance;
	:2528
	managerId = request_msg->un.pcm_release_forward_request.masterid;

2021-09-18



tpcc加载后台执行命令：
nohup sh runDatabaseBuild.sh props.pg> results.log&

tpcc执行命令：
nohup sh runBenchmark.sh props.pg> results.log&


修改扩展块时区分普通块和索引块报错


共享存储最新分支：
feature/v2.1.0.6.03r/#118614



###Kylin Linux Advanced Server 10 - os repo###

[ks10-adv-cdrom]
name = Kylin Linux Advanced Server 10 - cdrom
baseurl = file:///run/media/root/KYLIN10-SVR
gpgcheck = 0
enabled = 1




./storcli64  /c0  add  vd  r0 drives=252:0,252:1,252:4,252:5
共享存储操作：
1、加载完数据后，执行以下操作：
ALTER SEQUENCE bmsql_hist_id_seq
CACHE 10000;
alter table bmsql_history drop constraint bmsql_history_pkey;



%Cpu(s): 13.3 us,  2.4 sy,  0.0 ni, 83.1 id,  0.2 wa,  0.0 hi,  1.0 si,  0.0 st


段错误：

ulimit -a查看
ulimit -c unlimited设置生成不限制大小
echo "/home/uxdb/uxdbinstall/dbsql/bin/core-%e-%p-%t" > /proc/sys/kernel/core_pattern
echo "1" > /proc/sys/kernel/core_uses_pid
echo "1" > /proc/sys/fs/suid_dumpable （出于安全考虑，suid程序以及调用setuid()的程序缺省情况下不产生core dump）
使文件生效：source /etc/profile



/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.0-directio/src/include/ux_config_manual.h
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.0-directio/src/backend/storage/file/odirect.c




numactl --interleave=all  ./ux_ctl -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=1 -p 5432" start

c48
113：%Cpu(s):  9.7 us,  1.6 sy,  0.0 ni, 87.7 id,  0.2 wa,  0.0 hi,  0.8 si,  0.0 st
112：%Cpu(s):  0.8 us,  0.4 sy,  0.0 ni, 98.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st

11:37:45,098 [Thread-26] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 42788.63                11:37:45,098 [Thread-26] INFO   jTPCC : Term-00, Measured tpmTOTAL = 94917.98                        11:37:45,098 [Thread-26] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 11:27:45             11:37:45,099 [Thread-26] INFO   jTPCC : Term-00, Session End       = 2021-10-08 11:37:45             11:37:45,099 [Thread-26] INFO   jTPCC : Term-00, Transaction Count = 949269


113:%Cpu(s):  8.7 us,  1.6 sy,  0.0 ni, 88.8 id,  0.2 wa,  0.0 hi,  0.7 si,  0.0 st
112:%Cpu(s):  0.5 us,  0.2 sy,  0.0 ni, 97.7 id,  1.6 wa,  0.0 hi,  0.0 si,  0.0 st

13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 34848.45                13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Measured tpmTOTAL = 77576.71                        13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 13:06:21             13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Session End       = 2021-10-08 13:16:21             13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Transaction Count = 775845

修改swappiness：
sysctl -w vm.swappiness=60
sysctl -a|grep vm.swappiness
cat /proc/sys/vm/swappiness

shared_buffer = 32GB:
c48
%Cpu(s):  8.6 us,  2.0 sy,  0.0 ni, 86.3 id,  2.1 wa,  0.0 hi,  1.0 si,  0.0 st
%Cpu(s):  1.2 us,  0.4 sy,  0.0 ni, 97.1 id,  1.2 wa,  0.0 hi,  0.1 si,  0.0 st

16:41:12,629 [Thread-45] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 52919.4                 16:41:12,629 [Thread-45] INFO   jTPCC : Term-00, Measured tpmTOTAL = 117671.99
16:41:12,630 [Thread-45] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 16:36:12
16:41:12,630 [Thread-45] INFO   jTPCC : Term-00, Session End       = 2021-10-08 16:41:12
16:41:12,630 [Thread-45] INFO   jTPCC : Term-00, Transaction Count = 588459

c64
16:48:20,966 [Thread-35] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 68798.84                16:48:20,967 [Thread-35] INFO   jTPCC : Term-00, Measured tpmTOTAL = 152901.81
16:48:20,967 [Thread-35] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 16:43:20
16:48:20,967 [Thread-35] INFO   jTPCC : Term-00, Session End       = 2021-10-08 16:48:20
16:48:20,967 [Thread-35] INFO   jTPCC : Term-00, Transaction Count = 764661

c32

17:00:41,742 [Thread-29] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 92449.0                 17:00:41,742 [Thread-29] INFO   jTPCC : Term-00, Measured tpmTOTAL = 205011.71
17:00:41,742 [Thread-29] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 16:55:41
17:00:41,742 [Thread-29] INFO   jTPCC : Term-00, Session End       = 2021-10-08 17:00:41
17:00:41,743 [Thread-29] INFO   jTPCC : Term-00, Transaction Count = 1025266

c24
17:06:55,964 [Thread-17] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 69525.67                17:06:55,965 [Thread-17] INFO   jTPCC : Term-00, Measured tpmTOTAL = 154732.54
17:06:55,965 [Thread-17] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 17:01:55
17:06:55,965 [Thread-17] INFO   jTPCC : Term-00, Session End       = 2021-10-08 17:06:55
17:06:55,965 [Thread-17] INFO   jTPCC : Term-00, Transaction Count = 773899


shared_buffer = 64GB:
18:23:57,311 [Thread-31] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 73377.0                 18:23:57,312 [Thread-31] INFO   jTPCC : Term-00, Measured tpmTOTAL = 163038.03                       18:23:57,312 [Thread-31] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 18:13:57             18:23:57,312 [Thread-31] INFO   jTPCC : Term-00, Session End       = 2021-10-08 18:23:57             18:23:57,312 [Thread-31] INFO   jTPCC : Term-00, Transaction Count = 1630537

c50（第一次10min）：
09:46:33,710 [Thread-32] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 110790.16
09:46:33,710 [Thread-32] INFO   jTPCC : Term-00, Measured tpmTOTAL = 246314.23
09:46:33,710 [Thread-32] INFO   jTPCC : Term-00, Session Start     = 2021-10-09 09:36:33
09:46:33,710 [Thread-32] INFO   jTPCC : Term-00, Session End       = 2021-10-09 09:46:33
09:46:33,711 [Thread-32] INFO   jTPCC : Term-00, Transaction Count = 2463400

第二次（5min）
c54
 09:52:56,024 [Thread-13] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 137230.01               09:52:56,025 [Thread-13] INFO   jTPCC : Term-00, Measured tpmTOTAL = 304868.55
09:52:56,025 [Thread-13] INFO   jTPCC : Term-00, Session Start     = 2021-10-09 09:47:55
09:52:56,025 [Thread-13] INFO   jTPCC : Term-00, Session End       = 2021-10-09 09:52:56
09:52:56,025 [Thread-13] INFO   jTPCC : Term-00, Transaction Count = 1524606


2021-10-11
绑定cpu测试结果：
c128：
10:27:52,974 [Thread-116] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 6421.06
10:27:52,974 [Thread-116] INFO   jTPCC : Term-00, Measured tpmTOTAL = 14326.84
10:27:52,974 [Thread-116] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:16:43
10:27:52,975 [Thread-116] INFO   jTPCC : Term-00, Session End       = 2021-10-11 10:27:52
10:27:52,975 [Thread-116] INFO   jTPCC : Term-00, Transaction Count = 159746

c72

10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 17892.85
10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Measured tpmTOTAL = 39764.57
10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:29:29
10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Session End       = 2021-10-11 10:39:30
10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Transaction Count = 398057

c48
10:51:03,923 [Thread-33] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 48245.75
10:51:03,923 [Thread-33] INFO   jTPCC : Term-00, Measured tpmTOTAL = 107182.84
10:51:03,923 [Thread-33] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:41:03
10:51:03,923 [Thread-33] INFO   jTPCC : Term-00, Session End       = 2021-10-11 10:51:03
10:51:03,924 [Thread-33] INFO   jTPCC : Term-00, Transaction Count = 1071915

c32
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 65333.1
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Measured tpmTOTAL = 145222.46
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:51:31
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Session End       = 2021-10-11 10:56:31
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Transaction Count = 726288

c56：
11:03:07,920 [Thread-52] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 94963.5
11:03:07,921 [Thread-52] INFO   jTPCC : Term-00, Measured tpmTOTAL = 211123.95
11:03:07,921 [Thread-52] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:58:07
11:03:07,921 [Thread-52] INFO   jTPCC : Term-00, Session End       = 2021-10-11 11:03:07
11:03:07,921 [Thread-52] INFO   jTPCC : Term-00, Transaction Count = 1055851

c60：
11:08:52,956 [Thread-12] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 88086.51
11:08:52,957 [Thread-12] INFO   jTPCC : Term-00, Measured tpmTOTAL = 195708.01
11:08:52,957 [Thread-12] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 11:03:52
11:08:52,957 [Thread-12] INFO   jTPCC : Term-00, Session End       = 2021-10-11 11:08:52
11:08:52,957 [Thread-12] INFO   jTPCC : Term-00, Transaction Count = 978800



绑定cpu

c72（2机4实例）：
Term-00, Measured tpmC (NewOrders) = 132680.72
Term-00, Measured tpmTOTAL = 294719.26
Term-00, Session Start     = 2021-10-11 16:00:40
Term-00, Session End       = 2021-10-11 16:10:40
Term-00, Transaction Count = 2947673




预热函数：
create extension ux_prewarm;
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_customer');
select ux_prewarm('bmsql_district');
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_history');
select ux_prewarm('bmsql_item');
select ux_prewarm('bmsql_new_order');
select ux_prewarm('bmsql_oorder');
select ux_prewarm('bmsql_order_line');
select ux_prewarm('bmsql_stock');
select ux_prewarm('bmsql_warehouse');
select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1');
select ux_prewarm('bmsql_customer_pkey');
select ux_prewarm('bmsql_district_pkey');
select ux_prewarm('bmsql_item_pkey');
select ux_prewarm('bmsql_new_order_pkey');
select ux_prewarm('bmsql_oorder_idx1');
select ux_prewarm('bmsql_oorder_pkey');
select ux_prewarm('bmsql_order_line_pkey');
select ux_prewarm('bmsql_stock_pkey');
select ux_prewarm('bmsql_warehouse_pkey');
select ux_prewarm('NDX_OORDER_2');
checkpoint;


预热后：(目测76并发最高)
c72
 09:29:20,484 [Thread-35] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 129129.39
 09:29:20,485 [Thread-35] INFO   jTPCC : Term-00, Measured tpmTOTAL = 286882.55
 09:29:20,485 [Thread-35] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:19:20
 09:29:20,485 [Thread-35] INFO   jTPCC : Term-00, Session End       = 2021-10-12 09:29:20
09:29:20,485 [Thread-35] INFO   jTPCC : Term-00, Transaction Count = 2869078

c56
09:40:10,875 [Thread-50] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 143355.5
09:40:10,876 [Thread-50] INFO   jTPCC : Term-00, Measured tpmTOTAL = 318688.2
09:40:10,876 [Thread-50] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:30:10
09:40:10,876 [Thread-50] INFO   jTPCC : Term-00, Session End       = 2021-10-12 09:40:10
09:40:10,876 [Thread-50] INFO   jTPCC : Term-00, Transaction Count = 3187290

c52(5min)
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 121848.56
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Measured tpmTOTAL = 270618.88
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:44:22
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Session End       = 2021-10-12 09:49:23
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Transaction Count = 1353558

c60：
09:55:43,447 [Thread-15] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 132443.69
09:55:43,447 [Thread-15] INFO   jTPCC : Term-00, Measured tpmTOTAL = 294487.85
09:55:43,448 [Thread-15] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:50:43
09:55:43,448 [Thread-15] INFO   jTPCC : Term-00, Session End       = 2021-10-12 09:55:43
09:55:43,448 [Thread-15] INFO   jTPCC : Term-00, Transaction Count = 1473042

c64
10:04:06,033 [Thread-12] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 132314.47
10:04:06,034 [Thread-12] INFO   jTPCC : Term-00, Measured tpmTOTAL = 294334.1
10:04:06,034 [Thread-12] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:59:05
10:04:06,034 [Thread-12] INFO   jTPCC : Term-00, Session End       = 2021-10-12 10:04:06
10:04:06,035 [Thread-12] INFO   jTPCC : Term-00, Transaction Count = 1472425

c68
10:11:04,414 [Thread-47] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 123513.75
10:11:04,415 [Thread-47] INFO   jTPCC : Term-00, Measured tpmTOTAL = 274236.62
10:11:04,415 [Thread-47] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 10:06:04
10:11:04,415 [Thread-47] INFO   jTPCC : Term-00, Session End       = 2021-10-12 10:11:04
10:11:04,415 [Thread-47] INFO   jTPCC : Term-00, Transaction Count = 1371982

c80
10:19:47,851 [Thread-27] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 118316.41
10:19:47,851 [Thread-27] INFO   jTPCC : Term-00, Measured tpmTOTAL = 263138.51
10:19:47,851 [Thread-27] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 10:14:47
10:19:47,851 [Thread-27] INFO   jTPCC : Term-00, Session End       = 2021-10-12 10:19:47
10:19:47,852 [Thread-27] INFO   jTPCC : Term-00, Transaction Count = 1317266



删除外键：

13:09:41,568 [Thread-37] INFO   jTPCC : Term-00,
13:09:41,568 [Thread-37] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 5434.9
13:09:41,569 [Thread-37] INFO   jTPCC : Term-00, Measured tpmTOTAL = 12102.05
13:09:41,569 [Thread-37] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 12:59:41
13:09:41,569 [Thread-37] INFO   jTPCC : Term-00, Session End       = 2021-10-12 13:09:41
13:09:41,569 [Thread-37] INFO   jTPCC : Term-00, Transaction Count = 121124


删除外键，绑定cpu（4节点4实例）
terminals=56
第一次10min：
Measured tpmC (NewOrders) = 7861.83
Measured tpmTOTAL = 17477.04
Session Start     = 2021-10-12 15:09:52
Session End       = 2021-10-12 15:19:52
Transaction Count = 174851

第二次10min：
Measured tpmC (NewOrders) = 28372.13
Measured tpmTOTAL = 63061.02
Session Start     = 2021-10-12 15:21:01
Session End       = 2021-10-12 15:31:01
Transaction Count = 630933


第三次10min：
113：%Cpu(s):  3.3 us,  1.0 sy,  0.0 ni, 86.6 id,  8.5 wa,  0.0 hi,  0.5 si,  0.0 st
112：%Cpu(s):  1.8 us,  0.8 sy,  0.0 ni, 96.6 id,  0.9 wa,  0.0 hi,  0.0 si,  0.0 st
111：%Cpu(s):  2.2 us,  0.7 sy,  0.0 ni, 94.7 id,  2.4 wa,  0.0 hi,  0.1 si,  0.0 st
110：%Cpu(s):  1.6 us,  0.5 sy,  0.0 ni, 93.6 id,  4.2 wa,  0.0 hi,  0.0 si,  0.0 st

Term-00, Measured tpmC (NewOrders) = 53409.85
Term-00, Measured tpmTOTAL = 118643.13
Term-00, Session Start     = 2021-10-12 15:31:15
Term-00, Session End       = 2021-10-12 15:41:15
Term-00, Transaction Count = 1186638

第四次10min：

113：%Cpu(s):  3.9 us,  1.2 sy,  0.0 ni, 86.5 id,  7.9 wa,  0.0 hi,  0.5 si,  0.0 st
112：%Cpu(s):  2.6 us,  0.6 sy,  0.0 ni, 95.1 id,  1.6 wa,  0.0 hi,  0.0 si,  0.0 st
111：%Cpu(s):  1.8 us,  0.5 sy,  0.0 ni, 95.6 id,  2.1 wa,  0.0 hi,  0.1 si,  0.0 st
110：%Cpu(s):  2.3 us,  0.6 sy,  0.0 ni, 94.1 id,  2.9 wa,  0.0 hi,  0.1 si,  0.0 st

Term-00, Measured tpmC (NewOrders) = 72902.37
Term-00, Measured tpmTOTAL = 162225.41
Term-00, Session Start     = 2021-10-12 15:44:23
Term-00, Session End       = 2021-10-12 15:54:24
Term-00, Transaction Count = 1622583


第五次10min：
实例1-实例4cpu：
%Cpu(s):  6.5 us,  1.6 sy,  0.0 ni, 85.4 id,  5.6 wa,  0.0 hi,  0.8 si,  0.0 st
%Cpu(s):  4.2 us,  0.7 sy,  0.0 ni, 92.7 id,  2.3 wa,  0.0 hi,  0.1 si,  0.0 st
%Cpu(s):  3.5 us,  0.7 sy,  0.0 ni, 94.1 id,  1.7 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu(s):  3.9 us,  0.7 sy,  0.0 ni, 92.3 id,  2.9 wa,  0.0 hi,  0.1 si,  0.0 st

Term-00, Measured tpmC (NewOrders) = 80680.11
Term-00, Measured tpmTOTAL = 179377.06
Term-00, Session Start     = 2021-10-12 15:54:50
Term-00, Session End       = 2021-10-12 16:04:50
Term-00, Transaction Count = 1794245


第六次10min：
%Cpu(s):  7.9 us,  1.6 sy,  0.0 ni, 85.6 id,  4.3 wa,  0.0 hi,  0.6 si,  0.0 st
%Cpu(s):  4.5 us,  0.7 sy,  0.0 ni, 91.8 id,  2.8 wa,  0.0 hi,  0.1 si,  0.0 st
%Cpu(s):  3.8 us,  0.7 sy,  0.0 ni, 93.1 id,  2.3 wa,  0.0 hi,  0.1 si,  0.0 st
%Cpu(s):  4.3 us,  0.7 sy,  0.0 ni, 92.4 id,  2.6 wa,  0.0 hi,  0.1 si,  0.0 st

16:15:59,619 [Thread-28] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 86034.63
16:15:59,620 [Thread-28] INFO   jTPCC : Term-00, Measured tpmTOTAL = 191148.37
16:15:59,620 [Thread-28] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 16:05:59
16:15:59,620 [Thread-28] INFO   jTPCC : Term-00, Session End       = 2021-10-12 16:15:59
16:15:59,621 [Thread-28] INFO   jTPCC : Term-00, Transaction Count = 1912053







dd命令测试磁盘读写速度：

dd if=/dev/zero of=/mnt/sd10/test bs=1M count=8192 oflag=direct


2021-10-14

benchmark：
时间9:36-10:26		//50min
加载31仓-143仓		//112仓

134/h

表：							加载						  执行						600min增加			
bmsql_customer					| 17GB						  | 24 GB   				| 7GB
bmsql_district					| 1248kb					  | 1525 MB             	| 1524MB
bmsql_history					| 2532MB                      | 3060 MB             	| 528MB
bmsql_item						| 10MB                        | 10 MB               	| 0MB
bmsql_new_order					| 380MB                       | 644 MB              	| 264MB
bmsql_oorder					| 1899MB                      | 2624 MB             	| 725MB
bmsql_order_line				| 28GB                        | 40 GB               	| 12GB
bmsql_stock						| 33GB                        | 54 GB               	| 21GB
bmsql_warehouse					| 120kb                       | 687 MB              	| 687MB

索引：							加载					  	  执行						600min增加
bmsql_customer_pkey	            | 902.47MB				  	  | 960.83MB            	| 58.36MB
bmsql_district_pkey	            | 256KB                       | 272KB               	| 16KB
bmsql_history_pkey	            | 644.4375MB                  | 772.79MB            	| 128.36MB
bmsql_item_pkey		            | 2224KB                      | 2224MB              	| 0MB
bmsql_new_order_pkey	        | 270.76MB                    | 629.33MB            	| 358.57MB
bmsql_oorder_pkey	            | 902.5MB                     | 1276.4MB            	| 373.9
bmsql_order_line_pkey           | 8.812GB                     | 12.65GB             	| 3.808GB
bmsql_stock_pkey		        | 2148MB                      | 2285.85MB           	| 137.85MB
bmsql_warehouse_pkey	        | 56KB                        | 56KB                	| 0





索引：
之前大小
select ux_relation_size('bmsql_customer_pkey');
 ux_relation_size
------------------
        946315264（902.47MB）
select ux_relation_size('bmsql_district_pkey');
 ux_relation_size
------------------
           262144（256KB）
select ux_relation_size('bmsql_history_pkey');
 ux_relation_size
------------------
        675741696（644.4375MB）
select ux_relation_size('bmsql_item_pkey');
 ux_relation_size
------------------
          2277376（2224KB）
select ux_relation_size('bmsql_new_order_pkey');
 ux_relation_size
------------------
        283910144（270.76MB）
select ux_relation_size('bmsql_oorder_pkey');
 ux_relation_size
------------------
        946315264（902.5MB）
select ux_relation_size('bmsql_order_line_pkey');
 ux_relation_size
------------------
       9462095872（8.812GB）
select ux_relation_size('bmsql_stock_pkey');
 ux_relation_size
------------------
       2252357632（2148MB）
select ux_relation_size('bmsql_warehouse_pkey');
 ux_relation_size
------------------
            57344（56KB）
执行后大小：
select ux_relation_size('bmsql_customer_pkey');
 ux_relation_size
------------------
       1007501312（960.83MB）
uxdb=# select ux_relation_size('bmsql_district_pkey');
 ux_relation_size
------------------
           278528（272KB）
uxdb=# select ux_relation_size('bmsql_history_pkey');
 ux_relation_size
------------------
        810328064（772.79MB）
uxdb=# select ux_relation_size('bmsql_item_pkey');
 ux_relation_size
------------------
          2277376（2224MB）
uxdb=# select ux_relation_size('bmsql_new_order_pkey');
 ux_relation_size
------------------
        659898368（629.33MB）
uxdb=# select ux_relation_size('bmsql_oorder_pkey');
 ux_relation_size
------------------
       1338392576（1276.4MB）
uxdb=# select ux_relation_size('bmsql_order_line_pkey');
 ux_relation_size
------------------
      13581352960（12.65GB）
uxdb=# select ux_relation_size('bmsql_stock_pkey');
 ux_relation_size
------------------
       2396889088（2285.85MB）
uxdb=# select ux_relation_size('bmsql_warehouse_pkey');
 ux_relation_size
------------------
            57344（56KB）


100仓tpcc数据：
ip：192.30.0.110

本地：
directio：
cpu：%Cpu(s): 34.3 us,  3.5 sy,  0.0 ni, 60.1 id,  0.8 wa,  0.0 hi,  1.4 si,  0.0

Term-00, Measured tpmC (NewOrders) = 62107.64          
Term-00, Measured tpmTOTAL = 138217.91                 
Term-00, Session Start     = 2021-10-16 19:37:27       
Term-00, Session End       = 2021-10-16 19:47:27       
Term-00, Transaction Count = 1382344

dev标准版：
cpu：%Cpu(s): 34.3 us,  3.0 sy,  0.0 ni, 61.4 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0
Measured tpmC (NewOrders) = 61902.55          
Measured tpmTOTAL = 137745.6                  
Session Start     = 2021-10-16 20:01:56       
Session End       = 2021-10-16 20:11:56       
Transaction Count = 1377563

107共享盘（模式异步）：
directio：
cpu：%Cpu(s): 12.6 us,  2.7 sy,  0.0 ni, 82.9 id,  1.2 wa,  0.0 hi,  0.6 si,  0.0 st
Term-00, Measured tpmC (NewOrders) = 37984.01                                                                            
Term-00, Measured tpmTOTAL = 84301.27    
Term-00, Session Start     = 2021-10-16 20:47:49                                                                         
Term-00, Session End       = 2021-10-16 20:57:49
Term-00, Transaction Count = 843200

dev标准版：
第一次测试
cpu：%Cpu(s): 34.5 us,  5.6 sy,  0.0 ni, 57.6 id,  0.1 wa,  0.0 hi,  2.3 si,  0.0 st
Term-00, Measured tpmC (NewOrders) =    22389.61
Term-00, Measured tpmTOTAL = 49863.01   
Term-00, Session Start    = 2021-10-16 20:28:40                                                                     
Term-00, Session End       = 2021-10-16 20:38:40
Term-00, Transaction Count = 498738

dev第二次测试
CPU：%Cpu(s): 33.1 us,  5.0 sy,  0.0 ni, 59.9 id,  0.0 wa,  0.0 hi,  1.9 si,  0.0 st
Term-00, Measured tpmC (NewOrders) = 32453.51                                                                           
Term-00, Measured tpmTOTAL = 72075.9    
Term-00, Session Start     = 2021-10-16 21:02:26                                                                        
Term-00, Session End       = 2021-10-16 21:12:26
Term-00, Transaction Count = 720871



pg多并发执行：

uxsql -p 5433 -c “update t1 set info = ‘PG中的隔离级别遵守了sql标准567’;” > results.txt&
uxsql -c “update t1 set info = ‘PG中的隔离级别遵守了sql标准567’;” > 1.txt 2>&1 &


2021-10-18

pg并行查询相关配置参数
https://blog.csdn.net/louxia_xiaohei/article/details/100112557


date;/home/uxdb/uxdbinstall/dbsql/bin/uxsql -p 5432 -c "select ux_prewarm('bmsql_order_line');";date
Mon Oct 18 16:17:40 CST 2021
 ux_prewarm
------------
    8519550
(1 row)

Mon Oct 18 16:33:06 CST 2021

修改max_worker_processes=8
42649 uxdb      20   0 82.918g 0.014t 0.014t S  57.1  5.7   1:57.28 uxdb: uxdb uxdb+
Mon Oct 18 16:46:06 CST 2021
 ux_prewarm
------------
    8519550
(1 row)

Mon Oct 18 17:01:45 CST 2021




造数步骤
一、创建表 ./runSQL.sh props.ux sqlTableCreates
二、灌数据./runLoader.sh props.ux numWarehouses 100
三、创建索引、主键等相关 ./runSQL.sh props.ux sqlIndexCreates
四、创建序列等相关./runSQL.sh props.ux   sqlExtraCreates.pg

./runSQL.sh props.pg sqlTableCreates
./runLoader.sh props.pg numWarehouses 100

./runSQL.sh props.pg sqlIndexCreates
./runSQL.sh props.pg sqlExtraCreates.pg


./runBenchmark.sh props.pg


原生benchmark链接：
 conn=jdbc:uxdb://192.30.0.102:5432/uxdb?enableEnhance=false&initInstanceSize=1


参数：conn=jdbc:uxdb://192.30.0.102:5432/uxdb?enableEnhance=false&initInstanceSize=2&enableHA=false
					tpmTOTAL
1min				60519.91
5min				23072.07
9min				17160.99
10min				16283.08

conn=jdbc:uxdb://192.30.0.102:5432/uxdb?enableEnhance=false&initInstanceSize=1&enableHA=false

1仓，jdbc修改后：
						tpmTOTAL
1min					44731.72
2min					32929.45
3min					28874.02
5min					22693.49
8min					17958.88	
10min					16074.84

原生：
1min					53672.75
2min					45522.48
3min					38651.16
5min					31333.34
8min					25678.51	
10min					22740.15

100仓tpcc数据：

原生数据：
						tpmTOTAL
1min					369097.47
2min					397897.18
3min					406092.47
5min					407470.19
8min					400588.91	
10min					394040.07
tpmC (NewOrders) = 177447.04

启动haproxy后数据：
						tpmTOTAL
1min					369097.47
2min					397897.18
3min					406092.47
5min					407470.19
8min					400588.91	
10min					394040.07
tpmC (NewOrders) = 177447.04


最新jar包
						tpmTOTAL
1min					219326.77
2min					227187.80
3min					231040.16
5min					233341.84
8min					233554.90	
10min					233137.91
tpmC (NewOrders) = 104928.5





postgresql tpcc测试数据：

原生jar包
						tpmTOTAL
1min					980164.74
2min					981555.44
3min					969828.61
5min					940495.23
8min					899066.54	
10min					872706.7
tpmC (NewOrders) = 392633.01

最新jar包
						tpmTOTAL
1min					1130119.48
2min					1124095.63
3min					1104315.95
5min					1056927.76
8min					985092.86	
10min					952889.23
tpmC (NewOrders) = 428592.11



		


pg最优参数设置

/mnt/sd9/racdata/instances/1/uxsinodb.conf
未注释
max_connections = 600
shared_buffers = 20GB
listen_addresses = '*'
log_timezone = 'PRC'

已注释：
huge_pages = off
work_mem = 1GB
maintenance_work_mem = 2GB
dynamic_shared_memory_type = posix
bgwriter_delay = 20ms
bgwriter_lru_maxpages = 1000
bgwriter_lru_multiplier = 10.0
effective_io_concurrency = 2
wal_buffers = 1GB
checkpoint_timeout = 1d
max_wal_size = 100GB
checkpoint_completion_target = 0.8
effective_cache_size = 128GB
update_process_title = off
track_activities = off
log_statement = 'none'
max_wal_senders=0
logging_collector=off
krb_server_keyfile=’’


"/mnt/sd9/racdata/super_rac.conf"
未注释
datestyle = 'iso, mdy'
已注释：
wal_level = minimal
fsync = off
synchronous_commit = off
heartbeat_try_times = 60
rac_debuglog_mask=0
global_deadlock_check_period_seconds=120
lc_time = 'en_US.UTF-8'
lc_messages = 'en_US.UTF-8'
lc_monetary = 'en_US.UTF-8'
lc_numeric = 'en_US.UTF-8'
timezone = 'PRC'
wal_writer_delay = 20ms
full_page_writes = off
wal_sync_method = open_sync
commit_siblings = 16
autovacuum = off




feature/v2.1.0.6.03r/#109187


旧包：
					tpmc
1min				264814.58				
3min				260305.02
4min				254647.93	
5min				248893.94				
10min				232660.02

新包：
					tpmc
1min				238244.80				
3min				234256.98
4min				229846.17	
5min				226897.64				
10min				211063.57

旧包：
					tpm
1min				272814.26				
3min				283870.14	
5min				277479.28				
10min				264461.37

新包：
					tpm
1min				246881.26			
3min				238456.76	
5min				230389.40				
10min				218670.67




新编译：
					tpm
5min				269119.10				
10min				257554.69

旧包：
					tpm
5min				267890.30			
10min				257936.59

新包：
					tpm
5min				270530.46			
10min				257158.44

27号第一次包：
tpmTOTAL = 244424.42

RESOURCE_CODE_IF







共享存储最新修改：
/home/uxdb/uxdb-ng/uxdb-2.0-directio/src/backend/utils/rac/grd/nonpcm_bufmgr.c	//+2076
if (!uxdb_rac || resCode == RESOURCE_CODE_IF)

2021-11-02
1、postgres国内社区：
http://www.postgres.cn/v2/about




2021-11-11

1、windows转linux行尾符转换命令：
/bin/bash^M
sed -i "s/\r//" build.sh



2021-11-15

1、haproxy 负载均衡原理


2、pg连接池	pgbouncer
https://www.cnblogs.com/shuaixf/archive/2012/10/02/2710432.html

uxpool





8）SQLFetchScoll 
16）SQLGetStmtAttr


SQLGetDescField_1


./odbcTestPro --gtest_filter=ODBCTest.SQLGetDescField_1


haproxy


2021-11-17

haproxy调研

1、克隆代码：
git clone  https://gitee.com/mirrors/haproxy.git
2、切换到2.4版本
git reset --hard 6cbbecf09734aeb5fa8bb88f36f06a6f6d35e813


haproxy2.4编译安装：
make clean
make -j $(nproc) TARGET=linux-glibc USE_OPENSSL=1 USE_PCRE=1 USE_SYSTEMD=1
sudo make install


pgpool调研：

进程池代码分析：
https://www.cnblogs.com/gaojian/archive/2012/08/05/2623778.html

pgpool英文文档：
https://www.pgpool.net/mediawiki/index.php/Main_Page


2021-11-18

CI构建：

报告时间	构建成功率	构建次数	构建成功次数	失败环节	提交人	失败原因	是否修复			
2021/11/19	100%			1			1

RAC：
日志路径：/home/uxdb/.jenkins/workspace/unit_test/TestScript/log

The sum of running testcase is 1951
The sum of pass testcase is 0
The sum of fail testcase is 1951

错误"could not connect to server"个数：1648
错误"No such file or directory"个数：298
错误"SyntaxError: invalid syntax"个数：3
错误"IOError"个数：2
已统计错误总数：1951


sql:
/home/uxdb/.jenkins/workspace/unit_test/TestScript/CI_FailTestCaseLogCount/
/home/uxdb/.jenkins/workspace/unit_test/TestScript/CI_TestReportList/

错误"could not connect to server"个数：26
错误"error,the result is different to expect"个数：0
错误"parameter "(.*?)" cannot be changed now"个数：0
错误"parameter "(.*?)" cannot be changed without restarting the server"个数：1
错误"role "(.*?)" does not exist"个数：1
错误"the database system is in recovery mode"个数：0

报错信息查看：
/home/uxdb/.jenkins/jobs/unit_test/builds/169







单节点：
shared_buffers = 40GB
terminals=100

2021-11-19 21:59:03,878  INFO - Term-00, Measured tpmC (NewOrders) = 35346.2                
2021-11-19 21:59:03,878  INFO - Term-00, Measured tpmTOTAL = 78376.08                       
2021-11-19 21:59:03,879  INFO - Term-00, Session Start     = 2021-11-19 21:39:03            
2021-11-19 21:59:03,879  INFO - Term-00, Session End       = 2021-11-19 21:59:03            
2021-11-19 21:59:03,879  INFO - Term-00, Transaction Count = 1567893

shared_buffers = 40GB
terminals=200

2021-11-19 22:25:40,296  INFO - Term-00, Measured tpmC (NewOrders) = 43473.78               
2021-11-19 22:25:40,296  INFO - Term-00, Measured tpmTOTAL = 96471.82                       
2021-11-19 22:25:40,296  INFO - Term-00, Session Start     = 2021-11-19 22:05:38            
2021-11-19 22:25:40,296  INFO - Term-00, Session End       = 2021-11-19 22:25:40            
2021-11-19 22:25:40,297  INFO - Term-00, Transaction Count = 1932148 

shared_buffers = 40GB
terminals=300
2021-11-19 23:32:52,984  INFO - Term-00,                                                    
2021-11-19 23:32:52,984  INFO - Term-00, Measured tpmC (NewOrders) = 45008.05               
2021-11-19 23:32:52,984  INFO - Term-00, Measured tpmTOTAL = 99954.93                       
2021-11-19 23:32:52,984  INFO - Term-00, Session Start     = 2021-11-19 23:12:52            
2021-11-19 23:32:52,985  INFO - Term-00, Session End       = 2021-11-19 23:32:52            
2021-11-19 23:32:52,985  INFO - Term-00, Transaction Count = 1999779 

shared_buffers = 40GB
terminals=400

2021-11-19 23:57:13,174  INFO - Term-00, Measured tpmC (NewOrders) = 43640.23
2021-11-19 23:57:13,174  INFO - Term-00, Measured tpmTOTAL = 97058.93
2021-11-19 23:57:13,174  INFO - Term-00, Session Start     = 2021-11-19 23:37:12
2021-11-19 23:57:13,174  INFO - Term-00, Session End       = 2021-11-19 23:57:13
2021-11-19 23:57:13,174  INFO - Term-00, Transaction Count = 1942535


shared_buffers = 40GB
terminals=500

log4j:WARN Failure in post-close rollover action                                                                
2021-11-20 00:42:39,283  INFO - Term-00,                                                                        
2021-11-20 00:42:39,284  INFO - Term-00, Measured tpmC (NewOrders) = 43998.46                                   
2021-11-20 00:42:39,284  INFO - Term-00, Measured tpmTOTAL = 97737.16                                           
2021-11-20 00:42:39,284  INFO - Term-00, Session Start     = 2021-11-20 00:22:38                                
2021-11-20 00:42:39,285  INFO - Term-00, Session End       = 2021-11-20 00:42:39                                
2021-11-20 00:42:39,285  INFO - Term-00, Transaction Count = 1955990

shared_buffers = 40GB
terminals=600
2021-11-20 09:35:42,235  INFO - Term-00, Measured tpmC (NewOrders) = 41092.47                                   
2021-11-20 09:35:42,236  INFO - Term-00, Measured tpmTOTAL = 91487.12                                           
2021-11-20 09:35:42,236  INFO - Term-00, Session Start     = 2021-11-20 09:15:41                                
2021-11-20 09:35:42,236  INFO - Term-00, Session End       = 2021-11-20 09:35:42                                
2021-11-20 09:35:42,237  INFO - Term-00, Transaction Count = 1831152

shared_buffers = 40GB
terminals=700

2021-11-20 10:00:33,794  INFO - Term-00, Measured tpmC (NewOrders) = 41967.67                                   
2021-11-20 10:00:33,794  INFO - Term-00, Measured tpmTOTAL = 93189.35                                           
2021-11-20 10:00:33,794  INFO - Term-00, Session Start     = 2021-11-20 09:40:33                                
2021-11-20 10:00:33,809  INFO - Term-00, Session End       = 2021-11-20 10:00:33                                
2021-11-20 10:00:33,809  INFO - Term-00, Transaction Count = 1864822

shared_buffers = 40GB
terminals=800

2021-11-20 10:24:42,695  INFO - Term-00, Measured tpmC (NewOrders) = 41232.9                                    
2021-11-20 10:24:42,695  INFO - Term-00, Measured tpmTOTAL = 91807.64                                           
2021-11-20 10:24:42,695  INFO - Term-00, Session Start     = 2021-11-20 10:04:41                                
2021-11-20 10:24:42,696  INFO - Term-00, Session End       = 2021-11-20 10:24:42                                
2021-11-20 10:24:42,696  INFO - Term-00, Transaction Count = 1837194

shared_buffers = 40GB
terminals=1000

2021-11-20 10:47:54,311  INFO - Term-00, Measured tpmC (NewOrders) = 39151.38                                   
2021-11-20 10:47:54,311  INFO - Term-00, Measured tpmTOTAL = 86993.54                                           
2021-11-20 10:47:54,312  INFO - Term-00, Session Start     = 2021-11-20 10:27:52                                
2021-11-20 10:47:54,312  INFO - Term-00, Session End       = 2021-11-20 10:47:54                                
2021-11-20 10:47:54,312  INFO - Term-00, Transaction Count = 1742719




双节点

主备模式，然后开启负载均衡



性能监控：
nomn介绍：
https://www.cnblogs.com/kaymi/p/11281675.html


两节点：
主：
wal_level = replica
max_connections = 1024
shared_buffers=40GB
maintenance_work_mem=8GB
wal_buffers=1GB
effective_cache_size=64GB
bgwriter_delay = 100ms
bgwriter_lru_maxpages = 500
bgwriter_lru_multiplier = 5.0
effective_io_concurrency = 0
synchronous_commit = off
max_wal_size = 32GB
min_wal_size = 4GB
random_page_cost = 1.1
fsync = off
checkpoint_timeout = 30min


hot_standby = on
max_wal_senders = 3
wal_keep_segments = 64 
full_page_writes = on 
wal_log_hints = on




流复制修改配置文件：
ux_hba.conf
uxsinodb.conf

五分钟后下降

10仓
2021-11-21 10:11:24,096  INFO - Term-00, Measured tpmC (NewOrders) = 77366.12                                   
2021-11-21 10:11:24,096  INFO - Term-00, Measured tpmTOTAL = 171860.6                                           
2021-11-21 10:11:24,096  INFO - Term-00, Session Start     = 2021-11-21 09:51:23                                
2021-11-21 10:11:24,096  INFO - Term-00, Session End       = 2021-11-21 10:11:24                                
2021-11-21 10:11:24,096  INFO - Term-00, Transaction Count = 3439620









dstat -C 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31 -D /dev/mapper/vg_home-lv_home -g -m -n -ipc --top-io --top-cpu --top-mem --output dstat_10.csv 5

./uxpool  -n -D -f ../etc/uxpool.conf  > /home/uxdb/uxdbinstall/uxpool/log/uxpool.log 2>&1 &

num_init_children

配置异步模式：

未打开负载均衡：
tpmTOTAL = 9.3

打开负载均衡：


主机：%Cpu(s): 63.2 us, 25.8 sy,  0.0 ni,  1.1 id,  0.0 wa,  0.0 hi, 10.0 si,  0.0 st

备机：%Cpu(s):  5.3 us,  6.6 sy,  0.0 ni, 86.4 id,  0.8 wa,  0.0 hi,  1.0 si,  0.0 st







单节点：
不带uxpool：
warehouses=100
terminals=1000
runMins=10

%Cpu(s): 77.2 us, 13.9 sy,  0.0 ni,  4.4 id,  1.9 wa,  0.0 hi,  2.6 si,  0.0 st

2021-11-21 20:25:38,598  INFO - Term-00, Measured tpmC (NewOrders) = 73966.98               
2021-11-21 20:25:38,598  INFO - Term-00, Measured tpmTOTAL = 164746.74                      
2021-11-21 20:25:38,598  INFO - Term-00, Session Start     = 2021-11-21 20:15:36            
2021-11-21 20:25:38,598  INFO - Term-00, Session End       = 2021-11-21 20:25:38            
2021-11-21 20:25:38,598  INFO - Term-00, Transaction Count = 1654416

带uxpool：
warehouses=100
terminals=1000
runMins=10

2021-11-21 20:41:53,649  INFO - Term-00, Measured tpmC (NewOrders) = 47612.54               
2021-11-21 20:41:53,649  INFO - Term-00, Measured tpmTOTAL = 105716.62                      
2021-11-21 20:41:53,649  INFO - Term-00, Session Start     = 2021-11-21 20:31:53            
2021-11-21 20:41:53,649  INFO - Term-00, Session End       = 2021-11-21 20:41:53            
2021-11-21 20:41:53,649  INFO - Term-00, Transaction Count = 1058159


双节点：

关闭负载均衡 		//load_balance_mode = off

warehouses=100
terminals=1000
runMins=10

2021-11-21 20:59:39,396  INFO - Term-00, Measured tpmC (NewOrders) = 42353.53               
2021-11-21 20:59:39,397  INFO - Term-00, Measured tpmTOTAL = 94206.88                       
2021-11-21 20:59:39,397  INFO - Term-00, Session Start     = 2021-11-21 20:49:37            
2021-11-21 20:59:39,397  INFO - Term-00, Session End       = 2021-11-21 20:59:39            
2021-11-21 20:59:39,397  INFO - Term-00, Transaction Count = 945508



打开负载均衡 		//load_balance_mode = on
warehouses=100
terminals=1000
runMins=10

2021-11-21 21:17:08,772  INFO - Term-00, Measured tpmC (NewOrders) = 42978.08               
2021-11-21 21:17:08,772  INFO - Term-00, Measured tpmTOTAL = 95515.58                       
2021-11-21 21:17:08,772  INFO - Term-00, Session Start     = 2021-11-21 21:07:07            
2021-11-21 21:17:08,772  INFO - Term-00, Session End       = 2021-11-21 21:17:08            
2021-11-21 21:17:08,772  INFO - Term-00, Transaction Count = 957522



jdbc改造后：
warehouses=100
terminals=1000
runMins=10

2021-11-21 22:39:30,283  INFO - Term-00, Measured tpmC (NewOrders) = 100392.36
2021-11-21 22:39:30,283  INFO - Term-00, Measured tpmTOTAL = 222857.72
2021-11-21 22:39:30,283  INFO - Term-00, Session Start     = 2021-11-21 22:19:29
2021-11-21 22:39:30,283  INFO - Term-00, Session End       = 2021-11-21 22:39:30
2021-11-21 22:39:30,283  INFO - Term-00, Transaction Count = 4461191


jdbc改造后第二次：
warehouses=100
terminals=1000
runMins=10
2021-11-22 09:50:03,330  INFO - Term-00, Measured tpmC (NewOrders) = 103904.8               
2021-11-22 09:50:03,331  INFO - Term-00, Measured tpmTOTAL = 230541.38                      
2021-11-22 09:50:03,331  INFO - Term-00, Session Start     = 2021-11-22 09:40:02            
2021-11-22 09:50:03,331  INFO - Term-00, Session End       = 2021-11-22 09:50:03            
2021-11-22 09:50:03,331  INFO - Term-00, Transaction Count = 2308164


url=jdbc:uxdb://192.72.0.62:5432,192.72.0.63:5432/uxdb
enable=false

单节点：
数据库：debug版  
shared_buffers = 16GB
warehouses=100
terminals=1000
runMins=10

2021-11-22 13:59:28,254  INFO - Term-00, Measured tpmC (NewOrders) = 75519.81               
2021-11-22 13:59:28,254  INFO - Term-00, Measured tpmTOTAL = 168197.46                      
2021-11-22 13:59:28,254  INFO - Term-00, Session Start     = 2021-11-22 13:49:25            
2021-11-22 13:59:28,254  INFO - Term-00, Session End       = 2021-11-22 13:59:28            
2021-11-22 13:59:28,255  INFO - Term-00, Transaction Count = 1688724


主备节点：


2021-11-22 14:24:32,254  INFO - Term-00, Measured tpmC (NewOrders) = 111472.6               
2021-11-22 14:24:32,254  INFO - Term-00, Measured tpmTOTAL = 247833.92                      
2021-11-22 14:24:32,254  INFO - Term-00, Session Start     = 2021-11-22 14:14:31            
2021-11-22 14:24:32,254  INFO - Term-00, Session End       = 2021-11-22 14:24:32            
2021-11-22 14:24:32,254  INFO - Term-00, Transaction Count = 2481304

提升47.6%


单节点：
shared_buffers = 16GB
warehouses=100
terminals=1000
runMins=20

2021-11-22 14:56:51,454  INFO - Term-00, Measured tpmC (NewOrders) = 74103.67               
2021-11-22 14:56:51,454  INFO - Term-00, Measured tpmTOTAL = 164707.31                      
2021-11-22 14:56:51,455  INFO - Term-00, Session Start     = 2021-11-22 14:36:48            
2021-11-22 14:56:51,455  INFO - Term-00, Session End       = 2021-11-22 14:56:51            
2021-11-22 14:56:51,455  INFO - Term-00, Transaction Count = 3302570


主备节点：


2021-11-23 09:48:59,020  INFO - Term-00, Measured tpmC (NewOrders) = 110284.03                    
2021-11-23 09:48:59,020  INFO - Term-00, Measured tpmTOTAL = 244943.34                            
2021-11-23 09:48:59,020  INFO - Term-00, Session Start     = 2021-11-23 09:28:58                  
2021-11-23 09:48:59,020  INFO - Term-00, Session End       = 2021-11-23 09:48:59                  
2021-11-23 09:48:59,020  INFO - Term-00, Transaction Count = 4902087



jdbc添加配置文件后，验证 shared_buffers=16G，terminals = 100，tpcc性能数据，
验证
tpcc 10min，单节点 tpmc = 75519.81，主备节点模式下 tpmc = 111472.6，性能提升；47.6%
tpcc 20min，单节点 tpmc = 74103.67，主备节点模式下 tpmc = 110284.03，性能提升；48.8%

时间设置为20min后，tpcc报冲突报错后，tpcc链接断开，
原因是备库在wal流中获取更新数据时，而更新将正在运行的查询当前正在访问的数据无效，
在这种情况下报错；
解决方法：备机将参数max_standby_streaming_delay = 600s，login_idle_time = 3000；它允许备库特意增加延迟以允许查询完成。
由于备机只有一两个进程处于工作状态，数据库存在连接超时设置，超过5min数据库会断开链接，
将login_idle_time设置3000，目前测试错误未复现
















conn=jdbc:uxdb://192.72.0.62:5432,192.72.0.63:5432/uxdb?maxActive=200&initialSize=200




2021-1203
性能测试总结
1、通过火焰图查看哪个函数调用次数最频繁
火焰图分析：
1、宽度越宽，性能损耗越多

2、查看

 通知下大家，每个人需要写一个总结回顾，包括工作贡献，团队贡献，岗位符合度的回顾（岗位的理解，岗位产出，不足等），流程规范方面（规范的理解，用到那些规范，建议）；对自己规划及改进，以及建议等其它方面。

这个文档的用途：1、年终总结； 2、和每个员工要沟通，岗位理解，产出，不足，规划等。所以最后是对岗位，流程，工作产出，不足等多方面能总结回顾到

总结里面再加一些：可以从工作项目和公司日常两方面，各列几项认为做的好的和做的不好的事；
比如版本里面某件事认为比较好；公司日常，包括管理，活动，考勤，加班等等

这个文档格式不限，PPT，doc都可以。 不一定需要讲解，但是会每个人都沟通。

截止时间是周五中午前交给我。ps 实习生可以不写。


1、工作贡献、团队贡献、岗位的理解，岗位产出，不足等

2、流程规范方面（规范的理解，用到哪些规范，建议）

3、自我规划及改进，建议

1、团队贡献：
wal日
uxpool连接池培训

2、岗位符合度的回顾（岗位的理解，岗位产出，不足等）
主要进行需求分析、需求理解、功能设计、实现和测试


3、流程规范方面（规范的理解，用到那些规范，建议）
4、自我规划及改进



自我规划：




工作内容：
缺陷
1、tpcc稳定性测试
2、make check_32_ora不通过
总工时：1786
产品服务部：193h
1、2.1.0.4s迭代开发				11.4%
主要处理版本稳定性、wal日志、列加密、make check修复相关问题
8+4+1+3+11+9+20+56+8+11=131h	7.3%

2、安全版重构
分别在安全模式和安全兼容模式，验证bin工具、插件、高可用工具可用性；
20+8+26+8=62h					4.1%


对外支持：工时：546h			30%
1、信创支持：
在线升级和节点故障问题分析
2、28所项目支持
主要进行语法兼容开发
3、重庆粮食局支持
mysql默认配置时大小写问题
4、保密四期支持
主要处理initdb、uxaudit审计日志等相关问题
5、区域化项目支持：
分析ADO.NET连接uxdb数据库
6、GFKD数据库适配项目支持
用户密码加密大小写、初始化添加表注释问题
7、重庆传晟项目支持
流复制备机wal日志损坏问题



rac组：工时：1047h				58.6%
1、direct io接口开发
2、表文件、离线恢复相关wal日志接口等接口替换
3、各进程共享内存初始化大小开发
4、ASCII、GB18030、UTF8等多语言字符集移植
5、rac审计代码移植
6、表、索引扩展块相关代码修改
7、dio性能分析
8、查看pg消耗内存计算方法
9、fsm分块代码修改
10、dev、dio、nfs打包脚本修改
11、nci接口移植
12、haproxy改造计划，进行高可用预研



支持：
postgres_adaptor插件更新
信创支持：
验证在线升级和节点故障

28所项目支持：
语法相关支持

重庆粮食局：
兼容mysql默认大小写；

保密四期支持：
根据现场需求实现相关功能；

区域化项目支持：
ADO.NET连接SQLServer数据库

电子五所：


GFKD数据库适配：

重庆传晟：



1、完成oracle与uxdb merge功能差异整理
2、协助查看语法打开make check问题

1、整理安全功能的身份鉴别
2、uxmpp环境搭建

1、年度述职报告（完成100%）
2、处理问题单100331，报错为强仿数据参数

1、wal日志培训
2、解决问题单100331

1：2.1.0.4s安全版打包
2：安全版已解决缺陷功能验证

完成2.1.0.4s已解决问题单验证、
分析问题单100403mpp分片后数据迁移报错

100403mpp分片后数据迁移已定位清楚报错原因
分析mpp分片后，where in子句元组ctid描述符操作报错

2.1.0.4s打包已解决问题单验证

#101492：安全版make  check报错问题分析

101492：完成安全版make check分析，
目前测试用例brin 、gist、 spgist、 privileges已修改验证
101492：安全版make check测试用例修改（完成50%）

部门述职报告会议；
参加自访控制分享会议；
安全版make check报错修改

修改make check报错，提交make check修改用例
安全版make check部分代码提交mr
安全版审计代码检视
1、别名代码修改并提交MR
2、sysdate语法兼容修改，并提交MR

28所支持，完善sysdate代码

1、number类型兼容分析mr合入
2、安全版make check修改检视意见
3、storage语法兼容分析

1、#102306：storage语法功能调研
2、#102373：脚本调用uxsql时指定密码修改并提交mr

解决make check报错问题，目前剩余6个sql文件待解决

make check分析在非超级用户模式下，强转uxdb模式下的类型报错，
目前分析原因由于安全版命名空间链表导致

1、分析make check报错问题
2、兼容LINUX环境下 mysql 默认配置时大小写的行为
兼容mysql大小写行为，目前存在问题：
1、initdb初始化存在大小写不匹配问题
2、make check中有4种sql语句目前未转换

#102680：兼容LINUX环境下 mysql 默认配置时大小写的行为
整理重庆粮食大小写敏感文档，并上传至redmine
涉密版本需求支持
保密四期支持
将uxsinodb.login文件信息加入ux_login_table表中，且增加上次失败字段：
配置ADO.NET连接SQLServer数据库，链接成功，需分析web.config链接sqlserver数据库方式
#106134 ：CDPS代码合入支持。
2、支持国防科大项目
begin语句改造
销售四级安全功能规范文档编写
区域化项目支持




	
#129390:ux_cron、repmgr插件提示模式不存在，ux_cron extension插件未加载等问题		10h
#127403:【2114s】工具、插件、高可用工具验证											8h
#110025:软江项目uxpool问题															24h

42h
#127403:【2114s】工具、插件、高可用工具验证											8h
#110025:软江项目uxpool问题															24h


报错语句：
SELECT ts,           
CASE WHEN last_xact_replay_timestamp IS NULL             THEN 0::INT           ELSE             EXTRACT(epoch FROM (ux_catalog.clock_timestamp() - last_xact_replay_timestamp))::INT                    END AS replication_lag_time

FROM (  SELECT CURRENT_TIMESTAMP AS ts,         ux_catalog.ux_is_in_recovery() AS in_recovery,         ux_catalog.ux_last_xact_replay_timestamp() AS last_xact_replay_timestamp,         COALESCE(ux_catalog.ux_last_wal_receive_lsn(), '0/0'::UX_LSN) AS last_wal_receive_lsn,         COALESCE(ux_catalog.ux_last_wal_replay_lsn(),  '0/0'::UX_LSN) AS last_wal_replay_lsn,         
CASE WHEN ux_catalog.ux_is_in_recovery() IS FALSE           THEN FALSE           ELSE ux_catalog.ux_is_wal_replay_paused()         END AS wal_replay_paused,         
CASE WHEN ux_catalog.ux_is_in_recovery() IS FALSE           THEN -1           ELSE repmgr.get_upstream_last_seen()         END AS upstream_last_seen           ) q;

实际报错语句：
SELECT EXTRACT(epoch FROM (ux_catalog.clock_timestamp()))::INT from ux_catalog.ux_last_xact_replay_timestamp() AS last_xact_replay_timestamp;

报错（循环第三次）：
ParseFuncOrColumn		//305：正常应该fdresult == FUNCDETAIL_NORMAL
	func_get_detail		//1539：正常ncandidates应该等于1
		func_match_argtypes	//930： 第二次循环，条件为真
			can_coerce_type
		
(gdb) p inputTypeId
$9 = 705
(gdb) p targetTypeId
$10 = 25


305行：
正常应该：
fdresult == FUNCDETAIL_NORMAL


122             if (fn && fn->agg_filter != NULL)
(gdb)
133             if (list_length(fargs) > FUNC_MAX_ARGS)
(gdb)
153             nargs = 0;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
156                     Node       *arg = lfirst(l);
(gdb)
157                     Oid                     argtype = exprType(arg);
(gdb)
159                     nextl = lnext(l);
(gdb)
161                     if (argtype == VOIDOID && IsA(arg, Param) &&
(gdb)
168                     actual_arg_types[nargs++] = argtype;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
156                     Node       *arg = lfirst(l);
(gdb)
157                     Oid                     argtype = exprType(arg);
(gdb)
159                     nextl = lnext(l);
(gdb)
161                     if (argtype == VOIDOID && IsA(arg, Param) &&
(gdb)
168                     actual_arg_types[nargs++] = argtype;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
179             argnames = NIL;
(gdb)
180             foreach(l, fargs)
(gdb)
182                     Node       *arg = lfirst(l);
(gdb)
184                     if (IsA(arg, NamedArgExpr))
(gdb)
203                             if (argnames != NIL)
(gdb)
180             foreach(l, fargs)
(gdb)
182                     Node       *arg = lfirst(l);
(gdb)
184                     if (IsA(arg, NamedArgExpr))
(gdb)
203                             if (argnames != NIL)
(gdb)
180             foreach(l, fargs)
(gdb)
211             if (fargs)
(gdb)
213                     first_arg = linitial(fargs);
(gdb)
228                                                        list_length(funcname) == 1 &&
(gdb)
224             could_be_projection = (nargs == 1 && !proc_call &&
(gdb)
235             if (could_be_projection && is_column)
(gdb)
265             setup_parser_errposition_callback(&pcbstate, pstate, location);
(gdb)
272                                                                &declared_arg_types, &argdefaults);
(gdb)
269                                                                !func_variadic, true,
(gdb)
267             fdresult = func_get_detail(funcname, fargs, argnames, nargs,
(gdb)
274             cancel_parser_errposition_callback(&pcbstate);
(gdb)
281             if (proc_call &&
(gdb)
295             if (fdresult == FUNCDETAIL_PROCEDURE && !proc_call)
(gdb)
305             if (fdresult == FUNCDETAIL_NORMAL ||
(gdb)
306                     fdresult == FUNCDETAIL_PROCEDURE ||
(gdb)
355             if (fdresult == FUNCDETAIL_NORMAL || fdresult == FUNCDETAIL_PROCEDURE)
(gdb)
359             else if (fdresult == FUNCDETAIL_AGGREGATE)
(gdb)
514             else if (fdresult == FUNCDETAIL_WINDOWFUNC)
(gdb)
533             else if (fdresult == FUNCDETAIL_COERCION)
(gdb)
543             else if (fdresult == FUNCDETAIL_MULTIPLE)
(gdb)
581                     if (is_column)
(gdb)
587                     if (could_be_projection)
(gdb)
601                     if (list_length(agg_order) > 1 && !agg_within_group)
(gdb)
614                     else if (proc_call)
(gdb)
624                             ereport(ERROR,



正常：

122             if (fn && fn->agg_filter != NULL)
(gdb)
133             if (list_length(fargs) > FUNC_MAX_ARGS)
(gdb)
153             nargs = 0;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
156                     Node       *arg = lfirst(l);
(gdb)
157                     Oid                     argtype = exprType(arg);
(gdb)
159                     nextl = lnext(l);
(gdb)
161                     if (argtype == VOIDOID && IsA(arg, Param) &&
(gdb)
168                     actual_arg_types[nargs++] = argtype;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
156                     Node       *arg = lfirst(l);
(gdb)
157                     Oid                     argtype = exprType(arg);
(gdb)
159                     nextl = lnext(l);
(gdb)
161                     if (argtype == VOIDOID && IsA(arg, Param) &&
(gdb)
168                     actual_arg_types[nargs++] = argtype;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
179             argnames = NIL;
(gdb)
180             foreach(l, fargs)
(gdb)
182                     Node       *arg = lfirst(l);
(gdb)
184                     if (IsA(arg, NamedArgExpr))
(gdb)
203                             if (argnames != NIL)
(gdb)
180             foreach(l, fargs)
(gdb)
182                     Node       *arg = lfirst(l);
(gdb)
184                     if (IsA(arg, NamedArgExpr))
(gdb)
203                             if (argnames != NIL)
(gdb)
180             foreach(l, fargs)
(gdb)
211             if (fargs)
(gdb)
213                     first_arg = linitial(fargs);
(gdb)
228                                                        list_length(funcname) == 1 &&
(gdb)
224             could_be_projection = (nargs == 1 && !proc_call &&
(gdb)
235             if (could_be_projection && is_column)
(gdb)
265             setup_parser_errposition_callback(&pcbstate, pstate, location);
(gdb)
272                                                                &declared_arg_types, &argdefaults);
(gdb)
269                                                                !func_variadic, true,
(gdb)
267             fdresult = func_get_detail(funcname, fargs, argnames, nargs,
(gdb)
274             cancel_parser_errposition_callback(&pcbstate);
(gdb)
281             if (proc_call &&
(gdb)
295             if (fdresult == FUNCDETAIL_PROCEDURE && !proc_call)
(gdb)
305             if (fdresult == FUNCDETAIL_NORMAL ||
(gdb)
313                     if (agg_star)
(gdb)
320                     if (agg_distinct)
(gdb)
326                     if (agg_within_group)
(gdb)
332                     if (agg_order != NIL)
(gdb)
338                     if (agg_filter)
(gdb)
344                     if (over)
(gdb)
355             if (fdresult == FUNCDETAIL_NORMAL || fdresult == FUNCDETAIL_PROCEDURE)
(gdb)
641             nargsplusdefs = nargs;
(gdb)
642             foreach(l, argdefaults)
(gdb)
664             rettype = enforce_generic_type_consistency(actual_arg_types,
(gdb)
671             make_fn_arguments(pstate, fargs, actual_arg_types, declared_arg_types);
(gdb)
678             if (!OidIsValid(vatype))
(gdb)
681                     func_variadic = false;



2022-02-14


heap_open

Datum ux_login_table_insert(UX_FUNCTION_ARGS)
{
	Datum		values[Natts_ux_login_table];
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);
	bool nulls[Natts_ux_login_table];
	
		Name	queryid = "123456";
	Name	query = query_string;
	Name	total_time = "0214"
	Name	suggestions = "split(partition_suggest_data)";
	
	values[0]=NameGetDatum(rolname);
	values[1]=NameGetDatum(last_login_timestamp);
	values[2]=NameGetDatum(last_failuretime);
	values[3]=NameGetDatum(last_failuretime);
	
	//if rolename don't in table ,insert it
   
		Relation	ux_login_table_desc;
		HeapTuple tup;
		ux_login_table_desc = heap_open(PartitionSuggestRelationId, RowExclusiveLock);
		tup = heap_form_tuple(RelationGetDescr(ux_login_table_desc), values, nulls);
		CatalogTupleInsert(ux_login_table_desc, tup);
		heap_freetuple(tup);
		heap_close(ux_login_table_desc, RowExclusiveLock);
		UX_RETURN_BOOL(true);
}

	Datum		values[4];
	bool nulls[4];
	Name	queryid = "123456";
	Name	query = "query";
	Name	total_time = "0214";
	Name	suggestions = "split(partition_suggest_data)";

	values[0]=NameGetDatum(queryid);
	values[1]=NameGetDatum(query);
	values[2]=NameGetDatum(total_time);
	values[3]=NameGetDatum(suggestions);

	Relation	partition_suggest_desc;
	HeapTuple tup;
	if(IsUnderPostmaster && (strstr(query_string, "between") != NULL))
	{
		partition_suggest_desc = heap_open(RelationRelationId, RowExclusiveLock);
		tup = heap_form_tuple(RelationGetDescr(partition_suggest_desc), values, nulls);
		CatalogTupleInsert(partition_suggest_desc, tup);
		heap_freetuple(tup);
		heap_close(partition_suggest_desc, RowExclusiveLock);
	}

select reltuples from ux_class where relname = 'partition_suggest_data';


RelationRelationId


rel = heap_open(RelationRelationId, AccessShareLock);



	ScanKeyData key[1];
	classRel = heap_open(RelationRelationId, AccessShareLock);

	ScanKeyInit(&key[0],
				Anum_ux_class_relkind,
				BTEqualStrategyNumber, F_CHAREQ,
				CharGetDatum(RELKIND_RELATION));

	scan = heap_beginscan_catalog(classRel, 1, key);

	while ((tuple = heap_getnext(scan, ForwardScanDirection)) != NULL)
	{
		Oid			relid = HeapTupleGetOid(tuple);
		Form_ux_class relForm = (Form_ux_class) GETSTRUCT(tuple);

		if (is_publishable_class(relid, relForm))
			result = lappend_oid(result, relid);
	}

	heap_endscan(scan);
	heap_close(classRel, AccessShareLock);

Relation		rel_table;
char			*ux_class_relname = NULL;
rel_table =  heap_open(RelationRelationId, AccessShareLock);
scandesc = systable_beginscan(rel_table, ClassOidIndexId, true,
							   SnapshotSelf, 1, &skey);
while((tuple = systable_getnext(scandesc)) != NULL)
{
	value_datum[0] = heap_getattr(tuple, 1, rel_table, &isnull);
	ux_class_relname = text_to_cstring(DatumGetTextP(value_datum[0]));
	if(strcmp(ux_class_relname, "partition_suggest_data") == 0)
	{
		elog("partition_suggest_data = %s", ux_class_relname);
		break;
	}
}

	rel_table = heap_open(RelationRelationId, AccessShareLock);
	scandesc = systable_beginscan(rel_table, ClassOidIndexId, true,
							   SnapshotSelf, 1, &skey);

	tuple = systable_getnext(scandesc);



rel = heap_open(RelationRelationId, AccessShareLock);
	scan = heap_beginscan_catalog(rel, 1, key);




relScan = heap_beginscan_catalog(classRel, 0, NULL);
获取表oid：
get_relname_relid()

2022-02-21

oracle数据库sql参考：
https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_6010.htm

预研：
资源管理：
https://www.cnblogs.com/NamingException/p/10891976.html

资源限制：对 用户 或者 系统 进行一些资源限制，用以防止服务器资源紧张。
资源监控：查看数据库资源使用情况；
表空间资源限制：设置用户在表空间的限额；
客体重用：通过客体重用的功能，防止非法进程利用数据库客体的内存泄漏来攻击数据库；
基于任务优先级的CPU调度：根据任务的优先级设置CPU调度的优先级；

原始问题：
1、物理存储配置管理：
测试内容：应提供数据文件、日志文件、归档文件的物理存储位置设置和数据库空间大小分配、页大小分配等功能，是否提供了推荐配置参数。
测试方法：分别验证数据库文件、日志文件、归档文件的物理存储位置的设置功能以及数据库空间大小分配、页大小分配功能，并检查配置过程中是否提供了推荐配置参数。

2、用户使用资源控制：
用户内存使用空间限制(要真正的用户内存控制)

目前需求：

1、物理资源配置管理
物理资源配置管理
a.数据库空间大小可分配
b.页大小可分配
c.其他资源管理需参考其他数据库进一步调查

2、用户使用资源控制
用户使用资源控制
a.用户的内存使用空间
b.用户的磁盘使用空间






使用create profile命令创建一个profile，用它来实现对数据库资源的限制使用。如果把该profile分配给用户，则该用户所能使用的数据库资源都在该profile的限制之内。

一、资源限制

1、创建profile命令：

 CREATE PROFILE sec_profile LIMIT
     SESSIONS_PER_USER          UNLIMITED
     CPU_PER_SESSION            UNLIMITED
     CPU_PER_CALL               6000
     CONNECT_TIME               60
     LOGICAL_READS_PER_SESSION  DEFAULT
     LOGICAL_READS_PER_CALL     6000
     COMPOSITE_LIMIT            6000000
     PRIVATE_SGA                66K
     FAILED_LOGIN_ATTEMPTS      6
     PASSWORD_LIFE_TIME         60
     PASSWORD_REUSE_TIME        60
     PASSWORD_REUSE_MAX         5
     PASSWORD_LOCK_TIME         1/24
     PASSWORD_GRACE_TIME        10  
     PASSWORD_VERIFY_FUNCTION   verify_function


2、将profile指定给具体用户：

alter user sec profile sec_profile;

三、表空间资源限制
注意：Oracle 建议您使用数据库资源
Manager 而不是 SQL 配置文件来建立数据库资源限制。
数据库资源管理器提供了一种更灵活的方法
管理和跟踪资源使用。 有关更多信息
数据库资源管理器，请参阅 Oracle 数据库管理员
指导。

create user itme identified by zero default tablespace myspace 
quota 10M on myspace 
quota 5M on system temporary tablespace temp profile default account unlock;


配额条款
使用 QUOTA 子句指定用户可以分配的最大空间量
表空间。
一个 CREATE USER 语句可以有多个用于多个表空间的 QUOTA 子句。
UNLIMITED 允许用户在表空间中无限制地分配空间。
QUOTA 条款的限制 您不能将此条款指定为临时
表空间。
简介条款
指定要分配给用户的配置文件。 配置文件限制的数量
用户可以使用的数据库资源。 如果省略此子句，则 Oracle 数据库
将默认配置文件分配给用户。



四、客体重用：

达梦：
http://k.sina.com.cn/article_7033464851_1a33a281300100pxe3.html?subch=otech



































CREATE TABLE "NC"."NR_AIN_HOURDB0" (
  "TIME" DATE NOT NULL ,
  "ID" NUMBER(16) NOT NULL ,
  "V" NUMBER(20,3) ,
  "AVGV" NUMBER(20,3) ,
  "MAXV" NUMBER(20,3) ,
  "MAXT" DATE ,
  "MINV" NUMBER(20,3) ,
  "MINT" DATE ,
  "S" NUMBER(2) ,
  "AVGS" NUMBER(2) ,
  "MAXS" NUMBER(2) ,
  "MINS" NUMBER(2) 
)
NOLOGGING
NOCOMPRESS

STORAGE (
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Primary Key structure for table NR_AIN_HOURDB0
-- ----------------------------
ALTER TABLE "NC"."NR_AIN_HOURDB0" ADD CONSTRAINT "NR_AIN_HOURDB10_PK" PRIMARY KEY ("TIME", "ID");


-------------
oracle_migration 使用步骤：

conn.config文件配置：
oracle_server_uri=//192.71.0.118/orcl			//oracle IP,SID
oracle_log_user=ORA_USER2						//oracle 用户名
uxdb_server_host=127.0.0.1
uxdb_server_port=5432
uxdb_server_dbname=uxdb
uxdb_log_user=uxdb

./export_oracle_inc -s 192.168.30.199:1521/imc   -u uxmig   -p nariacc -l nc,pubuser >table_owner1.ddl
./init_foreign_server_inc -f conn.config -p '1qaz!QAZ!@#'  -r nariacc
./import_uxdb_inc -f conn.config -p '1qaz!QAZ!@#'  -i table_owner1.ddl
./sync_table_inc -f conn.config -p '1qaz!QAZ!@#' -r nariacc -l nc,pubuser -s 2022/2/22-15:05:00 -i 480 -a -D  -v -q 8

1、导出ddl
./export_oracle -s 192.71.0.118:1521/orcl   -u ORA_USER2   -p 123456 -l ORA_USER2 >table_owner2.ddl
./init_foreign_server -f conn.config -p'1qaz!QAZ' -r 123456
./import_uxdb -f conn.config -p '1qaz!QAZ' -i table_owner2.ddl
./add_table -f conn.config -p '1qaz!QAZ' -r 123456 -l ORA_USER2
同步数据：
./sync_table -f conn.config -p '1qaz!QAZ' -r 123456

sql语句：
create table NR_AIN_HOURDB0(
       classid number(20),
       classname varchar(3000) not null,
	   time date
       );

ALTER TABLE NR_AIN_HOURDB0 ADD CONSTRAINT NR_AIN_HOURDB10_PK PRIMARY KEY (classid,time);

insert into NR_AIN_HOURDB0 select rownum,'create user C##java identified by oracle default tablespace users temporary tablespace temp quota 100m on users quota 100m on system CREATE USER C##sidney IDENTIFIED BY out_standing1 DEFAULT TABLESPACE example QUOTA 10M ON example ',sysdate from dual connect by level <=5;


select a.constraint_name,  a.column_name 
from user_cons_columns a, user_constraints b 
where a.constraint_name = b.constraint_name 
  and b.constraint_type = 'P' and a.table_name = 'NR_AIN_HOURDB0'

oracle_fdw:
1、create extension oracle_fdw;
2、create server osdba_fdw foreign data wrapper oracle_fdw options (dbserver '//192.71.0.118:1521/orcl');
3、create user mapping for uxdb server osdba_fdw options(user 'ora_user1', password '123456');
4、create foreign table "test_tab"(id int, name varchar(100)) server osdba_fdw options(table 'TEST_TAB');
select * from test_tab;

alter system set nls_date_format= 'yyyy-mm-dd hh24:mi:ss' scope=spfile;



2022-03-07

统计信息：

查看某个表的统计信息：
select *
from ux_catalog.ux_stat_user_tables
  where schemaname = 'myschema' and relname = 'tb1';


二、pg_stat_activity
查看当前运行中的耗时较长的SQL语句：
select current_timestamp - query_start as runtime, datname, usename, query
    from ux_stat_activity
    where state != 'idle'
    order by 1 desc;
  
停止正在执行的sql：
1、
SELECT ux_cancel_backend(进程id);
这种方式只能kill select查询，对update、delete 及DML不生效)

2、
SELECT ux_terminate_backend(PID);
这种可以kill掉各种操作(select、update、delete、drop等)操作；


顺序扫描代价计算：
顺序扫描函数：
cost_seqscan

总代价 = 总的IO花费 + 总的CPU花费
获取页和元祖：
select RELPAGES,RELTUPLES from ux_class where relname = 'HF_GXZH';

并行执行未显示可能将max_parallel_workers_per_gather设置为0；
max_parallel_workers_per_gather = 0

总代价 = 启动花费+总的IO花费+总的CPU花费
spc_seq_page_cost = 1
总的IO花费 = spc_seq_page_cost * RELPAGES

cpu_tuple_cost = 0.01
总的CPU花费 (cpu_tuple_cost + quxsqlual_cost.per_tuple) * RELTUPLES


where in （递增0.00125）
quxsqlual_cost.per_tuple：
2个条件：
quxsqlual_cost.per_tuple = 0.0025

3个条件：
quxsqlual_cost.per_tuple = 0.0037499999999999999
4个条件：
0.0050
5个：
0.00625
6个：
0.0075
7个：
0.00875

比如where in后面
0.01+0.0025 = 0.0125 * 100 = 1.25 + 2 = 3.75

actual time:

ExecutorRun
	standard_ExecutorRun
		ExecutePlan
			ExecProcNode
				ExecProcNodeFirst
					ExecProcNodeInstr
						InstrStopNode
	

ExecScan				//按照全局变量 ExecDirection 指定方向返回符合条件的元祖

ExecScanFetch			//


2022-3-10

河南移动：
mod(x,1)这个永远=0

 call dbms_application_info.set_module(?,?)   王奇
 
mod(dbms_utility.get_hash_value(rowid,1,10000),1)  王奇



get_hash_value：此函数计算给定字符串的哈希值。


create table tb(id int,val char(20));
insert into tb  values( 1, 'aaa');
insert into tb values( 2, 'bbb');
insert into tb values( 3, 'ccc');
create or replace function dbms_utility.get_hash_value(name varchar2, base numeric, hash_size numeric)
returns numeric as
$$
	select mod(abs(hashtextextended(name,0)),hash_size - base) + base;
$$ language sql;

对
oid  | castsource | casttarget | castfunc | castcontext | castmethod
insert into ux_cast values(17237,9002,'text'::regtype,0,'i','i');

create or replace function dbms_utility.get_hash_value(name text, base numeric, hash_size numeric)
returns numeric as
$$
	select mod(abs(hashtextextended(name,0)),hash_size) + base;
$$ language sql;

select dbms_utility.get_hash_value(rowid,1,10000)from tb;
 select * from tb where mod(dbms_utility.get_hash_value(rowid,1,10000),1)=0;

2、call dbms_application_info.set_module(?,?)
记录数据库中正在执行的模块或事务的名称；

module_name
当前正在运行的模块的名称。 当前模块终止时，如果有新模块，则使用新模块的名称调用此过程，如果没有，则使用 NULL。 长度超过 48 个字节的名称将被截断。

action_name
当前模块中当前操作的名称。 如果您不想指定操作，则该值应为 NULL。 超过 32 个字节的名称将被截断。





oracle查看记录的会话信息：
SELECT sid,serial#,client_info,MODULE,action FROM v$session;


exec dbms_application_info.set_module('test module','test action');

call dbms_application_info.set_module('test module','test action');
 
向v$session系统表中的MODULE、ACTION字段添加注释；

select distinct sid from v$mystat;

select module,action,client_info from v$session where sid=1036;


实现语法：

CREATE PROCEDURE dbms_application_info.set_module(a text, b text)    
LANGUAGE SQL    
AS $$
set log_filename=a;   
$$;    
    
CALL dbms_application_info.set_module(1, 2); 

最终语句：
CREATE SCHEMA dbms_application_info;
CREATE PROCEDURE dbms_application_info.set_module(str1 text, str2 text)
 as $$
	declare string text;
	begin string:='set module=' || $1 || ';';
		string:=string || 'set action=' || $2;
		execute string;
	end; $$
LANGUAGE pluxsql;



static struct config_string ConfigureNamesString[] =
{
	{
		{"module", UXC_USERSET, PROCESS_TITLE,
			gettext_noop("Name of module that is currently running."),
			NULL
		},
		&module,
		"",
		NULL, NULL, NULL
	},
	{
		{"action", UXC_USERSET, PROCESS_TITLE,
			gettext_noop("Name of current action within the current module."),
			NULL
		},
		&action,
		"",
		NULL, NULL, NULL
	},

显示时分秒：
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';




2022-03-10
1、数据类型隐式转换：
通过向ux_cast表中插入对应数据实现转换；


函数:
1、max函数，找到ux_cast表的最大oid；
select max(oid) from ux_cast;


语法添加：
1、gram.y中添加：
1）子句类型：node节点
在%type <node>添加；

2）通过makeNode创建节点；
如：
maxrefClause *n = makeNode(maxrefClause);
maxrefClause为节点类型；

2、在parsenodes.h中添加
maxrefClause节点类型

3、在nodes.h添加枚举类型
在NodeTag中添加枚举：
T_maxrefClause

语义分析：

1、子句调用栈：
parse_analyze
	transformTopLevelStmt
		transformOptionalSelectInto
			transformStmt
				transformSelectStmt
					transformWhereClause
						transformExpr
							transformExprRecurse
								transformBoolExpr
							transformExprRecurse	
								transformSubLink
									parse_sub_analyze

编译命令：
 ./build.sh --release=standard --version=2.1.1.4 --license=internal --enable-root --nouxfs

sudo yum -y install gcc flex bison readline readline-devel zlib zlib-devel   openssl openssl-devel libxml2 libxml2-devel libxslt libxslt-devel gettext libssl libssl-devel libssh linssh-devel    perl-ExtUtils-Embed ossp-uuid-dev libcurl lz4 zstd
yum install -y ant fuse fuse-devel boost-devel

yum install -y libtool*
yum -y install automake
sudo yum install libselinux-devel maven











2022-03-25

自强考试：
1、添加guc参数，启动数据库并打印相关配置信息；
2、对数据库指定内容进行替换；


配置项说明：
replacetext:配置项名称
testdatabae:指定的数据库名称
scla:指定数据列名称
secret:需要替换内容
xxxxxx:替换后输出内容

replacetext = "uxdb,scla,secret,xxxxxx"

测试过程：

create table testdatabase(sno int, snamea char(20), scla varchar(8000));
insert into testdatabase values(1, 'zhangsan', 'top-secret');
insert into testdatabase values(2, 'lisi', 'confidential');
insert into testdatabase values(3, 'wangwu', 'secret');
insert into testdatabase values(4, 'zhaoliu', 'secret');



insert into testdatabase values(5, 'secret', 'secret');

select scla from testdatabase;



((Form_ux_attribute *)slot->tts_tupleDescriptor->attrs).attname.data

NameStr(slot->tts_tupleDescriptor->attrs->attname)



数据库：
MyProcPort->database_name


2022-03-28

1、pgpool链接：

http://www.manongjc.com/detail/21-yrviykughdzydkb.html


2022-03-29

insert into ux_cast values(17098,9002,'BIGINT'::regtype,0,'i','i');
隐士转换可以通过以下方式
首先通过 select max(oid) from ux_cast; 获取最大oid，



checkRuleResultList

./initdb  -D data -Atrust --enable_rowid --running-mode=compatible
create table tb(id int);
insert into tb values(1);

create view v_test(col1) as select rowid from tb;



2022-03-30
申威平台打包
1、
10.1.106.183   root/Uxsino@2021  uxdb/Uxsino@2022


10.1.106.181   root/Uxsino@2021  uxdb/Uxsino@2022



如何确定系统版本
1、查看平台信息
lsb_release -a			//查看平台信息（eg：centos或kylin操作系统）
cat /etc/issue			//查看平台信息

2、查看cpu信息
lscpu
cat /proc/cpuinfo


　　--build=编译该软件所使用的平台		//使用uname -i
　　--host=该软件将运行的平台
　　--target=该软件所处理的目标平台


申威编译报错：
1、
./configure --build=arm-linux

2、修改源
/etc/apt/sources.list

deb http://sh-packages.chinauos.com/server-enterprise/1030 fou/sp3 main contrib non-free

3、readline 未找到
configure: error: readline library not found

sudo apt-get install -y libreadline-dev

4、openssl

RedHat Fedora 平台 
yum -y install openssl-devel 

Debian ,ubunu 平台 
apt-get install libssl-dev

5、configure: error: libcurl not found

sudo apt-get install libcurl4-openssl-dev

6、解决安装报错
mvn使用
https://blog.csdn.net/daodan988/article/details/51535644

7、
uxdb-std-Neo6-x86_64-v2.1.1.4.064.p1.run
uxdb-std-Neo6-x86_64-v2.1.1.4.064.p1.run-b3748211f4a1dc9c6bc9517623e1178f.md


apt-get命令：
1、搜索readline软件
sudo apt-cache search readline



2022-04-01

uxdb-server-linux7-2.1.0.4.02s-SECURITY.tar.gz


报错节点：
SHA-1: 6e3dbe1289802d3bbe9c3b8dcab8da6b7c49a12d

* Merge branch 'bug/ver2.1.0.4s_dev/#99638' into 'dev/ver2.1.0.4s_dev'

#99638 解决uxop用户备份还原表、schema、数据库失败，提示SET TRANSACTION ISOLATION LEVEL的问题

See merge request db/uxdb-ng!2658


2022-04-02

修改函数：
mod,round,nvl,trunc,decode,to_number,to_date

trunc不知道类型：
I_FREE_RES_QUERY_392_202102

562 - 583
测试步骤：


select mod(101::varchar,'10');
select round('1'::interval);			//兼容模式返回interval类型
select nvl(1::numeric,1::integer);

select decode(1::smallint, '2012'::integer, '24', '2012-01-02');
select TO_NUMBER('123.45'::interval);		//兼容模式下不存在这个问题



未修改函数：

listagg							//目的：将列转为行
grouping_id						//未实现
regexp_like						//未实现
pg_backend_pid					//未实现
chartorowid
userenv							//

function add_months				//在oracle模式下已经存在
months_between					//在oracle模式下已经存在
last_day						//在oracle模式下已经存在
to_char							//已实现

已完成函数：
mod,round,nvl,trunc,decode,to_number,to_date，
add_months、months_between、last_day、 to_char

处理问题：
listagg        			//有序聚集函数的直接参数必须使用分组列GROUP BY 
grouping_id         
regexp_like          	//
pg_backend_pid       	//可以使用
chartorowid
userenv   

336979 ERROR: date out of range: "20211122"
150163 ERROR: value for "yyyy" in source string is out of range Detail: Value must be in the range -2147483648 to 2147483647.
1029003 all（）用法
1058106 ERROR: value "100006050057" is out of range for type integer
239176 ERROR: CASE types integer and interval cannot be matched

to_date函数报错修改：
https://222.212.87.87:10943/db/uxdb-ng/merge_requests/4162/diffs#b2975fb7cb2248aafd11fe58ac3c2cd8943ba258

regexp_like函数相关功能实现：
https://222.212.87.87:10943/db/uxdb-ng/merge_requests/2343



listagg:
create table tc(id text,name text);
select listagg(id || ':' || id || '/' || name || ',') within group(order by id) from tb;
select listagg(id || ':' || id || '/' || name || ',')  within group(order by id::text) over(order by id)from tb;

to_char：
CREATE FUNCTION ux_catalog.to_char(text)
RETURNS varchar
AS 
$$
  select $1;
$$
LANGUAGE sql;
COMMENT ON FUNCTION ux_catalog.to_char(text) IS 'Convert text to string';

兼容模式已支持以下函数：round、TO_NUMBER、to_date
以下函数实现在oracle模式下：add_months、months_between、last_day

CREATE FUNCTION add_months(TIMESTAMP WITH TIME ZONE,INTEGER)
RETURNS TIMESTAMP
AS $$ SELECT (ux_catalog.add_months($1::ux_catalog.date, $2) + $1::time)::oracle.date; $$
LANGUAGE SQL IMMUTABLE STRICT;



TIMESTAMP		//without 无时区
timestamptz		//有时区



规约冲突：

      | c_expr MOTH_P
        {
          $$ = makeNode(ResTarget);
          $$->name = $2;
          $$->indirection = NIL;
          $$->val = (Node *)$1;
          $$->location = @1;
        }
















create function sfunc_listagg(text[], text)
returns int[] as
$$
begin
	return $1 || $2; 
end;
$$
language pluxsql;

create function final_listagg(text[], text)
returns int[] as
$$
declare 
	len int := 0;
begin
	return $1;
end;
$$
language pluxsql;

CREATE AGGREGATE listagg(text order by text)
{
	sfunc = sfunc_listagg,
	stype = text[],
	finalfunc = final_listagg,
	initcond = '{''''}'
};



create function fin_mid(int[], real)
returns int as
$$
declare
len int := 0;
begin
len = array_length($1, 1);
return $1[round(len*$2)];
end;
$$
language pluxsql;

//list_agg实现（实现列转行）：
create table tb(id text,name text);

insert into tb  values('4', 'eee');
insert into tb  values('1', 'aaa');
insert into tb  values('2', 'bbb');
insert into tb  values('3', 'ccc');
insert into tb  values('5', 'fff');



create table oracle.ux_order_by_list_agg(data text , sort text);


create function ux_catalog.sfunc_listagg(flag int, text, text)
returns int as
$$
begin
	insert into oracle.ux_order_by_list_agg values($2, $3);
	return 0;
end;
$$
language pluxsql;

create function ux_catalog.final_listagg(falg int, text, text)
returns text as
$$
declare
	result text := '';
begin
	select listagg(data) into result from oracle.ux_order_by_list_agg order by sort;
	delete from oracle.ux_order_by_list_agg;
	return result;
end;
$$
language pluxsql;

CREATE AGGREGATE oracle.listagg(text, text order by text)
(
	sfunc = sfunc_listagg,
	stype = int4,
	finalfunc = final_listagg,
	initcond = 0
);



create function fin_mid(int[], real)
returns int as
$$
declare
len int := 0;
begin
len = array_length($1, 1);
return $1[round(len*$2)];
end;
$$
language pluxsql;

//中位数：

create function gen_arrary(int[], int)
returns int[] as
$$
begin
	return $1 || $2; 
end;
$$
language pluxsql;

create function fin_mid(int[], real)
returns int as
$$
declare 
	len int := 0;
begin
	len = array_length($1, 1);
	return $1[round(len*$2)];
end;
$$
language pluxsql;

CREATE AGGREGATE mid(real order by int)
(
	sfunc = gen_arrary,
	stype = int[],
	finalfunc = fin_mid,
	initcond = '{0}'
);






2022-04-12


1、身份鉴别：

PerformAuthentication

ClientAuthentication

ux_class_aclcheck(Oid table_oid, Oid roleid, AclMode mode)

标记：
mac_create_policy

mac_set_user_label

mac_apply_row_policy
mac_set_column_label

mac_drop_row_policy
mac_drop_column_label
mac_drop_user_label

4、强访

mac_compare_label

5、
log_audit_event


insertlogs_to_uxdb(char **data, int batch_size, char *next_filename, int *last_datasize)

_bt_check_unique(Relation rel, BTInsertState insertstate, Relation heapRel,
				 IndexUniqueCheck checkUnique, bool *is_unique,
				 uint32 *speculativeToken)


static bool
ri_PerformCheck(const RI_ConstraintInfo *riinfo,
				RI_QueryKey *qkey, SPIPlanPtr qplan,
				Relation fk_rel, Relation pk_rel,
				TupleTableSlot *oldslot, TupleTableSlot *newslot,
				bool detectNewRows, int expect_OK)

SPI_processed

ResultRelInfo *relationInfo, TupleTableSlot *slot, EState *estate

ExecConstraints(ResultRelInfo *resultRelInfo,
				TupleTableSlot *slot, EState *estate)

BlockNumber blocknum, char *buffer
mdextend

secure_raw_read(Port *port, void *ptr, size_t len)

int64 get_min_tblspace_size(Oid tblspc_oid)
min_space_size
表空间最小限额

check_password(const char *username,
			   const char *shadow_pass,
			   PasswordType password_type,
			   Datum validuntil_time,
			   bool validuntil_null)

InitializeSessionUserId(const char *rolename, Oid roleid)

void
hba_getauthmethod(hbaPort *port)

UXDB-IF-

_bt_check_unique(Relation rel, IndexTuple itup, Relation heapRel,
				 Buffer buf, OffsetNumber offset, ScanKey itup_scankey,
				 IndexUniqueCheck checkUnique, bool *is_unique,
				 uint32 *speculativeToken)

ri_PerformCheck(const RI_ConstraintInfo *riinfo,
				RI_QueryKey *qkey, SPIPlanPtr qplan,
				Relation fk_rel, Relation pk_rel,
				HeapTuple old_tuple, HeapTuple new_tuple,
				bool detectNewRows, int expect_OK)
				
void getSession(
        const char* strSessionId,		会话id
        long lSessionLineNum,			会话个数
        const char* strProcessId,		进程id
        const char* strSessionStartTime,		会话开始时间
        const char* strUserName,			用户名
        const char* strDatabaseName,		数据库
        const char* strApplicationName,		应用名称
        const char* strConnectionFrom,		链接地址
        const char* strCommandTag,			命令
        const char* strErrorSeverity,		严重错误信息
        const char* strLogTime,				日志时间
        const char* strMessage)				日志信息	
		
		

month


2022-04-14

https://blog.csdn.net/deniro_li/article/details/103745618

hh12	//时分秒正常
hh24
mi
ss
ms
us
ssss

tzh
tzm

mm
ddd
iddd
dd
d			//一周的星期几
id
iw			//iso标准的年中的第几周
q			//季度
cc			//第几世纪，格式两位

yyyy		年正常
yyy
yy
y

w		当月第几周(未实现)
j		从公元前 4713 年 1 月 1 日至今，已经经过多少天。

select to_date(20211122113001,'yyyy-mm-dd  hh24:mi:ms');


ddd:表示当年第几天
select to_date(20222,'yyyy-ddd');


ddd
select to_date(20211122113001,'yyyy-ddd  hh24:mi:ss');

w:
select to_date(20220412,'yyyy-mm-dd w hh24:mi:ms');

cc：第几世纪，格式两位
select to_date(21,'cc');

tzm：
select to_date(202111221130011,'yyyy-mm-dd  hh24:mi:ms tzm');
tzh：
select to_date(202111221130011,'yyyy-mm-dd  hh24:mi:ms tzh');





表示day的：dd 表示当月第几天；ddd表示当年第几天；dy 当周第几天 简写 比如星期五或者fri；day当周第几天 全写













bison -v ora_gram.y




函数：

1、获取随机数函数：
random()


2022-04-15
JYJT涉密改造沟通群（#140293）

nhibernate

nhibernate + spring mvc的demo

nhibernate 介绍：
https://blog.csdn.net/sufu1065/article/details/80116384

https://www.cnblogs.com/vipstone/archive/2011/09/15/2177830.html

nhibernate + spring
https://blog.csdn.net/wb09100310/article/details/46778773

spring学习笔记：
https://www.cnblogs.com/GoodHelper/archive/2009/11/20/SpringNet_Index.html

nhibernate + spring整合：
https://wenku.baidu.com/view/ad9c0e3467ec102de2bd89c4.html


demo:
https://www.cnblogs.com/dongteng/p/8378650.html

访问数据库配置：
https://blog.csdn.net/zhangxian_engineer/article/details/6313970

关联单子：
105978

不兼容报错；
需要迁移；

确定下是不是vs2008搭建的
cs工程文件是哪个？

Console.WriteLine("---------数据库链接成功！")


Npgsql-1.0：
Error thrown by a dependency of object 'Npgsql-1.0' defined in 'assembly [Spring.Data, Version=1.3.0.20214, Culture=neutral, PublicKeyToken=65e474d141e25e07], resource [Spring.Data.Common.dbproviders.xml] line 683' :
 Unsatisfied dependency expressed through constructor argument with index 2 of type [System.Type] : 
 Could not convert constructor argument value [Npgsql.NpgsqlConnection, Npgsql, Version=1.0.0.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7] to required type [System.Type] : Cannot convert property value of type [System.String] to required type [System.Type] for property ''.
while resolving 'constructor argument with name dbmetadata' to 'Spring.Data.Common.DbMetadata#15D72B1' defined in 'assembly [Spring.Data, Version=1.3.0.20214, Culture=neutral, PublicKeyToken=65e474d141e25e07], resource [Spring.Data.Common.dbproviders.xml] line 683'



 <constructor-arg name="connectionType" value="Npgsql.NpgsqlConnection, Npgsql, Version=1.0.0.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7"/>
 <constructor-arg name="connectionType" value="System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
 
 <constructor-arg name="connectionType" value="Npgsql.NpgsqlConnection, Npgsql, Version=1.0.0.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7"/>
 
类型转换问题：
发生这一错误的主要原因是connectionString类型为system.string，但spring.data中的类型是system.type,
无法将类型 [System.String] 的属性值转换为属性所需的类型 [System.Type]，最终导致了这个错误。
方案一：
对类型进行转换，但存在对框架语法不熟悉
方案二：
通过升级新组件方式，正在进行



spring.data:
定义变量：
https://www.springframework.net/doc-latest/reference/html/dbprovider.html


类型转换问题：

MVC3+NHibernate2.1+Spring.NET1.3

问题：存在connectionString类型为system.string，但spring.data中的类型是system.type,
无法将类型 [System.String] 的属性值转换为属性所需的类型 [System.Type]，最终导致这个错误。

分析结论：
1、升级新组件方式：原框架组件（MVC3+NHibernate2.1+Spring.NET1.3），升级新框架组件（MVC4+NHibernate3.3+Spring.NET2.0）后，问题依然存在，
通过查看spring源码，Npgsql相关代码没有差别，故该问题与组件版本应该没啥关系。
2、通过分析mysql，该问题应该与dll版本号有关，spring.data框架中version存在该版本号，则正常，如不存在，则mysql也会报该报错；
eg：引入mysql-5.2.3 ddl动态库，由于spring.data框架中存在该版本，故正常，如删除mysql-5.2.3 ddl动态库，则存在该类型转换问题；
通过查看spring.data框架中Npgsql相关版本号，分别是：
1.0.0.0
1.98.1.0
2.0.0.0
然后查看Npgsql源码版本号，最低版本号为2.0.12.0，照这样看该框架与Npgsql无法适配，可能需要对spring框架进行修改，
所以师伟你那边可否找个熟悉这个框架的，去看下这个问题，我这边是没辙了；


该问题属NHibernate与spring框架问题，你那边可否找个熟悉这个框架的，去看下这个问题，

Npgsql：
1.0.0.0
1.98.1.0
2.0.0.0

<db:provider id="DbProvider" provider="Npgsql-2.0" connectionString="Data Source=${db.datasource};Database=${db.database};User Id=${db.user};Password=${db.password};"/>


<entry key="connection.driver_class" value="NHibernate.Driver.NpgsqlDriver" />
<entry key="dialect" value="NHibernate.Dialect.PostgreSQLDialect" />


1、MVC+NHibernate+Spring+ .NET适配：

目前需要写一个nhibernate + spring mvc的demo，
框架这边我已经搭好了，但是进行适配时，
会报一些框架上的报错，
需要对这个nhibernate + spring mvc框架熟悉的同事协助下

    <add  key = "db.datasource"  value = "192.168.0.137" />
    <add  key = "db.user"  value = "uxdb" />
    <add  key = "db.password"  value = "123456" />
    <add  key = "db.database"  value = "postgres" />
	
Data Source=${db.datasource};Database=${db.database};User Id=${db.user};Password=${db.password};

connectionString="Host=${db.datasource};Database=${db.database};Username=${db.user};Password=${db.password}"

   <db:provider id="DbProvider" provider="Npgsql-2.0" connectionString="Host=192.71.0.137;Database=uxdb;Username=uxdb;Password=123456" />

2、Mono.Security.dll

npgsql3x版本之后再没有Mono.Security.dll这个库


2022-04-22

1、top关键字，建表语句字段是关键字，在创建表的时候失败，给关键字加上双引号可建表成功，但后台程序调用的时有该字段的调用，调用时提示“语法错误，在“top”或附近”
2、运算符调用时支持<=  ，不支持 <   = ，两个运算符中间含有空格，在调用时提示“语法错误在“=”或附近的”
3、start with …connect by 递归调用，适配过程中含有递归调用，数据库暂不支持start with递归调用，提示“语法错误在“start”"或附近
4、无效的类型numeric输入语法"null"

1.  top 关键字， 已有解决方案， 对于 使用百分比的场景需要做函数单独理。 研发开销2人天
2.  更改词法解析， 加上后续测试   研发开销3人天
3.  用 pg 的 with  recusive  语法替换解决。  已有部分工作， 对于简单场景  研发开销3人天
4.   已有方案， 研发开销2人天。 

<=语法：
select * from tb where id < =2;	
支持的：
 <>
 >=
 <=
 ||		//链接

不支持的：
 ->				//无json这个类型


 &&				//无这个操作符

 @@				//圆中心，无这个操作符
 <^				//uxdb不存在该操作符
 >^				//uxdb不存在该操作符

 <<				//无这个操作符
 >>				//无这个操作符
 ##				//无这个操作符

 ?#				//无这个操作符
 ?-				//无这个操作符
 ?|				//无这个操作符
 @>				//无这个操作符
 <@				//无这个操作符
 ~=				//无这个操作符

 &>				//无这个操作符
 

 |/				//无这个操作符
 &<				//无这个操作符
 !!				//阶乘，无这个表达式


 ~*				//无这个操作符
 !~				//无这个操作符
 ?&				//无这个操作符
 #-				//无这个操作符
 @?				//无这个操作符
 *>				//对record类型结果进行比较
 *<
 *=
 ^@				//无这个操作符，等效于starts_with
 ~~				//无这个操作符，等效于like
 
2022-04-25

top关键字，建表语句字段是关键字，在创建表的时候失败，给关键字加上双引号可建表成功，但后台程序调用的时有该字段的调用，调用时提示“语法错误，在“top”或附近”

create table tb(id int, top int);
create table tb(id int, "top" int);
insert into tb values(1,1);
insert into tb values(1,2);

select * from tb where  top = 1;
select * from tb where  "top" = 1;


create table test(id int, name text);

insert into test values(11, 'b');
insert into test values(22, 'a');
insert into test values(33, 's');
insert into test values(44, 'h');
insert into test values(55, 'w');
insert into test values(6, 'f');
insert into test values(7, 'q');


2022-04-25

top关键字为RESERVED_KEYWORD，故对于字段名的引用需要添加双引号进行引用，
改为UNRESERVED_KEYWORD后，无需进行标识，即可识别为字段名。

由于top关键字在语法上与字段名冲突，故在top语法为空时，存在移进、规约冲突，
故修改top语法，对于top语法与非top语法分开使用，但当top语句为空时，由于top有括号语法，
所以top可能被识别为函数，故存在‘（’移进、规约冲突,通过添加top关键字优先使用解决



#143313：top关键字，建表语句字段是关键字，在创建表的时候失败

top关键字为RESERVED_KEYWORD，故对于字段名的引用需要添加双引号进行引用，
改为UNRESERVED_KEYWORD后，无需进行标识，即可识别为字段名。

由于top关键字在语法上与字段名冲突，故在top语法为空时，存在移进、规约冲突，
故修改top语法，对于top语法与非top语法分开使用，但当top语句为空时，由于top有括号语法，
所以top可能被识别为函数，故存在‘（’移进、规约冲突,通过添加top关键字优先使用解决

bison基本概念及语法介绍
https://blog.csdn.net/weixin_46222091/article/details/105990745

2022-04-26

create table tb(name number);

oracle jdbc使用方法：
https://blog.csdn.net/weixin_45595683/article/details/112545805

jdbc的使用：
将jar包解压，解压了以后把  com 文件夹和MainTest.java文件放在同一个路径，然后编译执行：

MainTest.java文件在139机器的jdbc路径下：
/home/uxdb/script/uxdb/jdbc
java编译：
eg：编译MainTest.java
编译：javac MainTest.java
执行：java MainTest



2022-04-27

support/#139826
打包要求：
root登录
internal



uxdb-std-kylin10-arm64-v2.1.1.4.014.p2.rpm
uxdb-std-kylin10-arm64-v2.1.1.4.014.p2-c928f322f09bf8476202dd92596b3536.md

2022-05-06

解决版本问题：

1、首先查看系统是否兼容
2、如果不兼容的话，寻找解决方案，查看是否修改代码

windows编译c文件
使用命令：
CL.exe proc.c /I"D:\uxdbinstall_1\include" /link /LIBPATH:"D:\uxdbinstall_1\lib" mylib.lib

windows编译postgres

1、进入src\tools\msvc路径，执行build.bat
2、编译后跑回归测试，perl vcregress.pl check

MSBuild.exe uxsql.sln /p:Configuration=Debug /p:Platform="Win32"

windows win32编译过程：
1、需要先编译uxfs
1）uxdb-ng\uxdb-2.1\src\tools\msvc\config_default.pl文件需要修改 nouxfs => 1
2）uxdb-ng\uxfs-1.0\nouxfs 编译libxtreemfs4c.lib库
修改build_nouxfs.bat脚本，
cmake ../ -G "Visual Studio 16 2019" -A "x64"
devenv /rebuild "Release|x64" nouxfs.sln

上面x64位win64编译，win32编译将x64改为win32，最终生成libxtreemfs4c.lib库；


2、编译uxdb

1）修改文件
修改文件 uxdb-ng\uxdb-2.1\src\include\ux_config.h.win32	
#define CONFIG_LICENSE_TYPE INTERNAL_LICENSE_TYPE		//表示不带license

2）进入msvc执行build编译
执行脚本：D:\workspace\uxdb-ng\uxdb-2.1\src\tools\msvc\build.bat
之后在
uxdb-ng/uxdb-2.1 目录下执行：
MSBuild.exe uxsql.sln /p:Configuration=Release /p:Platform="Win32"


3、win32的相关库路径
D:\mywork\mywork_2023\南京28所\Win32

4、wins查看动态库的信息，可以看到动态库是多少位的
dumpbin /HEADERS D:\uxdbinstall\dbsql\bin\zlib1.dll

5、uxdb报错：uxcrypto.vcxproj工程提示报错：

openssl.obj:error LNK2019:无法解析的外部符号 _OpenSSL_add_all_algorithms

修改方法：
contrib/uxcrypto/openssl.c
# if OPENSSL_API_COMPAT < 0x10100000L
_OpenSSL_add_all_algorithms();
#endif




linux编译问题：
1、configure报错，查看config.log文件确定问题；
2、如果是缺少库的问题，直接安装库文件
3、如果是未定义问题，查看对应库中是否定义函数名
通过nm -C 查看静态库符号：
nm -C /home/uxdb/uxdb-ng/uxdb-2.1/../thirdparty/stalib_install/xml2_install/lib/libxml2.a |grep fcntl
通过objdump -T查看动态库符号：
objdump -T /lib64/libc-2.17.so |grep fcntl

可能问题是版本不匹配，换取与系统版本匹配的源；






windows编译问题：

1、编译win32提示报错： D:\workspace\uxdb-ng\uxdb-2.1\uxsql.sln.metaproj : error MSB4126: 指定的解决方案配置“Release|x86”无效。请使用 Configuration 和 Platform 属性指定有效的 解决方案配置(例如 MSBuild.exe
解决方法：
uxdb-ng/uxdb-2.1 目录下执行：
MSBuild.exe uxsql.sln /p:Configuration=Release /p:Platform="Win32"

2、编译文件修改

软件安装目录：C:\Software
编译依赖文件所在目录：D:\uxdb_external
代码目录：D:\workspace\uxdb-ng

使用说明：
1）、进入 D:\workspace 目录，命令行执行 Env.bat 脚本准备编译环境；

2）、进入 uxdb-ng\uxfs-1.0\nouxfs(第4步中config_default.pl文件需要修改 nouxfs => 1) 编译nouxfs库；

3）、按需修改 uxdb-ng\uxdb-2.1\src\include\ux_config.h.win32（版本、license类型）,
   uxdb-ng\uxdb-2.1\src\tools\msvc\config_default.pl（编译依赖） 等文件；

4）、进入 uxdb-ng\uxdb-2.1\src\tools\msvc 目录，命令行执行 build.bat 进行编译；

6、编译成功之后可以执行 install.bat XXX（安装路径，例如D:\uxdbinstall，最好指定非系统路径，避免写入权限问题）
   进行安装，测试使用；或者直接在 uxdb-ng\uxdb-2.1\tmp_install 路径下进行测试使用。


windows编译使用dll方法：
https://blog.csdn.net/u012633319/article/details/113666273

注意点：
工程引用编译的dll，需要将dll拷贝到工程编译路径下；




windows版本历史：
winxp、（2001/10/25）
win2008、（2008/2/27）
win7、（2009/10/22）
win8、（2012/10/26）
win10 （2015/07/29）



头文件：
C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt
C:\Program Files (x86)\Windows Mobile 5.0 SDK R2\PocketPC\Include\Armv4i


rownum报错：

set ora_grammar to on;
select ux_backend_pid();
 
SELECT ROWNUM  FROM t1_rn  WHERE ROWNUM <= 5;


standard_planner
	subquery_planner
		grouping_planner
			preprocess_limit


今日进展：
1、解决了win 32 xp环境下初始化出错的问题
2、兼容功能问题调查，已经明确是rownum问题，其余兼容功能及兼容模式运行正常
3、图形化安装工具测试（目前发现在win xp32 、win 2008R2 环境下，会卡住，等于初步适配有问题） -> 目前还未让工具同事介入

后续计划（4日内）：
1、解决32位环境下 rownum 问题（已完成）
2、依次针对 win xp 32位、win 2008 R2 x64 进行打包测试。
3、针对 win 7 x64、 win 8 x64、win 10 x64 使用现有包进行打包测试（带图形化安装工具），确认基本测试通过后，再进行免license打包。

分支：
win xp：
support/#144088_for_winxp32

win x64：
hotfix/ver2.1.1.4p
#support/ver2.1.1.4p


%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin

Java\jre1.8.0_221

uxdb-std-win-x86_32-v2.1.1.4-56-01-winXP.zip
uxdb-std-win-x86_32-v2.1.1.4-56-01-win7.zip


uxdb-std-win-x86_64-v2.1.1.4-19-p2.exe

uxdb-std-win-x86_64-v2.1.1.4-19-p2-1fb5d8292c8a082e7ebd643eea7970c7.md

uxdb-std-win-x86_32-v2.1.1.4-19-p2-winXP.exe
uxdb-std-win-x86_32-v2.1.1.4-19-p2-win7.exe


打包：

call izpack_pkg_cmd.bat 2.1.1.4 standard 

cacls "C:\code" /E /G uxdb:F
cacls "C:\code\uninstaller" /E /G Administrator:F

cacls "%installDir%" /E /G %username%:F
cacls "%installDir%\uninstaller" /E /G Administrator:F


winxp安装时存在setx命令设置失败报错，setx命令用于设置环境变量，
winxp不支持该命令，需要手动添加下环境变量；

下面这些库会影响哪些功能：
OpenSSL-Win64
libxml2-2.9.8
libxslt-1.1.32
iconv-1.11.1
zlib-1.2.7
gettext-tools-dev_ext_0.18.1.1-2_win64


2022-05-26

1、由触发器造成的，id是触发插入的
insert into tb values(1) returning id;
2、String sql = "select user_id from mail_index where id = ?";
   DatabaseHelper helper = DB.getInstanceSQLite(dbPath);
   userId = helper.queryColumn(sql,"user_id",id);
然后id的值是3fe98d9d-0b93-4346-bbbb-c17c2303a7a6

3、使用别名，没有加as（问题单：85040）


1、第一个问题是触发器造成的，那触发器语句是啥，触发器语句是否对字段带双引号？（还有706开发已经在改了，）
2、第二个问题是类型转换问题吗？ （uxobject 转换string应用报错？）
3、改造语法， 加上后续测试，研发开销3人天


后续开发测试时间，不涉及系统测试，只是开发这边自测时间；


CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$ 
declare i int;
    BEGIN 
        INSERT INTO TB1(ID) VALUES (1) returning "id" into i; 
        RETURN NEW;  
    END; 
$example_table$ LANGUAGE pluxsql;


CREATE TRIGGER example_trigger AFTER INSERT ON TB 
FOR EACH STATEMENT EXECUTE PROCEDURE auditlogfunc();


insert into tb values(1);



数据库后端sql：INSERT INTO TB1(id) VALUES (1) returning "id";
错误:  字段 "id" 不存在 第 42 个字符处
语句:  INSERT INTO TB1(id) VALUES (1) returning "id";

触发器：
错误:  字段 "id" 不存在 第 42 个字符处
查询:  INSERT INTO TB1(ID) VALUES (1) returning "id"
上下文:  在SQL语句的第4行的PL/uxSQL函数AUDITLOGFUNC()
语句:  insert into tb values(1);

jdbc：
错误:  字段 "column1" 不存在 第 50 个字符处
语句:  insert into jdbc_tb_numeric values($1) returning "column1"


1、returning id，id不存在报错分析，通过创建触发器，链接jdbc构造returning id，
报错非触发器导致，insert语句可能在jdbc做了改造；

3、别名加不加as都无法插入，需实现该语法功能；

1、returning id这个问题，通过对比触发器，链接jdbc构造returning id，
根据现场报错信息，报错应该是jdbc对输入sql做了改造导致；

2、

3、insert插入时字段引用别名，别名加不加as都无法插入，所以现场需求是否是insert 插入时字段引用别名；


insert all 
into table1(id) values(1)
into table2(id) values(1)
select * from dual;
http://download.oracle.com/docs/cd/B19306_01/server.102/b14200/statements_9014.htm#SQLRF01604




create table UserInfo
(
UserId int primary key ,
UserName varchar(20),
password varchar(20) not null
);

create table UserDetails
(
id int  primary key,
name varchar(50) not null,
userId int,
foreign key (userId) references UserInfo(UserId)
);


insert into UserInfo values (1,'jeff','aaa');
insert into UserInfo values(2,'wzqwzq','bbb');
insert into UserInfo values(3,'lglg','ccc');
insert into UserDetails values(3,3,3);


delete FROM UserInfo where UserId=3;

客户那边使用的还是之前的框架，由于spring+NHibernate框架存在卡住问题，
客户那边创建了demo工程进行验证；

Npgsql，主键、外键索引报错卡住问题：
问题分析：
通过分析，版本适配问题，
分析Npgsql2.0.12.0版本之前对ExecuteNonQuery未做适配，
故2.0.12.0之前版本都存在这个问题，

解决方案：
由于uxdb目前驱动适配使用2.2.3版本，
所以对2.2.3版本Npgsql版本号做了适配，目前验证未发现异常；



但spring+NHibernate框架版本较低，只适配2.0.0
但spring+NHibernate框架版本较低，只适配2.0.0，
由于框架名称与版本号固定的，对应Npgsql，


2022-05-31

php手册：
https://www.php.net/manual/zh/book.pgsql.php


2022-06-01
Npgsql:
EntityFramework6(EF6)连接Postgresql数据库：
https://blog.csdn.net/carcarrot/article/details/105574477

dotnetcore 缺 动态库，原dotnet依赖库不支持
https://blog.csdn.net/u012122318/article/details/81809653

.net.core驱动Npgsql：
https://blog.csdn.net/Chen_Victor/article/details/61196160?utm_source=blogxgwz5

.net core工程搭建：

.net.core实战实例一：
https://www.jianshu.com/p/bc489b8966a9

使用以下命令链接数据库：
Scaffold-DbContext "Host=192.71.0.137;Database=uxdb;Username=uxdb;Password=1" Npgsql.EntityFrameworkCore.PostgreSQL -OutputDir Models

msi 解压命令msiexec
msiexec /a  "F:\git\Npgsql-4.0.9.msi" /qb TARGETDIR="F:\git\npgsql"


Npgsql.EntityFrameworkCore.PostgreSQL 示例：
https://www.npgsql.org/efcore/index.html


Benchmark工具使用：
https://blog.csdn.net/penriver/article/details/122276382


uxdb最优参数配置，共享内存最大128GB：
max_connections = 1024
shared_buffers=40GB
maintenance_work_mem=8GB
wal_buffers=1GB
effective_cache_size=64GB
bgwriter_delay = 100ms
bgwriter_lru_maxpages = 500
bgwriter_lru_multiplier = 5.0
effective_io_concurrency = 0
synchronous_commit = off
max_wal_size = 32GB
min_wal_size = 4GB
random_page_cost = 1.1
fsync = off
checkpoint_timeout = 30min

hot_standby = on
max_wal_senders = 3
wal_keep_segments = 64
full_page_writes = on
wal_log_hints = on

最有参数修改：
shared_buffers=64GB
maintenance_work_mem=4GB
wal_buffers=1GB
max_wal_size=4GB
effective_cache_size=64GB
autovacuum = on
autovacuum_naptime = 1380min
ora_grammar = on
max_connections = 1000
fsync = off
checkpoint_timeout = 1d
synchronous_commit = off


2022-06-07

1、
CS8618: 在退出构造函数时，不可为 null 的 字段“Read”必须包含非 null 值。请考虑将 字段 声明为可以为 null


2022-06-10

1、层次查询connect by
120066
https://www.pianshen.com/article/2898753313/

2022-06-16

词法语法分析：

flex与bison：
1、flex用作词法分析，bison用作语法分析；

词法分析把输入分解成一个个有意义的词块，称作token；
语法分析则确定这些词块彼此之间如何关联，使用语法树表达；
eg：
A = B + C;
flex将其分解成A、=、B、+、C和;
接着bison将其确定为一个表达式,简化如下：
                +---+
                | = |
                +---+
               /     \
          +---+       +---+
          | A |       | + |
          +---+       +---+
                     /     \
                +---+       +---+
                | B |       | C |
                +---+       +---+



2022-06-21

rowid影响5~6%；




max_connections = 128
shared_buffers=4GB
#maintenance_work_mem=8GB
#wal_buffers=1GB
#effective_cache_size=8GB
#bgwriter_delay = 100ms
#bgwriter_lru_maxpages = 500
#bgwriter_lru_multiplier = 5.0
effective_io_concurrency = 0
synchronous_commit = off
#max_wal_size = 32GB
#min_wal_size = 4GB
random_page_cost = 1.1
fsync = off
checkpoint_timeout = 30min

hot_standby = on
max_wal_senders = 3
wal_keep_segments = 64
full_page_writes = on
wal_log_hints = on

仓数：  warehouses=10   runMins=20

79.4 us

75848bc74411130ede23995d0ab1aefb12c4c4b0
dc7420c2c9274a283779ec19718d2d16323640c0
1f51c17c68d05c28d5b9294d8013cb9e7e653160
941697c3c1ae5d6ee153065adb96e1e63ee11224
5788e258bb26495fab65ff3aa486268d1c50b123
73487a60fc1063ba4b5178b69aee4ee210c182c4
623a9ba79bbdd11c5eccb30b8bd5c446130e521c


win拷贝linux文件格式问题：
1、修改文件
修改格式：
命令行模式执行
：set ff=unix 或者：set fileformat=unix

2、使用dos2unix递归转换文件夹下的格式：
首先安装dos2unix
sudo yum -y install dos2unix

find . -type f -not -path '*/\.*' -exec grep -Il '.' {} \; | xargs -d '\n' -L 1 dos2unix -k
转换为：在当前目录中递归查找所有非隐藏文件，然后使用grep，列出所有非二进制（-I）非空文件，
然后一次将其通过管道传送到xargs（由换行符分隔）中的一个文件至dos2unix并保留原始时间戳。

牵扯其他修改：
Track latest completed xid as a FullTransactionId.


2022-06-24
postgres编译：
./configure  --prefix=/home/uxdb/pginstall/ --with-openssl --with-blocksize=32 

内存消耗计算方法：
https://www.yht7.com/news/129198

工时登记填写：
706项目编号：
JA02903774202220291

公共交通：
A01093500202210484

河南移动：
A01097617202210156

2115系版本工时登记到 < UX010107783202210564 ~UXDB 2022年开发~全立>
2114维护工时 <UX010107783202210543~UXDB 2.1.1.4 版本维护~全立>
对外项目工时填写对应项目编号
其他类工时，继续登记到<UXDB产品线>

2022-06-27

98,632  insert
100 client 100 table

10s 20s 1min





CREATE TABLE persons
(
  id  int,
  name  varchar(255),
  gender  varchar(255),
  idnumber  varchar(255),
  contact  varchar(255),
  remarks  varchar(255),
  province  varchar(255),
  city  varchar(255),
  county  varchar(255),
  town  varchar(255),
  village  varchar(255),
  longitude  numeric(38),
  latitude  numeric(38)
);

INSERT INTO persons VALUES (1, 'Cheese', '男', '123456789', 'nve', 'this is man', 
'shanxi', 'xian', 'china', 'qianba', 'nande', 97.5, 9.99);

./uxbench -c 10 -T 10 -f table.sql
./uxbench -U UXDB -c 10 -T 10 -f table.sql

INSERT INTO persons select 1, 'Cheese', '男', '123456789', 'nve', 'this is man', 
'shanxi', 'xian', 'china', 'qianba', 'nande', 97.5, 9.99 from generate_series(1,100000);

1并发
9065.552214
8887.956140

使用uxbouncer：
Measured tpmC (NewOrders) = 68571.0
Measured tpmTOTAL = 152588.18

未使用uxbouncer：
Measured tpmC (NewOrders) = 553451.79
Measured tpmTOTAL = 1230589.24

进行相同的三轮测试，每轮测试
select数量：171859 
insert数量：98632 
update数量：1974 
delete数量：1043

2022-07-01

兼容性语法：
兼容dm语法实现：
参考手册：
DM8 SQL语言使用手册

兼容oracle使用：
https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/DECODE.html

mysql手册：
https://www.mysqlzh.com/ 

2022-07-04
性能相关记录：
1、性能优化
https://blog.csdn.net/qq_40026782/article/details/109221038?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2-109221038-blog-88997709.pc_relevant_vip_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2-109221038-blog-88997709.pc_relevant_vip_default&utm_relevant_index=3

性能分析：

内存超过55GB时间：
3:30

监控系统数据:
timeout 605800 dstat -tcdmnr --disk-util -N ens33 > 1000ware500terminal_jr.csv 60 &

timeout 1800 dstat -tcdmnr --disk-util -N ens192 > 200ware500terminal_jr_henan_p9.csv 60 &

timeout 7200 dstat -tcdmnr --disk-util -N ens192 > 200ware400terminal_jr_henan_p9.csv 60 &



内存泄漏检测
https://blog.csdn.net/Frederick_Fung/article/details/117529699
valgrind:

valgrind --tool=memcheck --log-file=valgrind%p.txt ./a.out

valgrind --tool=memcheck --leak-check=full ./a.out

使用抑制错误
valgrind --tool=memcheck  --suppressions=./gw.supp --log-file=valgrind%p.txt ./a.out

valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all --trace-children=yes --suppressions=./gw.supp --log-file=valgrind%p.txt ./runBenchmark.sh com_props.pg

$ cat gw.supp 
{
	1
	Memcheck:Value8
	fun:_itoa_word
}
{
	2
	Memcheck:Cond
	fun:vfprintf
}
{
	3
	Memcheck:Cond
	fun:_itoa_word
}

–trace-children=no|yes [no] //如果是yes，被调程序若用exec开启了一个子进程，那valgrind将会追踪此子进程的执行情况
--leak-check=full			//Memcheck跟踪malloc/new函数对应的free/delete等的调用，默认值为summary，
只统计发生了多少次泄漏。如果设置为full或 yes，则每个单独的泄漏将被详细显示或计为错误。

2022-07-06
获取系统性能数据：
在linux执行以下命令（获取cpu与io使用情况）：
nmon -F sys100f.nmon -s 2 -c 10800 
使用工具对nmon生成的sys100f.nmon进行解析：
nmon_analyser_v69

查看进程io占比：
命令：iotop -oP
https://zhuanlan.zhihu.com/p/354809310

iostat -x 1 10	//表示1s打印一次，打10次，结果util表示io百分比；


2022-07-07
1、
Oracle（+）、不等于操作符补充下测试用例

c/c++全数据：
https://www.bilibili.com/video/av374923818


windows dll系统库搜索链接：
https://www.dll-files.com/

windows dll库生成&使用:
https://blog.csdn.net/DeliaPu/article/details/131008103


izpack问题：

注销izpack自启动功能：
ux_ctl.exe unregister -N UxdbServer


2022-07-08

1、windows安装数据库报错：
无法定位程序输入点ucrtbase.terminate




ed2k://|file|mu_windows_7_and_windows_server_2008_r2_sp1_x86_x64_dvd_619642.iso|2048196608|D1D032D20568F9ED16F072075F4E9961|/


发票抬头:
名称：
北京优炫软件股份有限公司
纳税号：
911101086851120558
地址：
北京市海淀区学院南路62号中关村资本大厦11层1111-1113室
电话：
010-82886998
开户行及账号：
北京银行股份有限公司中关村海淀园支行
01091448700120105109956







2022-07-26

报错栈：

#4  0x0000000000533cf3 in RecordTransactionAbort (isSubXact=false) at xact.c:1657
#5  0x0000000000534b85 in AbortTransaction () at xact.c:2706
#6  0x00000000005352e4 in AbortCurrentTransaction () at xact.c:3227





uxdb.c:1436
finish_xact_command:uxdb.c:2792

CommitTransactionCommand
	CommitTransaction
		CSNSnapshotCommit
			CSNLogSetCommitSeqNo

csn未调用函数：
1、CSNSnapshotPrepareCurrent
2、csnlog_desc
3、CSNSnapshotAssignCurrent
4、




报错原因：
CSNSnapshotCommit
assignedCSN = ux_atomic_read_u64(&proc->assignedCSN);  //获取的csn值无效

#0  CSNLogSetCommitSeqNo (xid=517, nsubxids=0, subxids=0x0, csn=18446744073709551615, write_xlog=true)
    at csnlog.c:132
#1  0x0000000000557c64 in CSNSnapshotCommit (proc=0x7f304faa3e68, xid=517, nsubxids=0, subxids=0x0)
    at csn_snapshot.c:664
#2  0x00000000005343d6 in CommitTransaction () at xact.c:2203
#3  0x0000000000534fa5 in CommitTransactionCommand () at xact.c:2955
#4  0x0000000000901f07 in finish_xact_command () at uxdb.c:2792
#5  0x00000000008ffd46 in exec_simple_query (query_string=0x1f59270 "create table t2(id int,b text);") at uxdb.c:1436



代码移植问题记录：
一、未移植代码
diff --git a/src/backend/storage/lmgr/lwlock.c b/src/backend/storage/lmgr/lwlock.c
index 862097352b..1f78161d9a 100644
--- a/src/backend/storage/lmgr/lwlock.c
+++ b/src/backend/storage/lmgr/lwlock.c
@@ -135,6 +135,8 @@ static const char *const BuiltinTrancheNames[] = {
 	"CommitTSBuffer",
 	/* LWTRANCHE_SUBTRANS_BUFFER: */
 	"SubtransBuffer",
+	/* LWTRANCHE_CSN_LOG_BUFFERS */
+	"CSNLogBuffer",
 	/* LWTRANCHE_MULTIXACTOFFSET_BUFFER: */
 	"MultiXactOffsetBuffer",
 	/* LWTRANCHE_MULTIXACTMEMBER_BUFFER: */

2022-08-01

pgpool：
上游服务器:
健康检查：
lifecheck：
故障转移：就是进行主备切换；
仲裁：一种投票机制；


1、watchdog核心:
1、管理和协调本地节点看门狗状态
2、与内置或外部生命检查系统lifecheck交互，用于本地和远程Pgpool-II 节点健康检查。
3、与Pgpool-II主进程进行通讯，通过watchdog执行集群命令；
4、与所有参与的 Pgpool-II 节点通信去协调领导者/协调者节点（leader/coordinator）的选择，并确保集群中的仲裁。
5、管理active/coordinator上的vip，并允许用户提供用于升级和降级的自定义脚本
6、验证watchdog集群中参与的Pgpool-II 节点的Pgpool-II 配置的一致性。
7、在启动时同步所有 PostgreSQL 后端的状态。
8、为 Pgpool-II 主进程提供分布式锁定功能，用于同步不同的故障转移命令。

2、与集群中其他节点通讯：
看门狗使用 TCP/IP 套接字与其他节点进行所有通信。每个看门狗节点可以有两个与每个节点一起打开的sockets，
一个是该节点创建并启动与远程节点的连接的传出（客户端）套接字，
第二个套接字是侦听由远程watchdog节点启动的入站连接的套接字。
一旦与远程节点的套接字连接成功，看门狗就会在该套接字上发送 ADD NODE (WD_ADD_NODE_MESSAGE) 消息。
并且在接收到 ADD NODE 消息后，看门狗节点使用该节点的 Pgpool-II 配置验证消息中封装的节点信息。
如果节点通过验证测试，则会将其添加到群集中，否则连接将断开。

3、IPC和数据格式：
Watchdog 进程公开一个用于 IPC 通信的 UNIX 域套接字，它接受并提供 JSON 格式的数据。
所有的 Pgpool-II 内部进程，包括 Pgpool-II 内置的 lifecheck 和 Pgpool-II 主进程都使用这个 IPC 套接字接口与watchdog进行交互。
该 IPC 套接字也可以被任何外部/第 3 方系统用于与看门狗进行交互。

4、看门狗寿命检查（Watchdog Lifecheck）

看门狗生命检查是看门狗的子组件，用于监控参与看门狗集群的 Pgpool-II 节点的健康状况。
Pgpool-II 看门狗内置了三种远程节点健康检查方法，“心跳”、“查询”和“外部”模式。

在“心跳”模式下，生命检查进程通过 UDP 套接字发送和接收数据以检查远程节点的可用性，
并且对于每个节点，父生命检查进程产生两个子进程，一个用于发送心跳信号，另一个用于接收心跳信号。
在“查询”模式下，lifecheck 进程使用 PostgreSQL libpq 接口来查询远程 Pgpool-II。
在这种模式下，生命检查进程会为每个健康检查查询创建一个新线程，一旦查询完成，该线程就会被销毁。
在“外部”模式下，此模式禁用 Pgpool-II 的内置生命检查，并期望外部系统将监视本地和远程节点。

除了远程节点健康检查外，看门狗 lifecheck 还可以通过监控与上游服务器的连接来检查它安装的节点的健康状况。
为了监控与上游服务器的连接，Pgpool-II lifecheck 使用 execv() 函数执行“ping -q -c3 hostname”命令。
因此，会产生一个新的子进程来执行每个 ping 命令。
这意味着对于每个健康检查周期，都会为每个配置的上游服务器创建和销毁一个子进程。
例如，如果在 lifecheck 中配置了两个上游服务器，并且要求它每隔 10 秒进行一次健康检查，
那么在每 10 秒后，lifecheck 将产生两个子进程，每个上游服务器一个，每个进程将一直存活到 ping 命令完成。


1、心跳检查：
设置参数：heartbeat_destination
配置为对端机器；

2、看门狗配置

远程uxpool节点主机名
other_pgpool_hostname

3、健康检查：
https://blog.csdn.net/weixin_34112208/article/details/90132545#:~:text=health_check_period%20This%20parameter%20specifies%20the%20interval%20between%20the,need%20to%20reload%20pgpool.conf%20if%20you%20change%20health_check_period.
health_check

检测后端数据库，如果网络或服务器异常，执行故障转移；

4、看门狗
1、wd_hostname 	：指定uxpool服务器的ip地址，用于发送/接收查询和数据包；
2、看门狗如何检查uxpool的生命检查（lifecheck）：
看门狗检查的uxpool服务的响应，而不是进程，
通过uxpool发送查询命令到uxdb检查响应情况，
看门狗还检查从uxpool到客户端服务器的链接，用于监控uxpool服务；
配置参数：wd_heartbeat_port
heartbeat_destination检测生命信号的远端uxpool机器；

3、other_pgpool_hostname
监视远程uxpool服务器的ip；

watchdog日志信息：
LOG:  watchdog process is initialized
LOG:  watchdog: escalation started
LOG:  I am the master watchdog node

4、看门狗功能
用于解决单点故障，通过仲裁使故障在处理脑裂和网络分区方面更具容错性，3.7版本引入仲裁故障转移以减少pg服务器故障误报；
pgpool-II 节点的数量必须为奇数，并且大于或等于 3。

a、首先从主watchdog同步所有已配置后端节点的状态，如果uxpool节点继续成为主节点本身，他将在本地初始化后端状态；
b、当后端节点状态因故障转移等改变时，看门狗会将信息通知给其他uxpool并进行同步；
c、发生联机恢复时，watchdog会限制客户端与其他uxpool节点链接，以避免后端之间不一致；
d、与其他uxpool进行协调，以确保故障恢复、故障转移；

5、看门狗（watchdog）的寿命检查（lifecheck），用于监视看门狗集群的uxpool节点运行状况，以提供高可用。
a、心跳模式下，看门狗使用心跳信号定期监视其他uxpool，如果监视失败，看门狗将视为uxpool节点故障；

6、所有uxpool节点配置参数一致









2022-08-02

sql优化计划：

like模糊查询优化：
https://blog.csdn.net/weixin_43922449/article/details/120442352

1、查询优化：
select ux_relation_filepath('t1');
2、查看执行计划：
explain (ANALYZE,VERBOSE,BUFFERS)

执行计划介绍：
https://www.cnblogs.com/duanleiblog/p/13751805.html


1、Index Only Scan
https://www.cnblogs.com/abclife/p/13906623.html
https://wiki.postgresql.org/wiki/Index-only_scans

执行前需要进行vacuum，保证元组数据的可见性，
通过Index Only Scan，可以直接从索引直接输出结果，而无需扫描数据块；

Index Only Scan：包含我们查询语句的所有字段，提取出相应的index，就不必提取数据块了；
Index scan: 输出的是tuple，它先扫描索引块，然后得到rowid扫描数据块得到目标记录。
一次只读一条索引项，那么一个 PAGE面有可能被多次访问。

pg性能优化：
https://blog.csdn.net/pg_hgdb/category_10630706.html
https://www.cnblogs.com/duanleiblog/p/14049247.html#a3

1、like语法优化
https://postgresql.blog.csdn.net/article/details/114123959

2、导入数据优化
https://postgresql.blog.csdn.net/article/details/114585593


性能优化：


查找自上次使用 重置统计信息以来从未使用的索引，重置统计信息函数ux_stat_reset()
SELECT s.schemaname,
       s.relname AS tablename,
       s.indexrelname AS indexname,
       ux_relation_size(s.indexrelid) AS index_size
FROM ux_catalog.ux_stat_user_indexes s
   JOIN ux_catalog.ux_index i ON s.indexrelid = i.indexrelid
WHERE s.idx_scan = 0      -- has never been scanned
  AND 0 <>ALL (i.indkey)  -- no index column is an expression
  AND NOT i.indisunique   -- is not a UNIQUE index
  AND NOT EXISTS          -- does not enforce a constraint
         (SELECT 1 FROM ux_catalog.ux_constraint c
          WHERE c.conindid = s.indexrelid)
ORDER BY ux_relation_size(s.indexrelid) DESC;



PostgreSQL 15版本新特性:
发布时间：2022-5-20号发布
性能提升
PostgreSQL 在最近的多个版本中，一直在持续提升性能，15版本也不例外。此次新版本对大数据集的排序，特别是在数据集大小超过 work_mem参数指定大小时，性能显著提高。

新版本中对各类查询也进行了优化，包括对SELECT DISTINCT指令引入了并行查询功能，对使用row_number(), rank()，count() 等窗口函数也进行了增强。 
现在使用PostgreSQL外部数据封装器postgres_fdw来管理远程数据时，可以并行提交事务。还有多处对分区表查询的性能优化。

PostgreSQL 14版本正式发布：
发布时间：2021-09-30号发布
在高并发、高写入负载、并行查询和逻辑复制等方面的性能提升。
PostgreSQL 14版本中在有大量连接的场景下，大幅提高了事务的吞吐量，在一些测试场景下，最高可达1倍的提升。

PostgreSQL 13正式发布：
发布时间：2020-09-24







CREATE TABLE UXDBC_DBF_CAPITAL_DATESENSITIVE_VIEW_MATVIEW_DELETE_0001_TB01 (ID INT,NAME CHAR(10));
INSERT INTO UXDBC_DBF_CAPITAL_DATESENSITIVE_VIEW_MATVIEW_DELETE_0001_TB01 VALUES (1,'HELLOWORD'),(3,'helloword'),(5,'HELLOword'),(4,'helloword');
CREATE MATERIALIZED VIEW UXDBC_DBF_CAPITAL_DATESENSITIVE_VIEW_MATVIEW_DELETE_0001_VIEW01 AS SELECT * FROM UXDBC_DBF_CAPITAL_DATESENSITIVE_VIEW_MATVIEW_DELETE_0001_TB01;

#150166 

数据库内部对象名长度限制为64位(包含结束符,实际对象名最大为63位)，超过63位会被截断。
按照rowid原有设计，rowid对应的的序列名是在表明的基础上拼接“_UXDB_ROWID_SEQ”构成，
在表名恰为64位时序列名拼接部分丢失，造成rowid序列名与表名相同；
所以在对该表rowid序列名初始化时，由于该序列名与表名相同，识别到该表不是一个序列报错；

2022-08-30





2022-08-31

兼容模式下，两个字符字段，通过jdbc绑定参数插入数据，第一个设置为空串，第二个为null ，
会报 错“insufficient data left in message”

 insert into organ( memo,guidkey ) values('',null);


(gdb) p *input_message
{data = 0x2e6d260 "", len = 20, maxlen = 1024, cursor = 10}


正常：
x/20b msg->data
0x2e6d260:      0       0       0       2       0       0       0       0
0x2e6d268:      0       2       255     255     255     255     0       0
0x2e6d270:      0       0       0       0



2022-09-01
问题单：137770
--release=standard
--version=2.1.1.4
--license=commercial
--extension-adaptor=yes
--block-size=32
--nouxfs
--extended_parameters

./build.sh --release=standard --version=2.1.1.4 --license=commercial --extension-adaptor=yes --nouxfs --extended_parameters


2022-09-05

c语言提高





2022-09-08

explain：

1、explain参数介绍：
analyze 默认为true，会把query实际执行一遍；
VERBOSE 输出结果集的各个列， 输出信息查看Output:
BUFFERS 显示共享缓冲区命中信息；



2、计划树是从下往上执行；
3、输出信息介绍：
Seq Scan  ：全表扫描
Filter: 	过滤条件
Rows Removed by Filter: 表明过滤了多少行数据，属于Seq Scan 节点的VERBOSE 信息，只有EXPLAIN 命令中的VERBOSE 选项为on 时才会显示；
Buffers: shared hit=11 表明了从共享缓存中命中了11 个BLOCK，属于Seq Scan 节点的BUFFERS 信息，只有EXPLAIN 命令中的BUFFERS 选项为on 时才会显示
Planning time: 0.066 ms 表明了生成查询计划的时间
Execution time: 0.160 ms 表明了实际的SQL 执行时间，其中不包括查询计划的生成时间

Index Scan 是索引扫描；
Index Scan using no_index on public.class 表明是使用的public.class 表的no_index 索引对表进行索引扫描的
Index Cond:索引扫描的条件

IndexOnly Scan 是覆盖索引扫描
Heap Fetches 表明需要扫描数据块的个数


BitmapHeap Scan：
把Index Scan 的随机读转换成了按照数据块的物理顺序读取，在数据量比较大的时候，这会大大提升扫描的性能。
可以运行set enable_indexscan =off; 来指定关闭Index Scan 

Bitmap Index Scan on no_index 表明使用no_index 索引进行位图索引扫描
Index Cond: (class.st_no = 2) 表明位图索引的条件为class.st_no = 2
Bitmap Heap Scan on public.class 表明对public.class 表进行Bitmap Heap 扫描
Recheck Cond: (class.st_no = 2) 表明Bitmap Heap Scan 的Recheck操作 的条件是class.st_no = 2，这是因为Bitmap Index Scan 节点返回的是位图，位图中每位代表了一个扫描到的数据块，通过位图可以定位到一些符合条件的数据块（这里是3，Buffers: shared hit=3），而Bitmap Heap Scan 则需要对每个数据块的元组进行Recheck
Heap Blocks: exact=1 表明准确扫描到数据块的个数是1


一般来说：
大多数情况下，Index Scan 要比 Seq Scan 快。但是如果获取的结果集占所有数据的比重很大时，这时Index Scan 因为要先扫描索引再读表数据反而不如直接全表扫描来的快。
如果获取的结果集的占比比较小，但是元组数很多时，可能Bitmap Index Scan 的性能要比Index Scan 好。
如果获取的结果集能够被索引覆盖，则Index Only Scan 因为不用去读数据，只扫描索引，性能一般最好。但是如果VM 文件未生成，可能性能就会比Index Scan 要差。


2022-09-15

1、指针指向字符串常量，常量保存在全局静态数据区，且该数据不能被修改；

2、const修改的变量或指针，表示该变量或指针是只读的；
eg：
const int *p1;
int const *p2;
int * const p3;
在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；
在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。

3、函数参数使用字符串常量， 参数指针指向常量区；

函数指针指向地址被改变：
https://bbs.csdn.net/topics/380023886

2022-09-20

connection_cache

uxpool.conf修改参数：
search_primary_node_timeout				//执行故障切换命令时，查找主节点的时间，当没有活跃节点时，该参数影响健康检查时间；
connect_timeout

set args -n -d > uxpool.log 2>&1
handle SIGUSR1 nostop
b trigger_failover_command


2022-09-21



select * from UX_DEPEND;

add_exact_object_address_extra
测试用例：
create table tb(id int);
create schema so5;
create synonym table so5.test_syn on tb;
drop schema so5;
create synonym table so5.test_syn on tb;


报错：
cannot drop %s because other objects depend on it

REFCLASSID：
REFOBJID：oid

CLASSID | OBJID | OBJSUBID | REFCLASSID |  			REFOBJID
			表oid			模式oid所在表			表依赖的模式oid

生成oid：
GetNewObjectId

插入uxdepend：
recordDependencyOn
	recordMultipleDependencies


同义词删除函数失败：
原因：可能函数有特殊处理，查看UX_DEPEND中的函数依赖关系是怎么建立的？
select * from UX_DEPEND WHERE OBJID = 16775

oid的生成：
https://xiaowing.github.io/post/20171117_pg_knowhow_oid/#:~:text=OID%E7%9A%84%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6%20%E5%BD%93%E4%B8%80%E6%9D%A1%E5%85%83%E7%BB%84%E8%A2%ABINSERT%E5%88%B0%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%97%B6%E5%80%99,%28%E4%B9%9F%E5%8C%85%E6%8B%AC%E8%AF%AD%E6%B3%95%E5%B1%82%E9%9D%A2%E7%9A%84%20UPDATE%20%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%9B%A0%E4%B8%BAPG%E4%B8%AD%E7%9A%84UPDATE%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E5%B0%86%E6%9B%B4%E6%96%B0%E5%89%8D%E7%9A%84%E6%97%A7%E5%85%83%E7%BB%84%E6%A0%87%E8%AE%B0%E4%B8%BA%E6%97%A0%E6%95%88%E5%B9%B6%E6%96%B0%E5%A2%9E%E5%85%83%E7%BB%84%29%E3%80%82



索引添加：
1、
src/include/catalog/indexing.h
添加对应字段索引，例如，给oid添加索引；
2、src/backend/utils/cache/syscache.c
添加cache字段信息
3、src/include/utils/syscache.h
该位置需要与第2步对应，否则编译会报错
4、使用索引SynonymOidIndexOId
	//对rel表随机生成一个oid
	oid = GetNewOidWithIndex(rel, SynonymOidIndexOId,
									Anum_ux_synonym_oid);

2022-09-26

复现问题：

create table tb(exp_date TIMESTAMP WITH TIME ZONE);
insert into tb values(sysdate);
select * from tb where EXP_DATE = (EXP_DATE - 1);
select * from tb where EXP_DATE = (EXP_DATE + 1);
select * from tb where EXP_DATE < '2020-10-11 00:00:00+08'::TIMESTAMPtz + 1;
select * from tb where EXP_DATE > '2020-10-11 00:00:00+08'::TIMESTAMPtz - 1;


这个是已经有TIMESTAMP WITHOUT TIME ZONE 和 int 的操作符了

但是没有TIMESTAMP WITH TIME ZONE 和 int的操作符


TIMESTAMP WITHOUT TIME ZONE：不带时区：TIMESTAMP
TIMESTAMP WITH TIME ZONE：带时区：TIMESTAMPTZ

TIMESTAMP加法：
CREATE OR REPLACE FUNCTION oracle.add_days_to_timestamp(TIMESTAMPTZ,integer)
RETURNS timestamptz AS $$
SELECT ($1 + interval '1 day' * $2) :: TIMESTAMPTZ;
$$ LANGUAGE SQL IMMUTABLE;

CREATE OPERATOR UX_CATALOG.+ (
  LEFTARG   = TIMESTAMPTZ,
  RIGHTARG  = INTEGER,
  PROCEDURE = oracle.add_days_to_timestamp
);

TIMESTAMP减法：
CREATE OR REPLACE FUNCTION oracle.subtract(TIMESTAMPTZ,integer)
RETURNS timestamptz AS $$
SELECT ($1 - interval '1 day' * $2) :: TIMESTAMPTZ;
$$ LANGUAGE SQL IMMUTABLE;

CREATE OPERATOR UX_CATALOG.- (
  LEFTARG   = TIMESTAMPTZ,
  RIGHTARG  = INTEGER,
  PROCEDURE = oracle.subtract
);

TIMESTAMPTZ大于：
CREATE OR REPLACE FUNCTION UX_CATALOG.GTTIMESTAMPTZ(TIMESTAMPTZ,integer)
RETURNS BOOLEAN AS 
$$
	SELECT $1 > $2::TIMESTAMPTZ;
$$LANGUAGE SQL IMMUTABLE;

CREATE OPERATOR UX_CATALOG.> (PROCEDURE = GTTIMESTAMPTZ, LEFTARG = TIMESTAMPTZ, RIGHTARG = integer, COMMUTATOR = <, NEGATOR = <=);

TIMESTAMPTZ小于：





相关问题单：
103554 

create table test2 as select (to_timestamp('2010-2-12 13:24:52.123456','YYYY-MM-DD HH24:MI:SS.FF6')) + (SELECT CAST('1' AS int)) -(to_timestamp('2010-2-12 13:24:52.123456','YYYY-MM-DD HH24:MI:SS.FF6'));
create table test1 as select (time(1) without time zone '2016-07-08 12:00:00.234') + (SELECT CAST('1' AS int)) -(time(1) without time zone '2016-07-08 12:00:00.234');


2022-10-09

1、
语法词法分析：
https://blog.csdn.net/x311609001028/article/details/79781687



2022-10-11
1、添加repmgrd
sudo vi /etc/logrotate.d/repmgrd

2、修改repmgrd文件
添加su命令，指定用户组进行翻转
/home/uxdb/uxdbinstall/dbsql/bin/logrepmgrd.log {
        missingok
        compress
        rotate 1
        maxsize 4K
		dateext
        weekly
        create 0600 uxdb uxdb
        postrotate
            /usr/bin/killall -HUP repmgrd
        endscript
        su root root
}

rotate：指定保存多少个备份文件
hourly：每小时回滚一次日志
minsize 1M ：文件大小超过 1M 后才会切割
dateext：指定滚动文件的后缀是当前日期


3、手动强制切割日志
sudo logrotate -f  /etc/logrotate.conf

调试logrotate
sudo logrotate -vfd /etc/logrotate.d/repmgrd



2022-10-13







8、

【现场问题】：
[不带安全属性的用户输入]测试项要求:
1.导入文件要求是[带有安全属性的用户数据输出]测试项导出的含有标记的数据文件；
2.要求导入时数据库自动识别标记字段，根据导入用户自动生成标记。(即导入用户在写入这个数据时，标记为导入用户的默认写标记)

验证步骤
1、找强访标记
2、验证dump导出后，将标记删除，然后导入，看标记是否重新生成；
3、如果重新生成，那只需要在导出时，将标记删除即可；
否则，需要查看如何重新生成标记



7、

执行命令：

./ux_dump -p 5432 -U uxdumprestore -n public -P -F p -d uxdb>uxdbdump.sql

uxsql -p 5432 -U uxdumprestore uxdb <uxdbdump.sql

查看是否审计：
./uxsql -U uxdumprestore -d uxdb
select * from uxaudit.log_event;

ux_dump日志：
_selectOutputSchema

只导出数据：
./ux_dump -p 5432 -U uxdumprestore -n public -P -F p -d uxdb -a >uxdbdump.sql

问题：
1、添加标记，无法通过普通用户使用copy
2、使用uxdumprestore用户，通过uxdumprestore用户进行备份恢复；
但uxdumprestore使用copy命令的标记，未使用uxdumprestore用户默认标记；


命令：

查看用户拥有模式权限：
\dn+ 或者
select a.nspname,b.rolname,string_agg(a.pri_t,',') from (select nspname,(aclexplode(COALESCE(nspacl, acldefault('n'::"char",nspowner)))).grantee as grantee,(aclexplode(COALESCE(nspacl, acldefault('n'::"char",nspowner)))).privilege_type as pri_t from pg_namespace where nspname not like 'pg%' and nspname <> 'information_schema') a,ux_authid b where (a.grantee=b.oid or a.grantee=0) and b.rolname='uxdb' group by a.nspname,b.rolname;

-p 5432 -U uxdumprestore -n public -P -F p -d uxdb>uxdbdump.sql

2022-10-14

uxsql 恢复命令调试
命令：
uxsql -p 5432 -U uxdumprestore uxdb <uxdbdump.sql

调试文件：startup.c

idle出现位置：
359                     pset.db = UXSQLconnectdbParams(keywords, values, true)

2022-10-18

timer定时器验证：
create extension ux_cron;

create table order1 (date timestamp, status int);

insert into order1 values ('2019-08-01', 0);

insert into order1 values ('2019-08-21', 2);

insert into order1 values ('2019-09-01', 0);

insert into order1 values ('2019-08-11', 0);

insert into order1 values ('2019-11-11', 0);
insert into order1 values ('2022-11-11', 0);


CREATE FUNCTION e_test() RETURNS void
AS $e_test$
 BEGIN
       update order1 set status=5 where TO_TIMESTAMP(now()::text, 'YYYY-MM-DD HH24:MI:SS.US') > TO_TIMESTAMP(date::text, 'YYYY-MM-DD HH24:MI:SS.US') and status=0;
 END;
 $e_test$ LANGUAGE pluxsql;

CREATE EVENT TRIGGER event_test ON timer
EXECUTE PROCEDURE e_test();

ALTER EVENT TRIGGER event_test ENABLE;

select * from order1 ;

查看定时任务号：
select * from cron.job;

停止任务：
select * from cron.unschedule(1);

2022-10-24

编译报错
1、不存在这个文件gnu/stubs-n32_hard.h
修改方法：注释头文件
 /usr/include/gnu/stubs.h  +23

2、报错： 
/lib64/libdl.so: error adding symbols: file in wrong format

修改方法：

由于configure默认编译32位（可以通过config查看编译参数）
mips编译参数：
linux64-mips64
所以编译方式通过：
./configure linux64-mips64

3、core问题
mips平台，
set jit = on；
执行层次查询时，有段错误

修改代码：


1、
根据nodes.h文件中参数修改：
~/uxdb_devel/uxdb-ng/uxdb-2.1/src/include/nodes/nodes.h

	T_HierarClause,
	T_ConnectBy,
	T_StartWith,
	T_PriorClause,
	T_SysConnectPath,
	T_ConnectRoot,


/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/executor/execExpr.c
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/executor/execExprInterp.c
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/jit/llvm/llvmjit_expr.c

rpm命令：
linux已安装软件命令：
rpm -qa|grep llvm
卸载安装包：
sudo rpm -e llvm9.0-libs-9.0.1-9.el7.x86_64 llvm9.0-9.0.1-9.el7.x86_64
查看llvm所有安装包：
sudo yum list |grep llvm
或者	yum search llvm


ExecProcNode			：循环第84次报错，调试到83
ExecSort				：循环第15次报错，调试到14		打断点 ExecRunCompiledExpr
ExecRunCompiledExpr		：循环第11次报错，调试到10		打断点 ExecRunCompiledExpr
llvm_compile_expr		：循环第14次报错，调试到13		打断点 llvm_compile_expr
ExecMergeJoin			: 循环第2次报错，调试到1		打断点	ExecProject




段错误位置：
evalexpr_0_13





EEOP_ASSIGN_SCAN_VAR
EEOP_DONE




llvm调试方法：
https://blog.csdn.net/zhongyunde/article/details/109013865

复现core语句：
create table tab_connect_by (child number,parent number);
insert into tab_connect_by (CHILD, PARENT) values(15, 38);
insert into tab_connect_by (CHILD, PARENT) values(38, null);
create table a1 as select * from tab_connect_by;

select a.CHILD from tab_connect_by a inner join a1 w on a.child=w.child start with a.PARENT is null connect by prior a.child = a.parent ;

构造内连接：
create table tab_connect_by (child number,parent number);
insert into tab_connect_by (CHILD, PARENT) values(15, 38);
insert into tab_connect_by (CHILD, PARENT) values(38, null);
create table a1 as select * from tab_connect_by;

正常sql：
select a.CHILD from tab_connect_by a inner join a1 w on a.child=w.child;
select a.CHILD from tab_connect_by a inner join a1 w on a.child=w.child connect by prior a.child = a.parent;



2022-10-27
报错信息：
1、
/data/uxdata

2、
repmgrd启动：
starting up

项目名称：
A01087028202220002
东北证券带外管理系统建设项目

2022-10-29



               HeapTuple tuple;
               HeapTuple user_label_tup;
               Oid policy_id = InvalidOid;
               Oid ulevel = InvalidOid;
               Oid uscope = InvalidOid;

               Oid plc_level = HeapTupleGetPlCol2(tuple);
               Oid plc_scope = HeapTupleGetPlCol3(tuple);
                       policy_id = RelationGetMacPolicyId(cstate->rel, InvalidOid);

                               user_label_tup = SearchSysCache2(USERLABELUSERPOLICY, ObjectIdGetDatum(GetUserId()), ObjectIdGetDatum(policy_id));
                       if (HeapTupleIsValid(user_label_tup))
                       {
                               ulevel = ((Form_ux_user_label)GETSTRUCT(user_label_tup))->max_read_level;
                               uscope = ((Form_ux_user_label)GETSTRUCT(user_label_tup))->max_read_scope;
                               ReleaseSysCache(user_label_tup);
                       }

                       if(ulevel >= plc_level && (plc_scope&uscope)==plc_scope)
                       {
                                                       /* Format and send the data */
                               CopyOneRowTo(cstate, HeapTupleGetOid(tuple), HeapTupleGetPlCol1(tuple), HeapTupleGetPlCol2(tuple), HeapTupleGetPlCol3(tuple), values, nulls);
                               processed++;
                       }



2022-10-31

一、验证以下步骤：
那再完善一下第三点（FTP_ITC.1）的场景（均包括客户端和服务端信息说明）：
1）单节点访问，会话被锁定，记录日志和审计表
2）单节点访问，ssl证书到期，记录日志和审计表
3）主备模式，ssl证书到期，记录日志和审计表


openssl证书配置：
https://blog.csdn.net/qq_34479012/article/details/125629699?spm=1001.2014.3001.5501

openssl x509 -req -in root.csr -text -days 3650 -extfile /home/uxdb/openssl/openssl.cnf -extensions v3_ca -signkey root.key -out root.crt
openssl req -new -nodes -text -out server.csr -keyout server.key -subj "/CN=test1"


openssl x509 -req -in server.csr -text -days 365 -CA root.crt -CAkey root.key -CAcreateserial -out server.crt


uxsql "host=localhost user=uxdb dbname=uxdb password=1qaz!QAZ sslmode=require"
uxsql "host=192.71.0.139 user=uxdb dbname=uxdb password=1qaz\!QAZ sslmode=verify-ca"

linux恢复系统时间：
sudo ntpdate -u ntp.api.bz

查看证书的有效期：

cat server.crt |openssl x509 -noout -enddate

12、校验证书是否过期

openssl x509 -in server.crt -checkend 0


设置ssl认证到期时间：
202210311637Z
-startdate 120814050000Z -enddate 120814060000Z 
openssl x509 -req -in server.csr -text -startdate 202210311637Z -enddate 202210311640Z  -CA root.crt -CAkey root.key -CAcreateserial -out server.crt

openssl x509 -req -in server.csr -text -enddate 20170106071311Z  -CA root.crt -CAkey root.key -CAcreateserial -out server.crt

openssl ca -config conf/caconfig.cnf -startdate 20160107071311Z -enddate 20170106071311Z -batch -out server_cert_2048.pem -in

gmssl配置：

步骤1、
# 生成ca相关：
gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -pkeyopt ec_param_enc:named_curve -out ca.old
gmssl req -new -days 365 -sm3 -x509 -key ca.old -text -subj "/C=CN/ST=China/L=Beijing/O=uxsino/OU=UXDB/CN=uxsino.com_CA" -out ca.crt
gmssl sms4 -in ca.old -out ca.key -a -k '1qaz!QAZ'

# 生成server相关
gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -pkeyopt ec_param_enc:named_curve -out server.old
gmssl req -new -key server.old -out server.req -subj "/C=CN/ST=China/L=Beijing/O=uxsino/OU=UXDB/CN=uxsino.com_server"
gmssl sms4 -d -a -k '1qaz!QAZ' -in ca.key -out ca.new
gmssl x509 -req -in server.req -CA ca.crt -CAkey ca.new -set_serial 111111 -text -days 365 -sm3 -out server.crt
gmssl sms4 -in server.old -out server.key -a -k '1qaz!QAZ'

# 生成client相关
gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -pkeyopt ec_param_enc:named_curve -out uxsinodb.old
gmssl req -new -key uxsinodb.old -out uxsinodb.req -subj "/C=CN/ST=China/L=Beijing/O=uxsino/OU=UXDB/CN=uxsino.com_client"
gmssl sms4 -d -a -k '1qaz!QAZ' -in ca.key -out ca.new2
gmssl x509 -req -in uxsinodb.req -CA ca.crt -CAkey ca.new2 -set_serial 111111 -text -days 1 -sm3 -out uxsinodb.crt
gmssl sms4 -in uxsinodb.old -out uxsinodb.key -a -k '1qaz!QAZ'

# 修改权限
chmod 0400 server.key
chmod 0400 uxsinodb.key

cp ca.crt ~/.uxsinodb/root.crt
cp uxsinodb.key ~/.uxsinodb/
cp uxsinodb.crt ~/.uxsinodb/

# 修改集群配置文件
vim UXDATA/uxsinodb.conf
ssl = on
ssl_ciphers = 'ECDHE-SM2-WITH-SMS4-SM3'
ssl_ecdh_curve = 'sm2p256v1'
ssl_cert_file = '../server.crt'
ssl_key_file = '../server.key'
ssl_ca_file = '../ca.crt'

vim UXDATA/ux_hba.conf
hostssl all all 0.0.0.0/0 md5 00:00-24:00 clientcert=1
#host all all 0.0.0.0/0 md5 00:00-24:00

步骤2：
date -s 12/12/2022			//时间选择使客户端认证过期，服务端认证正常；

步骤3：
注意：启动数据库需要带参数-Q
启动数据库：
./ux_ctl -I -D data -Q start

步骤4：
链接数据库：

uxsql "host=[ip地址] user=uxdb dbname=uxdb password=1qaz\!QAZ sslmode=verify-ca"		//host需要指定ip地址，如果默认本地链接，非tcp链接，故未获取本地ip地址；
步骤5：
查看审计日志

2022-11-3
pg机制：

1、wal日志流复制：
https://blog.csdn.net/Wemesun/article/details/126213248


2、

执行alter system命令

根据
uxsinodb.login

PathNameOpenFile




	remove("master_slave.txt");
	srand(time(NULL));

    FILE* fp = fopen("master_slave.txt", "w");//打开文件文本

    if (fp == NULL)//判断是否打开成功
    {
        printf("Open File Error\n");
        return;
    }
	fprintf(fp,"%5d",rand()%100);
    fclose(fp);//关闭文件文本

shell脚本:

1、shell脚本调试
执行命令(使用-x)：
bash -x xxx.sh

uxdbpath="/home/uxdb/uxdbinstall/dbsql/bin"
masterpath="$uxdbpath/master"		#主机集簇路径
standbypath="$uxdbpath/slave_1"		#备机集簇路径
standbyip="uxdb2"
tempFile="$masterpath/master_slave.txt"						#master_slave.txt配置（该路径配置不用改）



MD5FIRST="first"

while :
do
if [[ ! -f "$tempFile" ]]; then
master_exist=0
MD5FIRST="null"
fi

if [[ -f "$tempFile" ]]; then
master_exist=1
fi

if [[ ($master_exist -eq 1) && ("$MD5FIRST" == "first")]]; then
MD5FIRST=`md5sum $tempFile`
fi

if [[ $master_exist -eq 1 ]]; then				#master_slave.txt文件已经存在
	MD5NUM=`md5sum $tempFile`
	if [ "$MD5NUM" != "$MD5FIRST" ]; then		#字符串比较用!=
	scp $masterpath/uxsinodb.auto.conf uxdb@$standbyip:$standbypath
	ssh -T $standbyip  "$uxdbpath/ux_ctl reload -D $standbypath"
	MD5FIRST=$MD5NUM
	fi
fi
sleep 2
done


ux_syn_uxsinodb_auto.sh脚本需要在执行select ux_reload_conf()前启动；
因为脚本中的系统命令可能有告警，让脚本在后端执行，且将日志输出到一个文件中：
nohup sh ux_syn_uxsinodb_auto.sh >results.log&

2022-11-07

dbt5编译：
cmake . -DDBMS=pgsql

2022-11-08


高斯tpce：
https://gitee.com/hwrd/dbt5-tpce-for-opengauss


2022-11-16




select
 a.attname as filed,
 (case
  when a.attnotnull = true then 'NO'
  else 'YES' end) as null,
 (case
  when (
  select
   count(ux_constraint.*)
  from
   ux_constraint
  inner join ux_class on
   ux_constraint.conrelid = ux_class.oid
  inner join ux_attribute on
   ux_attribute.attrelid = ux_class.oid
   and ux_attribute.attnum = any(ux_constraint.conkey)
  inner join ux_type on
   ux_type.oid = ux_attribute.atttypid
  where
   ux_class.relname = c.relname
   and ux_constraint.contype = 'p'
   and ux_attribute.attname = a.attname) > 0 then true
  else false end) as key,
 concat_ws('', t.typname) as type,
 
  col1.is_identity as extra,
  col1.column_default as default 
from
    ux_tables ta,
 ux_class c,
 ux_attribute a ,
 ux_type t,
 information_schema.columns as col1
where
    ta.tablename=c.relname
 and a.attnum>0
 and a.attrelid = c.oid
 and a.atttypid = t.oid
 and col1.table_name=c.relname and col1.column_name=a.attname
 and ta.schemaname= col1.table_schema
 and ta.schemaname  ='模式名'
 and (c.relnamespace::regnamespace)::text='模式名'
 and c.relname='表名'
order by
    ta.schemaname,
 c.relname desc
 ;


show  columns  from 


show create table 
问题单：146876

SHOW COLUMNS FROM student_info; 
field（字段名）	type（字段类型） Null（是否不能为null） key（键值） default（默认值） Extra（）

	HeapTuple tuple = NULL;
	Form_ux_class classForm = NULL;
	tableInfo tableinfo;
	tuple = SearchSysCache1(RELOID, ObjectIdGetDatum(tableoid));
	if (!HeapTupleIsValid(tuple))
	{
		ereport(ERROR, (errcode(ERRCODE_CACHE_LOOKUP_FAILED), errmsg("cache lookup failed for table %u.", tableoid)));
	}
	classForm = (Form_ux_class)GETSTRUCT(tuple);

	int natts = get_relnatts(tableoid);
	for (i = 0; i < natts; i++) 
	{
		HeapTuple tp = SearchSysCache2(ATTNUM, ObjectIdGetDatum(tableoid), Int16GetDatum(i + 1));
		if (HeapTupleIsValid(tp))
		{
			Form_ux_attribute att_tup = (Form_ux_attribute)GETSTRUCT(tp);

			char* result = NULL;
			Datum txt;
			if (att_tup->attisdropped)
			{
				ReleaseSysCache(tp);
				continue;
			}
			/* is local */
			if(!att_tup->attislocal && !relispartition)
			{
				ReleaseSysCache(tp);
				continue;
			}
			txt = DirectFunctionCall2(
				format_type, ObjectIdGetDatum(att_tup->atttypid), ObjectIdGetDatum(att_tup->atttypmod));
			quote_identifier(NameStr(att_tup->attname));			//获取属性名field
			result = TextDatumGetCString(txt);						//获取数据类型type
			if (att_tup->attnotnull)								//判断是否为null
			if (att_tup->atthasdef) 								//获取默认值
			{
				Relation attrdefDesc;
				ScanKeyData skey[2];
				SysScanDesc adscan;
				HeapTuple tup = NULL;
				bool isnull = false;

				attrdefDesc = table_open(AttrDefaultRelationId, AccessShareLock);
				ScanKeyInit(&skey[0], Anum_ux_attrdef_adrelid, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(tableoid));
				ScanKeyInit(&skey[1], Anum_ux_attrdef_adnum, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(att_tup->attnum));
				adscan = systable_beginscan(attrdefDesc, AttrDefaultIndexId, true, NULL, 2, skey);

				while (HeapTupleIsValid(tup = systable_getnext(adscan))) 
				{
					Datum val,
							txt;
					char *tmptxt = NULL;
					val = fastgetattr(tup, Anum_ux_attrdef_adbin, attrdefDesc->rd_att, &isnull);
					txt = DirectFunctionCall3(ux_get_expr, val, ObjectIdGetDatum(tableoid), true);
					tmptxt = TextDatumGetCString(txt);
					if (att_tup->attgenerated == ATTRIBUTE_GENERATED_STORED)
						appendStringInfo(buf, " GENERATED ALWAYS AS %s STORED", tmptxt);
					else 
					{
						if(tmptxt != NULL && strlen(tmptxt) > 0)
							appendStringInfo(buf, " DEFAULT %s", tmptxt);
					}
				}	
				systable_endscan(adscan);
				table_close(attrdefDesc, AccessShareLock);
			}
				
			ReleaseSysCache(tp);
	}
		
		get_index_list_info										//获取索引信息

static void
get_table_att_type_default(Oid tableoid, StringInfo tfield, StringInfo ttype,StringInfo tnull,StringInfo tdefault, Oid reloftype, bool relispartition)
{
	int i;
	int actual_atts = 0;
	int natts = get_relnatts(tableoid);
	for (i = 0; i < natts; i++) 
	{
		HeapTuple tp = SearchSysCache2(ATTNUM, ObjectIdGetDatum(tableoid), Int16GetDatum(i + 1));
		if (HeapTupleIsValid(tp))
		{
			Form_ux_attribute att_tup = (Form_ux_attribute)GETSTRUCT(tp);

			char* result = NULL;
			Datum txt;
			if (att_tup->attisdropped)
			{
				ReleaseSysCache(tp);
				continue;
			}
			/* is local */
			if(!att_tup->attislocal && !relispartition)
			{
				ReleaseSysCache(tp);
				continue;
			}
			txt = DirectFunctionCall2(
				format_type, ObjectIdGetDatum(att_tup->atttypid), ObjectIdGetDatum(att_tup->atttypmod));

			strcpy(tfield.data, quote_identifier(NameStr(att_tup->attname)));
			strcpy(ttype.data,TextDatumGetCString(txt));

			if (att_tup->attnotnull)
				strcpy(tnull.data, "NO");
			else
				strcpy(tnull.data, "YES");
			if (att_tup->atthasdef) 
			{
				Relation attrdefDesc;
				ScanKeyData skey[2];
				SysScanDesc adscan;
				HeapTuple tup = NULL;
				bool isnull = false;

				attrdefDesc = table_open(AttrDefaultRelationId, AccessShareLock);
				ScanKeyInit(&skey[0], Anum_ux_attrdef_adrelid, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(tableoid));
				ScanKeyInit(&skey[1], Anum_ux_attrdef_adnum, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(att_tup->attnum));
				adscan = systable_beginscan(attrdefDesc, AttrDefaultIndexId, true, NULL, 2, skey);

				while (HeapTupleIsValid(tup = systable_getnext(adscan))) 
				{
					Datum val,
							txt;
					char *tmptxt = NULL;
					val = fastgetattr(tup, Anum_ux_attrdef_adbin, attrdefDesc->rd_att, &isnull);
					txt = DirectFunctionCall3(ux_get_expr, val, ObjectIdGetDatum(tableoid), true);
					tmptxt = TextDatumGetCString(txt);
					if (att_tup->attgenerated == ATTRIBUTE_GENERATED_STORED)
						appendStringInfo(buf, " GENERATED ALWAYS AS %s STORED", tmptxt);
					else 
					{
						if(tmptxt != NULL && strlen(tmptxt) > 0)
							strcpy(tdefault.data, tmptxt);
						else
							strcpy(tdefault.data, "NULL");
					}
				}	
				systable_endscan(adscan);
				table_close(attrdefDesc, AccessShareLock);
			}
			ReleaseSysCache(tp);
		}
	}
	return;
}

create table tb1(did int primary key,id int UNIQUE);

create table tb(id int primary key, name text not null);


SHOW COLUMNS FROM tb;


2022-11-18

show columns from table语法介绍：

key
1、索引第一列显示 mul		（所有索引显示mul，如果索引为组合索引，那么创建组合索引第一列显示mul）
2、如果有多个Key值应用于表的给定列，Key将按PRI、UNI、MUL的顺序显示优先级最高的那个。
3、如果多个列组成一个复合UNIQUE索引，UNIQUE索引可以显示为MUL

Extra：
auto_increment： 用于具有自动递增属性的列。
on update CURRENT_TIMESTAMP：用于具有on update CURRENT_TIMESTAMP属性的TIMESTAMP或DATETIME列
VIRTUAL GENERATED or STORED GENERATED：用于生成列
DEFAULT_GENERATED：用于具有表达式默认值的列。


2022-11-21


获取索引：
get_table_alter_info
	get_index_list_info
		ux_get_indexdef_worker















测试用例：

2、如果有多个Key值应用于表的给定列，Key将按PRI、UNI、MUL的顺序显示优先级最高的那个。

3、如果多个列组成一个复合UNIQUE索引，UNIQUE索引可以显示为MUL
create table demo3(id int unique,idme varchar(20),pwd varchar(20));
alter table demo3 add unique (id, idme);
show columns from demo3;

后面字段后面跟空格：
create table demo13(id int,idme varchar(20),pwd varchar(20));
alter table demo13 add unique(id                       , idme);
show columns from demo13;


alter index：

primary验证：
create table demo(id int primary key,idme varchar(20),pwd varchar(20));
alter table demo add unique (id);
show columns from demo;
drop table demo;



unique验证：

create table demo(id int,idme varchar(20),pwd varchar(20));
alter table demo add unique (id);
show columns from demo;
drop table demo;

如果多个列组成一个复合UNIQUE索引，UNIQUE索引可以显示为MUL
create table demo(id int,idme varchar(20),pwd varchar(20));
alter table demo add unique (id, idme);
show columns from demo;
drop table demo;

字段后面跟空格：
create table demo(id int,idme varchar(20),pwd varchar(20));
alter table demo add unique(id                       , idme);
show columns from demo;
drop table demo;











alter验证优先级






验证create index
create table demo(id int,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id);
show columns from demo;
drop table demo;

create table demo(id int unique,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id,   idme);
show columns from demo;
drop table demo;


验证create unique

create table demo(id int,idme varchar(20),pwd varchar(20));
create unique index inx1 on demo(id);
show columns from demo;
drop table demo;

create table demo(id int not null,idme varchar(20),pwd varchar(20));
create unique index inx1 on demo(id  , idme);
show columns from demo;
drop table demo;

create (unique)index验证优先级：
create table demo(id int,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id);
show columns from demo;
drop table demo;

create table demo(id int primary key,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id);
show columns from demo;
drop table demo;


create table demo(id int,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id,   idme);
create unique index inx1 on demo(id);
show columns from demo;
drop table demo;

create table demo(id int primary key,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id,   idme);
create unique index inx1 on demo(id);
show columns from demo;
drop table demo;



create table demo(id int unique,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id,   idme);
show columns from demo;
drop table demo;


多字段验证：
create table demo(id int primary key,idme varchar(20) unique,pwd varchar(20));
alter table demo add unique(id                       , idme);
create index inx2 on demo(pwd);
show columns from demo;
drop table demo;


2022-11-22

show index from 语句实现
各字段介绍
Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment 

--Table：表名
--Non_unique：是否包含重复项，如果不包含，为0，否则，包含为1；
--Key_name：索引名称，如果索引是主键，则名称总是primary。（联合索引，索引名称相同）
--Seq_in_index：索引Key_name中的列序列号，从1开始。
--Column_name：Key_name中对应Seq_in_index的列名。
Collation：在索引中如何对列排序。它可以有值A(升序)、D(降序)或NULL(未排序)。
--Cardinality：行数，根据统计信息进行计数的；
--Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL
--Packed：指示key如何被压缩。如果没有被压缩，则为NULL。
--Null：该字段是否可以为null，如果是：yes，不是为空
Index_type：索引类型
Comment：字段注释
Index_comment：索引注释

添加字段注释：
comment on column demo1.id is '123';
添加索引注释：
comment on index demo1_idme_key is 'index_comm';
查看表注释信息：
Select a.attnum,(select description from ux_catalog.ux_description where objoid=a.attrelid and objsubid=a.attnum) as descript ,
a.attname,ux_catalog.format_type(a.atttypid,a.atttypmod) as data_type from ux_catalog.ux_attribute a where 1=1 and 
a.attrelid=(select oid from ux_class where relname='demo1' ) and a.attnum>0 and not a.attisdropped order by a.attnum;



测试用例：
--Non_unique
--Null
create table demo(id int,idme varchar(20),pwd varchar(20));

create index inx3 ON demo(idme, id);
--Cardinality
insert into demo(id) select generate_series(1,99);
--Comment
comment on column demo.id is '123';
--Index_comment
comment on index inx1 is 'index_comm';


2022-11-28

FORMAT(x,n)将数字x格式化，并以四舍五入的方式保留小数点后n位，结果以字符串形式返回。若n位0则返回结果函数不含小数部分。

mysql> select format(12332.123456,4),format(12332.1,4),format(12332.2,0);
+------------------------+-------------------+-------------------+|
format(12332.123456,4) | format(12332.1,4) | format(12332.2,0) |
+------------------------+-------------------+-------------------+|
12,332.1235            | 12,332.1000       | 12,332            |
+------------------------+-------------------+-------------------
+1 row in set (0.00 sec)

mysql> 
uxdb=# select format(12332.123456,4),format(12332.1,4),format(12332.2,0);
错误:  函数 format(numeric, integer) 不存在第1行select format(12332.123456,4),format(12332.1,4),format(12332... 
^提示:  没有匹配指定名称和参数类型的函数. 您也许需要增加明确的类型转换.
uxdb=#

测试用例： 
补0、补小数点
select format(12332,4);
select format(12332.,4);
select format(12332.123,4);

四舍五入：
select format(12332.123446,4);
select format(12332.123456,4);

select format(12332.123486,0);


实现函数：
1、
SELECT CAST(135.1235 as DECIMAL(18,3));
2、
补0、补小数点
select round(12332,4);
select round(12332.,4);
select round(12332.123,4);

四舍五入：
select round(12332.123446,4);
select round(12332.123456,4);

select round(12332.123486,0);

round不支持以下功能：
如果以数字开头，则将开头的数字部分转为数字。
如果不能转为数字，则按照 0 处理。

测试用例：

SELECT
    FORMAT(111111, 2),
	FORMAT(111111., 2),
    FORMAT(111111.111, 2),
    FORMAT(111111.111, 0),
    FORMAT('111111', 2),
	FORMAT(12332.123446,4),
	FORMAT(12332.123456,4),
    FORMAT(NULL, 2);

2022-11-29
FORMAT函数实现：

函数分析：
1、输出格式化结果#,###,###.##
2、输出结果为字符串
3、第三个参数，受lc_time_names值的影响，影响小数点、千位分隔符和分隔符之间的分组；
但lc_time_names值不影响FORMAT()的结果

设置千位分隔符：
\pset numericlocale		//numeric设置千位分隔符

CREATE OR REPLACE FUNCTION ux_catalog.format(NUMERIC, INTEGER)
RETURNS text AS
$$
declare 
	result  text;
begin
if $1 is NULL or $2 is NULL then
	return 'NULL';
end if;
        SELECT ux_catalog.round($1,$2)::text into result;
return result;
end;
$$LANGUAGE pluxsql;





CREATE OR REPLACE FUNCTION ux_catalog.format(NUMERIC, INTEGER)
RETURNS text AS
$$
declare 
	result  text;
begin
        SELECT ux_catalog.round($1,$2)::text into result;
return result;
end;
$$LANGUAGE pluxsql STRICT;


create table DemoTable
(
Amount numeric
);
insert into DemoTable values(95868685.50);
select format(Amount,2) from DemoTable;


千位分隔符实现：


for i in input_str:
    if input_str[lenth] == '.':
        break
    lenth += 1

if lenth % 3 == 0:
    pos_separator = 3
else:
    pos_separator = lenth % 3

for i in range(0, lenth):
    if i == pos_separator:
        output_str += ',' + input_str[i]
        pos_separator += 3
    else:
        output_str += input_str[i]

output_str += input_str[lenth:]





char_length			//获取字串长度


CREATE OR REPLACE FUNCTION ux_catalog.format(NUMERIC, INTEGER)
RETURNS text AS
$$
declare 
	result  text[];
	output_str text[];
	lenth int := 0;
	len int := 0;
	pos_separator int;
	i int;
begin
SELECT ux_catalog.round($1,$2)::text into result;
SELECT char_length(result) into len;
for i in 1.. len loop
    if result[lenth] == '.' then
        exit;
	end if;
    lenth:=lenth+1;
end loop;
if lenth % 3 == 0 then
    pos_separator = 3;
else
    pos_separator := lenth % 3;
end if;

for i in 1.. lenth loop
    if i == pos_separator then
        output_str :=output_str + ',' + result[i];
        pos_separator :=pos_separator + 3;
    else
        output_str :=output_str + result[i];
	end if;
end loop;
output_str :=output_str + result[lenth];

return output_str;
end;
$$LANGUAGE pluxsql;



format_numeric_locale



setDecimalLocale

LC_NUMERIC						//UXLC_localeconv

lc_numeric 设置local				//对应变量全局locale_numeric


{ oid => '3824', descr => 'convert numeric to money',				//numeric_cash对numeric进行处理，返回money
  proname => 'money', provolatile => 's', prorettype => 'money',
  proargtypes => 'numeric', prosrc => 'numeric_cash' },


numeric_to_char
	


coerce_to_target_type

ParseFuncOrColumn
	func_get_detail
		func_select_candidate

调试函数：
(gdb) p *(A_Const *)((FuncCall *)expr)->args->head->data
$10 = {type = T_A_Const, val = {type = T_String, val = {ival = 38330192,
      str = 0x248df50 "11111"}}, location = 14}
(gdb) p *(A_Const *)((FuncCall *)expr)->args->head->next->data




		/* 函数为format，且函数第二个参数为UNKNOWNOID时，进行对该字段类型进行强制转换 */
		if ((0 == strcmp(NameListToString(funcname), "format")) && (nargs == 1 && argtype == UNKNOWNOID))
			arg = coerce_to_target_type(pstate, arg,
										argtype, TEXTOID,
										-1, COERCION_EXPLICIT,
										COERCE_EXPLICIT_CAST, -1);
		argtype = exprType(arg);
		
2022-12-2

drop table if exists y1 cascade;
create table y1(id1 serial,id2 timestamp default now() on update current_timestamp,id3 timestamp on update now(),id4 int GENERATED ALWAYS AS (1 + 2) STORED);
SHOW COLUMNS FROM y1;


.net配置后端链接：
1、app.config配置
查看区域化项目

2、cs后端配置：

代码如下：
string myschool = System.Configuration.ConfigurationManager.ConnectionStrings["ConnStr"].ToString();
MessageBox.show(myschool);
NuxsqlConnection conn = new NuxsqlConnection(myschool);

try
{
	conn.Open();
	Console.WriteLine("数据库连接成功!");
	Console.ReadLine();
}




2022-12-2
rac数据库启动
1、启动corosync：
进入路径：
/home/uxdb/corosync/sbin
sudo ./corosync -c ../etc/corosync/corosync.conf

2022-12-05
930考试：
1、考题位置：   
svn|||   40.部门管理\03.产品服务部\05.专题记录\03.自强考试备考\

2、代码上传位置
930考试分支  origin/support930_examination   基于上次送测版本 切出的考试分支     
每个人领到的题 都要在下周三(12/8)以前进行上传  设计文档 代码上传(svn： 40.部门管理\01.产品研发部\08.930\02.930考试）

3、我的考试题
4-3 实现记录表存储信息查询工具
4-4 增加接口返回错误原因格式化文本输出
2-2 实现对数据导入和数据查询的关键词替换


4-3 实现记录表存储信息查询工具

实现步骤：
1、获取表数据文件位置；
2、获取表的长度；
3、获取每条记录tuple在文件中的位置和长度；
4、如果为大字段，指明大字段的存储情况；


1、
ux_relation_filepath			//获取表路径
2、
ux_relation_size				//获取表大小
3、

测试语句：
create table FixSizeTable
(
sno CHAR(20),
sname CHAR(20),
height INT
);

create table VarSizeTable
(
sno  VARCHAR(20),
sname VARCHAR(20),
sex  CHAR(20)
);

insert into FixSizeTable values('1', 'zhangsan', 1);

insert into FixSizeTable values('2', 'lisi', 2);

insert into FixSizeTable values('3', 'wangwu', 3);


insert into VarSizeTable values('1', 'zhangsan', 'M');

insert into VarSizeTable values('2', 'lisi', 'W');

insert into VarSizeTable values('3', 'wangwu', 'M');



内核代码分析：
tuple获取：

1）、页page	（块对应结构体：PageHeaderData）
页中的pd_linp 即上图中的 line-pointer，可变长度的数组，与元组一一对应，用来存储每一个元组在当前page内部的起始偏移地址
pd_linp的数据结构定义：
typedef struct ItemIdData
{
	unsigned	lp_off:15,		/* tuple位置（tuple在块中的起始位置） */
				lp_flags:2,		/* state of item pointer, see below */
				lp_len:15;		/* tuple长度（tuple的总长度（HeapTupleData + HeapTupleHeaderData + data area）） */
} ItemIdData;

2）、元祖（tuple对应的结构体：HeapTupleData）

1、元组主要由三部分组成
除了 t_data 之外的 HeapTupleData，t_data 也就是 HeapTupleHeaderData，还有一部分就是 实际的data area。

2、HeapTupleData 中的len = HeapTupleHeaderData + data area的长度，
t_self 标识当前 tuple 所处的 page 位置；


typedef struct HeapTupleData
{
	uint32		t_len;			/* header + data的长度(不包含HeapTupleData的长度) */
	ItemPointerData t_self;		/* 当前元组所处的页的位置（包含block-number 以及 page内的offset，也就是表文件中真实tuple的位置） */
	Oid			t_tableOid;		/* table the tuple came from */
	HeapTupleHeader t_data;		/* -> tuple header and data */
} HeapTupleData;

struct HeapTupleHeaderData
{
	union
	{
		HeapTupleFields t_heap;
		DatumTupleFields t_datum;
	}			t_choice;

	ItemPointerData t_ctid;		/* current TID of this or newer tuple (or a
								 * speculative insertion token) */

	/* Fields below here must match MinimalTupleData! */

	uint16		t_infomask2;	/* number of attributes + various flags */

	uint16		t_infomask;		/* various flag bits, see below */

	uint8		t_hoff;			/*  标识整个header + 后面的bit占用的偏移(tuple头的长度)  */

	/* ^ - 23 bytes - ^ */

	bits8		t_bits[FLEXIBLE_ARRAY_MEMBER];	/* bitmap of NULLs */

	/* MORE DATA FOLLOWS AT END OF STRUCT */
};

tuple存储内核分析：
https://www.cnblogs.com/flying-tiger/p/8029941.html

pg的页tuple从文件末尾向开头分配

text_to_cstring		//text转char
cstring_to_text		//char转text

获取块信息：
通过创建插件pageinspect，获取块元组详细信息：
create extension pageinspect;

扫描表信息函数：

ScanKeyInit：

ScanKeyInit(&skey, Anum_ux_index_indrelid, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(tableoid));（索引通过tableoid查找ux_index中相关行数据）
ScanKeyInit用于初始化一个扫描键skey，Anum_ux_index_indrelid表示索引元组中 "indrelid" 字段的索引号，
BTEqualStrategyNumber表示比较操作符类型（等于操作符），F_OIDEQ对应扫描键indrelid的类型，ObjectIdGetDatum(tableoid))，表示要查找比较表的唯一标识符，
也就是与第二个参数Anum_ux_index_indrelid比较

systable_beginscan 函数接受以下参数：
indrel = table_open(IndexRelationId, AccessShareLock);
indscan = systable_beginscan(indrel, IndexIndrelidIndexId, true, NULL, 1, &skey);
relation：要进行扫描的系统表的关系对象（Relation）。
indexId：指定要使用的索引的标识符，用于加速扫描。如果不需要索引加速，可以传递 InvalidOid。
indexOK：指示是否允许使用索引进行扫描。如果为 true，则在扫描过程中可以使用索引获取匹配的元组。如果为 false，则仅进行顺序扫描。
snapshot：表示扫描使用的快照（Snapshot）对象。如果为 NULL，则使用当前事务的快照。
nkeys 和 key：表示扫描键（ScanKey）的数量和数组，用于指定过滤条件。可以根据需要传递多个扫描键进行过滤。

systable_getnext 函数逐个获取系统表的元组，while (HeapTupleIsValid(htup = systable_getnext(indscan)))
Form_ux_index index = (Form_ux_index)GETSTRUCT(htup);		//通过GETSTRUCT获取元组信息

SearchSysCache2：
SearchSysCache2(int cacheId, Datum key1, Datum key2)
cacheId：表示要搜索的缓存的标识符（Oid）。每个缓存都有一个唯一的标识符，用于区分不同的缓存。
key1 和 key2：表示缓存条目的搜索键（ScanKey）。缓存条目的搜索键是一组限制条件，用于过滤出符合条件的缓存条目。
执行SearchSysCache2，需要释放cache，通过函数ReleaseSysCache(tp);
eg：
HeapTuple tp = SearchSysCache2(ATTNUM, ObjectIdGetDatum(tableoid), Int16GetDatum(i + 1));		//表示搜索pg_attribute中表oid为tableoid，列编号了i+1，因为列从1开始向上编号；
然后通过以下方式获取元组信息
if (HeapTupleIsValid(tp))
{
	Form_ux_attribute att_tup = (Form_ux_attribute)GETSTRUCT(tp);
}

int natts = get_relnatts(tableoid);			//获取表属性个数

DirectFunctionCall2Coll：
DirectFunctionCall2Coll(UXFunction func, Oid collation, Datum arg1, Datum arg2)	//内核中执行函数func，arg1，arg2为函数func的两个参数

copy form内核代码调用栈：
CopyFrom
	NextCopyFrom
		NextCopyFromRawFields
			CopyReadLine
				CopyReadLineText
					CopyLoadRawBuf
						CopyGetData


自动生成oid：
GetNewRelFileNode			//ux_class生成relfilenode

wal日志：

1、相关问题单
108463、

#隐式转换相关

select int4(B'110');		//int4(B'110'),意思将bit类型转化为int4
隐式转换与操作符优先级，当存在需要隐式转换的操作时，先执行隐式转换，然后再执行操作符函数；


pg使用手册：
1、guc参数使用
log_destination：该参数定义了日志的输出目的地。可以将其设置为 'stderr'，以将日志输出到标准错误流 (stderr)。

logging_collector：该参数用于启用日志收集器，它将数据库日志写入一个单独的日志文件。
log_statement：该参数定义了哪些 SQL 语句将被记录到日志中。可以设置为 'all'，以记录所有 SQL 语句。
log_duration：该参数定义了是否记录 SQL 语句的执行时间。可以将其设置为 on，以记录执行时间。
log_line_prefix：该参数定义了每行日志消息的前缀格式。可以将其设置为 '[%p] %m'，以包含进程 ID 和消息内容。


log_min_messages	//调试sql，log日志中可以显示sql详细信息

语法：
CREATE TABLE ... (LIKE ... INCLUDING ALL)

系统表相关信息：
objid 字段表示依赖关系的源对象的 OID（对象标识符）。这是发起依赖的对象，也称为依赖的对象或依赖项。
例如，如果一个视图依赖于一个表，那么视图的 OID 将出现在 objid 字段中。
refobjid 字段表示依赖关系的目标对象的 OID。这是被依赖的对象，也称为依赖目标。继续上述示例，如果一个视图依赖于一个表，那么表的 OID 将出现在 refobjid 字段中。








防疫：
1、发热：布洛芬片
2、发热、流鼻涕、鼻塞、打喷嚏等：复方氨酚烷
3、咽干咽痛：地喹氯铵含片
4、咳嗽咳痰：
按柠流肠溶胶囊
羚甲司坦口服溶液
福多司坦口服溶液
氨澳特罗口服溶液
氢澳酸右美沙芬胶囊/口服溶液
福尔可定口服溶液


2022-12-15

同步guc参数：
问题：
1、有些guc参数不能进行同步

guc参数分析：

UXC_INTERNAL		//alter命令无法修改
UXC_POSTMASTER		//alter命令可以修改，但需要重启后生效
UXC_SIGHUP			//alter命令可以修改，但需要reload或重启生效
UXC_SU_BACKEND		//alter命令可以修改，但需要重启后生效
UXC_BACKEND			//alter命令可以修改，但需要重启后生效
执行ux_reload_conf可以生效：
UXC_SIGHUP
UXC_SUSET			
UXC_USERSET			

guc参数分析：
https://blog.csdn.net/qq_21127313/article/details/72765786



AlterSystemSetConfigFile			//alter system入口

测试步骤：
alter system set max_connections TO 100;
alter system set lock_timeout TO 2;
select * from ux_replication_guc;

备库代码流程：
StartupXLOG
	ReadRecord
		XLogReadRecord
			ReadPageInternal
				XLogPageRead




walreceiver进程：
sigusr1_handler()->StartWalReceiver()->AuxiliaryProcessMain()->WalReceiverMain()->walrcv_receive()

startup进程：
PostmasterMain()->StartupDataBase()->AuxiliaryProcessMain()->StartupProcessMain()->StartupXLOG()




xlog.c:7873
heap_redo






gdb屏蔽信号调试：
handle SIGUSR1 nostop
b heap_xlog_insert



代码备份：
1、
		int ret = -1;
		char *gucname = NULL;
		bool isnull;
		if (SPI_connect() < 0)
			ereport(ERROR,
					(errcode(ERRCODE_TRIGGERED_ACTION_EXCEPTION),
					 errmsg("SPI_connect failed")));
		ret = SPI_execute("select ux_relation_filepath('tt');", false, 0);
		//ret = SPI_exec("select ux_relation_filepath('tt');", 0);
		if (ret != SPI_OK_SELECT)
			elog(ERROR, "SPI_execute failed !");
		gucname = text_to_cstring((const text *)SPI_getbinval(SPI_tuptable->vals[0],
															  SPI_tuptable->tupdesc,
															  1, &isnull));
		if(NULL != gucname)
		elog(WARNING, "gucname = %s!", gucname);
		SPI_finish();

2、
	// if (record->blocks->rnode.relNode == ReplicationGucRelationId)
	// {
	// 	int ret = -1;
	// 	SPIPlanPtr spiplan;
	// 	char *gucname = NULL;
	// 	bool isnull;
	// 	char questring[128] = {0};
	// 	if (SPI_connect() != SPI_OK_CONNECT)
	// 		elog(ERROR, "SPI_connect failed");
	// 	strcpy(questring, "select name from tt;");
	// 	spiplan = SPI_prepare(questring, 0, NULL);
	// 	if (spiplan == NULL)
	// 		elog(ERROR, "SPI_prepare failed for query_string");

	// 	ret = SPI_execute_plan(spiplan, NULL, NULL, true, 0);
	// 	if (ret != SPI_OK_SELECT)
	// 		elog(ERROR, "failed to execute query_string");
	// 	gucname = text_to_cstring((const text *)SPI_getbinval(SPI_tuptable->vals[0],
	// 														  SPI_tuptable->tupdesc,
	// 														  1, &isnull));
	// 	if (NULL != gucname)
	// 		elog(WARNING, "gucname = %s!", gucname);
	// 	if (SPI_finish() != SPI_OK_FINISH)
	// 		elog(ERROR, "SPI_finish failed");
	// }




StartupXLOG






walreceiver进程和startup进程
https://blog.51cto.com/u_15316394/5004211

通过系统表方式：
目前无法实现，由于备机在应用系统表数据时，处于恢复状态，在恢复状态下，无法执行alter system，故该方案不可行，
目前通过工具，调用libuxsql方式实现；

获取流复制备机ip：
select client_hostname from ux_stat_replication ;


guc主备可配置筛选：


执行ux_reload_conf可以生效：
UXC_SIGHUP
UXC_SUSET			
UXC_USERSET	

ssl
ssl_passphrase_command_supports_reload


可同步参数：
enable_audit
ssl
ssl_passphrase_command_supports_reload
ssl_prefer_server_ciphers


安全属性：

ssl
ts_size_threshold
enable_resource_limit

ux_security.password_length
ux_security.login_idle_timeout
ux_security.login_error_lock_times
ux_security.role_password_lifetime
ux_security.login_error_lock_duration
ux_security.password_condition_digit
ux_security.password_condition_symbol
ux_security.password_condition_simple
ux_security.password_condition_user
ux_security.password_condition_lower_case_character
ux_security.password_condition_upper_case_character

mpp发送命令：

问题单：
174367

接口：
ExecuteCriticalRemoteCommand






2022年工作总结：
1季度：
1、安全重构2114s插件、工具适配，并进行任务分配、工具自测；
2、协助跟踪安全组内成员完成安全重构相关问题；
3、解决2114s安全相关问题单；
4、redmine问题单处理（11+9）
5、现场问题处理（2+4）
6、自强考试

#129390、#130692、#131113、#131788、#132282、#132331、#132671、#132965

1月：
对外（现场）支持：
2、#110025：软江项目支持：uxpool core问题
5、自强tpcc测试支持

2114s工具、插件适配：
1、#127403：2114s插件、工具适配进度跟踪、问题讨论；
4、#129390:ux_cron、repmgr插件提示模式不存在，ux_cron extension插件未加载等问题
3、#130692：createuser 权限问题分析Permission denied：
repmgr解决安全功能下uxsmo超级用户问题
安全兼容版 ux_hint_plan插件问题整理
#131113：orafce中隐式转换结果不对
#131788：ver2.1.1.4s :安全集群，auditlogger 进程被kill掉
132282:安全集群，logger 系统日志进程被kill掉之后，存在残留进程；
#132331：ver2.1.1.4s：创建排序规则指定locale失败
#132671：2114s安全兼容模式下，创建ux_cron插件，提示uxdb数据库不存在
#132087：插件、工具自测
安全兼容 make check_32_compatible_security自测用例存在审计进程退出问题，
定位与关闭其他子进程审计管道读端有关，具体原因待分析
#132965：repmgr注册主节点提示"repmgr" extension is not available
repmgr故障切换未成功原因

review以下问题单：
review #129215问题单
#128644:解决兼容模式下char类型不可用
#129229：mysql_fdw、oracle_fdw、tds_fdw、uxdb_fdw插件报关键字为非法选项的错误。
#129207 解决安全兼容版中，dict_xsyn、file_fdw、unaccent插件关键字不识别问题
3、检视问题单 #129783ux_stat_statements、ux_probackup、dblink工具及插件问题修复
1、跟踪127403问题单进度；
2、检视问题单129783、129229；
review 130147 代码







2月：

对外支持：
8、分析repmgr故障切换未成功原因（已完成）

1、131788:ver2.1.1.4s :安全集群，auditlogger 进程被kill掉之后，不会自动拉起（已完成）
2、132282:安全集群，logger 系统日志进程被kill掉之后，存在残留进程；（已完成）
3、#132331：ver2.1.1.4s：创建排序规则指定locale失败（已完成）
4、#132671：2114s安全兼容模式下，创建ux_cron插件，提示uxdb数据库不存在（已完成）
5、#132087：插件、工具自测（已完成）
6、安全兼容 make check_32_compatible_security自测用例存在审计进程退出问题
7、#132965：repmgr注册主节点提示"repmgr" extension is not available（已完成）

9、自强考试2-1数据库内置函数功能裁剪及功能修改实现、
2-2实现对数据导入和数据查询的关键词替换、
3-5根据数据库系统负载给出创建分区建议；
考试题目方案分析及编码（正在进行）

3月：
对外支持：
#129384：旋极军工项目打包支持
#135974 河南移动中标项目支持
#138262 中防生态适配打包


#134746 ：修改max_pool参数值为异常时，uxpool可以正常停止
#134875 ：安全兼容模式下，控制台uxpool相关命令报错
#134743 ：安全兼容模式下，控制台show部分uxpool参数报错
#135100：主环境断电后，uxpool备库生升主库异常
#134730：资源管理调研
#125828:28所军创项目支持，分析where in语句查询变慢原因
安全重构迭代四相关问题单自测
#135974:调研oracle set_module函数
#136538  repmgr多次主备切换问题
#137009：where in问题分析
自强考试准备


2季度：
1、河南移动兼容多个函数支持
2、对外支持项目15个
3、redmine问题单处理19个
4、研发部培训1次


4月：
1、河南移动兼容多个函数支持
2、对外支持项目5个
3、问题单9个
4、研发部培训1次

对外支持：
#138851 add_months、months between、last day、to char等函数支持
#135974:listagg、grouping_id、regexp_like、 pg_backend_pid、chartorowid、userenv等函数功能支持


#136773、#138851、#135974、#138262、#136367、#138648、#138851、#125233、#139594、
#140293、#141388、#143313、#139826、#144088、#148035、#148163、#146359等

1、以下工作已全部完成:
#136773: 进行自强考试
#138851 add_months、months between、last day、to char等函数支持
#135974:listagg、grouping_id、regexp_like、 pg_backend_pid、chartorowid、userenv等函数功能支持
#135974 河南移动中标项目支持提作符类型问题
#138262 中防生态适配打包
#136367 dbms_utility.get hash_value功能支持
#138648 沈抚项目支持，分析系统环境报错问题
#138851 trunc、decode、nvl、mod等函数支持
#125233: 开发文档-安全功能规范编写
#139594:to date函数参数1使用数字报错
#140293: nhibernate + spring mvc整合demo编写
进行uxpool研发部培训

5月：
1、对外支持项目3个
2、问题单4个

1)主要完成工作:
#139594:to_date函数参数1使用数字报错
#140293:nhibernate + spring mvc整合demo编写（JYJT涉密）
#141388:运算符调用时支持<=，不支持《，两个运算符中间含有空格，在调用时提示“语法错误在“="或附近的
#143313:top关键字，建表语句字段是关键字，在创建表的时候失败
#139826:项目打包支持
分析验证numeric null问题
#144088: windowsxp环境编译uxdb数据库

6月

1、对外支持项目7个
2、问题单6个

repmgr虚拟ip重启后无法绑定问题分析
#139826:706涉密项目问题分析
别名加不加as都无法插入，需实现该语法功能
Npgsql，主键、外键索引报错卡住问题:
#139826:insert 使用别名不加as，且字段引用别名
504门户网站php驱动适配
#148035: oracle服务退出，uxdb定时任务执行handel住未退出（贵州省疾控中心）
#148163:dotnetcore 缺动态库，原dotnet依赖库不支持（西安公共交通）
#146359:706项目合入层次查询相关代码，并打包验证功能
#139826:706 start with代码合入，并打包验证



3季度：
1、河南移动性能分析优化
2、tpcc改造支持验证
3、对外支持项目11个
4、进行部门分享

7月

#135974:河南移动与2114基线分支数据库tpcc性能比对
#151152:河南移动分支移植pg14新特性代码:
#151152:空闲连接性能下降问题分析
验证rowid对insert语句的影响
验证uxbouncer连接池效果
验证改造后的idbc连接池功能
华能区块链项目支持协助;
#151917:空闲连接性能下降问题分析 验证修改后的idbc连接池功能:
#150671河南移动稳定性问题分析，验证目前测发现主要是机器磁盘性能查引起
#151917:河南移动现场性能问题分析:
uxpool功能代码查看

8月
重庆传最、9601项目、陕西军民融合信创、中船WRT项、博华jg、UXDB PATCH版本维护、沈抚项目、

1、#135974解决现场varchar到text隐士转换性能问题1#135974:
2、#135974:对现场添加索引进行优化，有些sl组合索引比单条索引执行效率高，有些单条索引执行效率高
3、#135974:对之前优化遗漏的sql进行优化
4、#135974:筛选执行次数高的sql进行预热
5、河南移动性能问题分析讨论:
河南移动sql整理优化，查看sql类型，本地构造验证分析;
6、#154893:csn性能指标测试，csn代码移植
7、#154893:解决编译报错csn代码编译报错
8、#154893:整理select&insert平均时间在10ms以内的sql，对sal平均时间性能问题进行分析
9、uxpool部门培训资料准备&&分享
10.157558: decode代码移植
11、#80809:重庆传最
12、#155646:陕西军民融合信创项目(打包)
13、#154893: csn性能指标测试
14、#151152:海量空闲连接性能下降
15、#106431:中船WRT项(打包)
16、进行uxpool的watchdog部门培训
17、了解学习explain的功能:

9月
#135974:河南移动性能分析组织会议讨论
#135974:河南移动性能查看pg12之后性能优化情况
#135974:河南移动性能分析验证idbc对性能影响情况
#159080:博华jg打包
#159256:numeric like操作符不存在
#155333兼容模式repmgr适配
#158996:兼容模式下创建物化视图失败
#158998:兼容模式下删除where条件带列名为小写或大小写混合字符串删除成功
#159696:兼容模式，jdbc绑定参数，固定格式空串+null
#137770:uxdb patch版本维护
#137770: 2114 patch ky v10 + x86打包
#157170:2114p uos系统arm平台编译打包
#135974:河南移动性能优化sql整理
#138648:沈抚项目uxpoolcore问题分析
#157170:9601项目编译打包
查看学习explain 性能分析方法
参加uXSync同步工具介绍会议
参加uxmpp hash分布部门分享

4季度：
1、云上贵州功能开发3个
2、ISCCC测试功能开发1个
3、redmine 问题单处理19个
4、对外支持项目9个
5、930考试支持

10月

1、#138648:沈抚项目uxpoolcore问题分析
2、#162414:删除模式未级联删除该模式同义词下存在其他模式依赖的同义词
3、#162962: time with time zone与int类型数字运算，报错: operator does not exist: time with time zone + integer
4、华能区块链项目对外支持
5、熟悉正则表达式的用法:
6、#125233:调查ux dump南计信息
7、#164747:[不带安全属性的用户输入]测试项要求
8、#164771:事件触发器功能移植

11月


207入围项目 mips平台层次查询问题(该问题系环境问题，暂未解决)
东北证券带外管理系统建设项目支持(已完成)
3、#166572: 针对普通用户使用dump导出，普通用户只能导出有权访问的数据(已完成)
4、华能区块链项目支持(已完成)
5、#166877:单节点访问，会话被锁定;ssl证书到期，记录日志和审计表(已完成)
6、#167428:主备同步参数修改的操作(已完成
7、ISCCC测试项目支持gmssl脚本修改(已完成)
8、ISCCC测试用例补充验证(已完成)
9、#125233:ISCCC测试项目支持，tpce编译调试(已完成)
10、#164410:主备同步参数修改的操作(已完成)
11、#164410:207入围项目问题支持(已完成)
12、pg手册与pg内核执行计划代码浏览
13、#169050:授权状态需要显示security，方案+修改代码+打包测试打包(已完成)
14、#169617:兼容mysql功能SHOW COLUMNS FROM table完成50%
15、repmgr日志回滚调研

12月

#169617:兼容mysql功能SHOW COLUMNS FROM table
#170076:兼客mysgl功能SHOWINDEX FROM table
#170706;兼容mysl函数FORMAT
#170953:SHOW COLUMNS的Null与Key列显示值大小写与mysql不一致
#170964:UNIQUE索引不能包含NULL值并且表中没有PRIMARY KEY，SHOW COLUMNS的key列显示错误
支持.net配置，链接报错
#170706:FORMAT函数与系统函数冲突问题
#170960: mysql模式，SHOW COLUMNS的多列主键时，key列显示错误
#170990: mysql模式，当列包含自增，on update以及标识列时，SHOW COLUMNS的默认值列显示与mysg不-致，且Extra列功能未实现
#170939: mysql模式，SHOW COLUMNS创建表字段中包含大小写混合与汉字时，Field列uxdb带双引号，与mysal不-致
#171755:930考试支持
#171158:主备环境，主库修改配置参数并进行ux reload conf0，可以同步到备库





rebrand路径：
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-tools/scripts/bash/rebrand






redis_fdw
https://blog.csdn.net/seapeak007/article/details/54340839

安装redis：

sudo yum -y install hiredis-devel.x86_64


redis_fdw使用简介:
1、创建表categories记录不同分类下条目的数量

CREATE TABLE categories
(
  catid character varying(32) NOT NULL,    --主键
  cname character varying(64),    --分类名称
  nums integer,    --条目数量
  CONSTRAINT categories_pkey PRIMARY KEY (catid)
);

2、CREATE EXTENSION redis_fdw;    --创建redis_fdw扩展

3、
创建需要关联的redis服务器
CREATE SERVER redis_server
    FOREIGN DATA WRAPPER redis_fdw
    OPTIONS (address '127.0.0.1', port '6379');
	
4、创建redis中存储catid/nums映射的虚拟表
CREATE FOREIGN TABLE rd_categories (key text, val text)
            SERVER redis_server
            OPTIONS (database '0');


5、创建触发器:

CREATE OR REPLACE FUNCTION public.insert_new_item()
  RETURNS trigger AS
$BODY$  
begin
    insert into rd_categories values(NEW.catid, 0,1);
    return NEW;  
end  
$BODY$
  LANGUAGE pluxsql VOLATILE
  COST 100;
ALTER FUNCTION public.insert_new_item()
  OWNER TO uxdb;
CREATE TRIGGER new_category
  AFTER INSERT
  ON public.categories
  FOR EACH ROW
  EXECUTE PROCEDURE public.insert_new_item();

6、创建用户映射：
CREATE USER MAPPING FOR PUBLIC SERVER redis_server OPTIONS ( password 'secret');

7、
测试:
insert into categories values('123', 'ces', 0);    --插入一条数据

在redis里查看：
[root@uxdb1 bin]# ./redis-cli -p 6379
127.0.0.1:6379> keys *
"123"
127.0.0.1:6379> get 123
"0"

redis不带触发器：

redis_fdw测试用例：
CREATE EXTENSION redis_fdw;
CREATE SERVER redis_server
    FOREIGN DATA WRAPPER redis_fdw
    OPTIONS (address '127.0.0.1', port '6379');
CREATE USER MAPPING FOR PUBLIC SERVER redis_server OPTIONS ( password 'secret');
CREATE FOREIGN TABLE rd_categories (key text, val text) SERVER redis_server OPTIONS (database '0');
insert into rd_categories values ('a', '111');
select * from rd_categories;


insert into rd_categories values('fcc', '1');

在redis里查看：
[root@uxdb1 bin]# ./redis-cli -p 6379
127.0.0.1:6379> keys *
"123"
127.0.0.1:6379> get 123
"0"

redis命令：

切换指定库：
SELECT 15
清空所用表数据：
FLUSHALL


oracle_fdw:
create extension oracle_fdw;
create server osdba_fdw foreign data wrapper oracle_fdw options (dbserver '//192.71.0.244:1521/orcl');
CREATE USER MAPPING FOR uxdb SERVER osdba_fdw OPTIONS (user 'C##ora_tkb', password '123456');
CREATE  FOREIGN TABLE "test_tab" (id int,name varchar(100)) SERVER osdba_fdw OPTIONS (table 'TEST_TAB');
select * from test_tab;
INSERT INTO test_tab select generate_series(1,10),'bb';
select * from test_tab limit 5,10;




fdw（外部数据包装器）
https://www.jiangguo.net/c/wyW/2e5.html


https://github.com/pg-redis-fdw/redis_fdw
https://github.com/redis/hiredis


Latest commit number:5abc858e03e4a6946ef75983aebe4d47268c4c28




#175604:redis_fdw适配,The branch that adapts redis_fdw is REL_12_STABLE,Latest commit number:5abc858e03e4a6946ef75983aebe4d47268c4c28

redis_fdw适配对应pg对应版本，eg：REL_12_STABLE分支对应pg12，同理REL_15_STABLE对应pg15


2023-2-2


1、mpp高可用修改了什么特性，master和worker都看下
2、这次uxdb使用2115B
3、

分支代码：
support/#129384


http://192.30.1.2/uxdb/uxdb-security_reframe/%E4%BC%98%E7%82%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%9F%E8%83%BD%E6%89%8B%E5%86%8C%20V2.1/html/data-column.html#wallet


加密：

加密文档：
svn\30.项目\02.通用版

1、多个列加密时，加密系统表数据如何存储；
2、刷盘时，申请一个页原因；
3、密钥与根密钥如何进行解密；


2023-2-17



./build.sh --license=commercial --nouxfs

php编译：利于php-7.2.34版本
进入php-7.2.34主目录，执行以下命令：


./configure --prefix=/home/uxdb/uxdbinstall/driver/php

编译pdo_uxsql.so：
进入路径php-7.2.34/ext/pdo_pgsql
执行以下命令：
/home/uxdb/uxdbinstall/driver/php/bin/phpize
aclocal					//存在问题，可跳过aclocal、autoconf
autoconf
./configure --with-php-config=/home/uxdb/uxdbinstall/driver/php/bin/php-config --with-uxsql=/home/uxdb/uxdbinstall/dbsql/bin
arm编译：
./configure --with-php-config=/home/uxdb/uxdbinstall/driver/php/bin/php-config --with-pdo-uxsql=/home/uxdb/uxdbinstall/dbsql/bin
生成路径
ext/pgsql/.libs/pdo_uxsql.so

编译uxsql.so：
进入路径php-7.2.34/ext/pgsql
执行以下命令：
/home/uxdb/uxdbinstall/driver/php/bin/phpize
aclocal
autoconf
./configure --with-php-config=/home/uxdb/uxdbinstall/driver/php/bin/php-config --with-uxsql=/home/uxdb/uxdbinstall/dbsql/bin




2023-02-21

已修复版本：
REL_14_BETA1

已修复版本基版本：
REL_13_BETA1


时间线：
7966b7980138ebcee7ae986ebcc393aea38a35c0  --》e4f9737fac77a5cb03a84d1f4038d300ffd28afd


198b3716dba68544b55cb97bd120738a86d5df2d		2021-03-31 7:12（未修复）

9ee7d533dacf8594057ced2d016250f09056c284		2021-03-31 7:46（未修复）

65158f497a7d7523ad438b2034d01a560fafe6bd		2021-03-31 8:01（未修复）

055fee7eb4dcc78e58672aef146334275e1cc40d		2021-03-31 23:09（未修复）

86dc90056dfdbd9d1b891718d2e5614e3e432f35		2021-03-31 23:52(已修改)






ExecInitModifyTable


ExecModifyTable

内存未释放问题：

记录其他问题：
cpu利用率超过90%

返工计划和执行UPDATE和DELETE。

这个补丁做了两组密切相关的更改:

1.对于UPDATE, ModifyTable节点的子计划现在只交付已更改列的新值(即，在查询的SET子句中计算的表达式)以及行标识信息(如CTID)。ModifyTable必须重新获取原始元组，
以合并任何未更改列的旧值。这样做的核心优势是，在继承或分区目标关系的所有表中，更改后的列是一致的，而其他列可能不是。当UPDATE涉及连接时，第二个优点是需要通过计划树的数据更少。
当然，缺点是需要额外获取每个要更新的元组。然而，这在上下文中似乎是非常自由的;即使是最坏情况的测试也没有显示它对总查询成本的增加超过百分之几。在某些情况下，
将重新获取与元组访问结合起来可能会很有趣，ModifyTable必须这样做才能标记旧元组死亡;但这将需要大量的重构，似乎不会买那么多，所以这个补丁没有尝试它。

2.对于继承的UPDATE/DELETE，我们不再为每个目标关系生成一个单独的子计划，而是生成一个与SELECT计划完全相同的子计划，然后将ModifyTable置于子计划之上。
为了让ModifyTable知道给定的输入行指的是哪个目标关系，将向行标识信息添加一个表类垃圾列。这样就摆脱了inheritance_planner()这种可怕的hack，
在存在许多unprunable 的目标关系的情况下消除了O(N^2)计划成本和内存消耗。

点2当然需要点1，这样就有了子计划返回的非垃圾列的统一定义。
但是，如果我们想在分区层次结构中同时拥有普通表和外部表，就不能坚持对行标识垃圾列进行统一定义。因为不能让每个子表都有自己的行标识列，
所以这个补丁包含了将类似的行标识列合并到subplan结果的一列中的条款。
特别是，我们可以将fdw通常用作行标识的整行Vars合并为一列，假设它们是RECORD类型。(不过，对于实际的复合Datums来说，使用表的行类型OID标记仍然是可以的。)

在这个补丁中还有更多的工作可以做，但现在似乎是可以接受的。

FDW作者应该注意以下几个API变化:

* AddForeignUpdateTargets()的参数列表已经改变，它必须使用的方法添加垃圾列到查询。调用add_row_identity_var()，而不是直接操作解析树。
你可能也需要重新考虑添加的内容。

* PlanDirectModify()现在必须稍微努力找到ForeignScan计划节点;如果外部表是分区层次结构的一部分，那么ForeignScan可能不是ModifyTable的直接子表。有关示例代码，请参阅postgres_fdw。

*要检查一个关系是否是目标关系，将其relid与root->parse->resultRelation进行比较已经不够了。
相反，根据需要检查all_result_relids或leaf_result_relids。



    update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
        );

update parted_tab set b = 'b'
from
  (select a from some_tab union all select a+1 from some_tab) ss (a)
where parted_tab.a = ss.a;
select tableoid::regclass::text as relname, parted_tab.* from parted_tab order by 1,2;

修改不全：
未修改
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/replication/logical/worker.c
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/executor/execIndexing.c

标记注释：
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/executor/execPartition.c




/* #177670:Rework update 修改点不同记录 */
/* 
 * SHA-1: fb5883da86154c3126264bfd97b0cd6f293bcebd
 * Remove PartitionRoutingInfo struct.
 * 
 */
 
 
e1551f96e643a52a035c3b35777d968bc073f7fc


目前问题：
日期：2023/3/01
存储过程内存膨胀问题工作进展：

1、目前标准版除ux_pathman、uxdb_fdw还需要开发进行定位测试验证,其他功能基本验证正常，
2、兼容版还未进行验证，
预估1-2天完成以上问题；
3、
现场内存膨胀问题，目前已验证正常， 后面佳慧验证还有其他问题，明天佳慧是否可以用新包验证下新问题是否存在；
4、
然后明天测试就可以开始介入测试，具体新包提供时间看明天测试情况；




src/backend/executor/nodeModifyTable.c src/backend/nodes/equalfuncs.c src/backend/optimizer/util/appendinfo.c src/test/regress/compatible_testcase/expected/inherit.out src/test/regress/compatible_testcase/expected/insert_conflict.out src/test/regress/compatible_testcase/expected/partition_join.out src/test/regress/compatible_testcase/expected/partition_prune.out src/test/regress/compatible_testcase/expected/rowsecurity.out src/test/regress/compatible_testcase/expected/updatable_views.out src/test/regress/compatible_testcase/expected/update.out src/test/regress/compatible_testcase/expected/with.out

2023-03-03
逻辑复制
https://blog.51cto.com/2012ivan/2524740

1、
配置postgresql.conf

wal_level = logical

2、创建发布者

yangjie=# create table users(id int, name name);
CREATE TABLE
yangjie=# create publication pub1 for table users;
CREATE PUBLICATION
创建发布者pub1,并添加表users.
另一种用法是添加数据库中所有用户表到发布者alltables:

create publication alltables for all tables;

3、另一个机器创建表users和订阅者

yangjie=# create subscription sub1 connection ‘host=192.71.0.139 port=5432 dbname=uxdb’ publication pub1;
NOTICE: created replication slot “sub1” on publisher
CREATE SUBSCRIPTION

创建订阅者时，表不会被复制，我们需要先自己创建这些表，如果没有发现本地表复制将会失败。

当发布者添加新表时，订阅者不能自动的获知，我们需要更新订阅者：

alter subscription sub1 refresh publication;

4、
为了逻辑复制能在下游节点正确执行UPDATE和DELETE，我们需要定义如何找到唯一行，这就是复制标识，默认情况下，复制标识将是表的主键，如果已经定义了主键，将不需要做任何动作，

alter table users add primary key(id);
发布者和订阅者都要执行

明确定义复制标识
yangjie=# alter table users replica identity using index users_pkey;

5、执行update、delete






p *(A_Const*)(((A_Expr*)(((SelectStmt*)((RawStmt *)raw_parsetree_list->head->data)->stmt)->whereClause))->rexpr)




2023-03-09


create  table t1(id  bit(3));
insert into t1 values(B'001');
insert into t1 values(B'010');
insert into t1 values(B'011');
insert into t1 values(B'100');
insert into t1 values(B'101');
insert into t1 values(B'110');
insert into t1 values(B'111');

select * from t1 where id = 2;
select * from t1 where id != 2;
select * from t1 where id > 2;
select * from t1 where id >= 2;
select * from t1 where id < 2;
select * from t1 where id <= 2;

select * from t1 where id = 8;
select * from t1 where id != 8;
select * from t1 where id < 8;
select * from t1 where id <= 8;
select * from t1 where id > 8;
select * from t1 where id >= 8;


select * from t1 where 2 = id;
select * from t1 where 2 != id;
select * from t1 where 2 > id;
select * from t1 where 2 >= id;
select * from t1 where 2 < id;
select * from t1 where 2 <= id;

select * from t1 where 8 = id;
select * from t1 where 8 != id;
select * from t1 where 8 < id;
select * from t1 where 8 > id;
select * from t1 where 8 <= id;
select * from t1 where 8 >= id;



copy vd_his_alarm from '/home/uxdb/uxdbinstall/dbsql/bin/vd_his_alarm_202302221655.csv' WITH csv header delimiter ',';

存储过程内存膨胀问题：

使用现场存储过程语句与数据，目前sql执行缓慢问题已解决，内存未释放问题正常；
但使用改造后的存储过程语句多次执行存在以下问题，且该问题必先：（改造存储过程语句中存在太多次update、delete）
问题一：存储过程语句执行第一次，内存从400MB增长200MB到600MB，之后每次增长10MB，第六次，内存增长翻倍（从600M变为1.2GB），后面再执行20多次，内存变化稳定在10M；
分析结果：
1、pg14和pg最新版本15.2也存在该问题；
2、通过查看统计信息， 存储过程访问共享内存比较频繁；
3、直接执行存储过程中的sql未复现问题一；
目前分析方法是通过调试内存上下文去查看内存释放问题，需要确定位置，
uxdb的内存都是通过内存上下文进行分配，需要调试内存上下文对于内存申请释放情况，分析内存泄露问题；


pg内存分配和操作系统内存分配：
https://www.modb.pro/db/486292


调用栈：
#0  BuildCachedPlan (plansource=0x2cf95c0, qlist=0x0, boundParams=0x1f23e40, queryEnv=0x0)
    at plancache.c:885
#1  0x0000000000a473d8 in GetCachedPlan (plansource=0x2cf95c0, boundParams=0x1f23e40,
    useResOwner=true, queryEnv=0x0) at plancache.c:1214
#2  0x000000000074b7c3 in _SPI_execute_plan (plan=0x1f5b140, paramLI=0x1f23e40, snapshot=0x0,
    crosscheck_snapshot=0x0, read_only=false, fire_triggers=true, tcount=0) at spi.c:2225
#3  0x0000000000748d6a in SPI_execute_plan_with_paramlist (plan=0x1f5b140, params=0x1f23e40,
    read_only=false, tcount=0) at spi.c:577
#4  0x00007f51fae53d59 in exec_stmt_execsql (estate=0x7ffd55b92e50, stmt=0x1f84ff8) at pl_exec.c:4170
#5  0x00007f51fae4fa19 in exec_stmt (estate=0x7ffd55b92e50, stmt=0x1f84ff8) at pl_exec.c:2040
#6  0x00007f51fae4f71b in exec_stmts (estate=0x7ffd55b92e50, stmts=0x1f6c2b8) at pl_exec.c:1931
#7  0x00007f51fae4f5cf in exec_stmt_block (estate=0x7ffd55b92e50, block=0x7f520d2adfc0)
    at pl_exec.c:1872
#8  0x00007f51fae4f818 in exec_stmt (estate=0x7ffd55b92e50, stmt=0x7f520d2adfc0) at pl_exec.c:1964
#9  0x00007f51fae4d327 in pluxsql_exec_function (func=0x1e906f0, fcinfo=0x7ffd55b93140,
    simple_eval_estate=0x0, atomic=false) at pl_exec.c:596
#10 0x00007f51fae47be8 in pluxsql_call_handler (fcinfo=0x7ffd55b93140) at pl_handler.c:269
#11 0x0000000000682e16 in ExecuteCallStmt (stmt=0x1e64108, params=0x0, atomic=false, dest=0x1e64708)
    at functioncmds.c:2474



/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/utils/cache/plancache.c:1179			//CachedPlan


内存使用情况：




1、直接执行：
    update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
        );

存储过程：
create procedure tstprc_sa_sts_vehicle_alarm_day2(sts_time_str character varying)
    language pluxsql
as
$$
begin
    update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
        );
end;
$$;

2、直接执行：
update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.sts_time = '2023-02-19 12:00:00'::timestamp and ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
            where a.beg_gnss_time >= '2023-02-19 00:00:00'::timestamp
              and a.beg_gnss_time <= '2023-02-20 23:59:59'::timestamp
              and t.alarm_src is not null
        );

存储过程：
create procedure tstprc_sa_sts_vehicle_alarm_day(sts_time_str character varying)
    language pluxsql
as
$$
begin
update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.sts_time = '2023-02-19 12:00:00'::timestamp and ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
            where a.beg_gnss_time >= '2023-02-19 00:00:00'::timestamp
              and a.beg_gnss_time <= '2023-02-20 23:59:59'::timestamp
              and t.alarm_src is not null
        );
end;
$$;

由于ux_opclass的opcintype对应ux_amop的左操作符类型，左操作符类型为int4，
左操作符int4对应的操作符类integer_ops, 操作符类对应的操作符族唯一，故左操作符为int4时，使用integer_ops操作符类

2023-03-22

bit与bool类型比较

create  table t1(id  bit(3), city char(60));
insert into t1 values(B'001', '111');
insert into t1 values(B'010', '222');
insert into t1 values(B'011', '333');
insert into t1 values(B'100', '444');
insert into t1 values(B'101', '555');
insert into t1 values(B'110', '666');
insert into t1 values(B'111', '777');

select * from t1 where id > 1::bool;
select * from t1 where id >= 1::bool;
select * from t1 where id = 1::bool;
select * from t1 where id != 1::bool;
select * from t1 where id <= 1::bool;
select * from t1 where id < 1::bool;

select * from t1 where id > 0::bool;
select * from t1 where id >= 0::bool;
select * from t1 where id = 0::bool;
select * from t1 where id != 0::bool;
select * from t1 where id <= 0::bool;
select * from t1 where id < 0::bool;

设计方案：
1、mysql bit类型精度与uxdb的区别
2、mysql还支持哪些类型操作符，（还支持哪些操作符类型比较）；


2023-03-24

cpu:mips

编译分支：
hotfix/ver2.1.1.5Cp

编译方式：
1、带参数--enable-root、--uxgmssl
2、--with-openssl --with-libxml 去掉
3、不带license

打包记录：
打包方式：rpm包
打包内容：
1、带驱动jdbc/odbc
2、带工具admin

编译命令：
./build.sh --license=internal --enable-root --uxgmssl
打包命令：

执行/install/autopkg/rpmpkg/release.sh
~/rpmbuild/RPMS/aarch64/下生成rpm包。
神威：
configure编译带参数--without-readline；


2023-03-29

人工智能
1、chatGPT
访问地址：https://chat.openai.com/

2、百度的文言一心
访问地址：https://yiyan.baidu.com/

3、Copilot X，代码自动生成工具
访问地址：https://github.com/features/preview/copilot-x

4、Notion AI，写文章
访问地址：https://www.notion.so/

5、Midjourney,画图
访问地址：https://www.midjourney.com/
账号：
WGreatLove#9374/wang_qi@uxsino.com
密码：
926474.wq

Midjourney使用教程：
https://www.163.com/dy/article/I0KKE30S05561X2T.html




3、odbc用例

2023-03-31

实现功能：

缺少系统表：
"DBA_JOBS"


1、oracle的描述
2、我们可以用cron的功能去实现增加对应的DBA_JOB系统表或视图，内部调用cron相关的函数去实现L
3、但是难点在于要实现上面定时器的相关函数，工作量大
4、现场目前只使用了这个DBA_JOB系统表进行查询，系统表的数据维护需要相关函数，也可以直接插入数据

刚现场提供的图片中这些字段咱们ux_cron中cron.job都不存在；

1、
DBA_JOBS系统表用于存储数据库中计划作业信息，与咱们数据库的ux_cron类似，
DBA_JOBS系统表记录的字段值较多，且存在以下调度器管理用法；

oracle调度器管理用法：
调度器实现的功能，通过包dbms_job实现，
dbms_job所包含的过程：
submit:提交预定时间执行的作业
remove:从作业队列中删除以前提交的作业
change:更改已提交作业的参数(描述、下一次运行时间、执行时间间隔)
broken:禁止作业队列中某作业
interval:改变作业队列中某作业执行的时间间隔
next_date:改变作业队列中某作业的下一次执行时间
run:强制运行作业队列中某一作业，而不管本身的作业调度；

eg：创建一个调度信息
创建一个新的 DBA_JOB
BEGIN
  DBMS_JOB.SUBMIT(
    job       => 1,
    what      => 'BEGIN MY_JOB; END;',
    next_date => TO_DATE('2023/04/01 09:00:00', 'YYYY/MM/DD HH24:MI:SS'),
    interval  => 'SYSDATE + 1'
  );
  COMMIT;
END;
/

实现方法可以映射咱们数据库ux_cron调度器用法，

2、我们可以用cron的功能去实现增加对应的DBA_JOB系统表或视图，内部调用cron相关的函数去实现
3、但是难点在于要实现上面定时器的相关函数，工作量大
4、现场目前只使用了这个DBA_JOB系统表进行查询，系统表的数据维护需要相关函数，也可以直接插入数据

目前工作安排：
1、添加系统表DBA_JOBS，；
2、实现系统表DBA_JOBS各个字段功能，实现oracle调度器管理用法（调度器管理用法较多，需要排优先级）；




oracle调度器管理用法：
1、创建一个新的 DBA_JOB
BEGIN
  DBMS_JOB.SUBMIT(
    job       => 1,
    what      => 'BEGIN MY_JOB; END;',
    next_date => TO_DATE('2023/04/01 09:00:00', 'YYYY/MM/DD HH24:MI:SS'),
    interval  => 'SYSDATE + 1'
  );
  COMMIT;
END;
/

2、修改 DBA_JOB 的执行时间
BEGIN
  DBMS_JOB.INTERVAL(
    job       => 1,
    interval  => 'SYSDATE + 2'
  );
  COMMIT;
END;
/

3、删除 DBA_JOB
BEGIN
  DBMS_JOB.REMOVE(
    job       => 1
  );
  COMMIT;
END;
/



create table t1(root_id numeric,id numeric,name varchar2(20),description varchar2(20));
create table t2(root_id numeric,id numeric,name varchar2(20),description varchar2(20));
create table t3(root_id numeric,id numeric,name varchar2(20),description varchar2(20));
insert into t1 values(0,1,'a','aaa');
insert into t1 values(1,2,'a1','aaa1');
insert into t2 values(0,1,'a','aaa');
insert into t2 values(1,2,'a1','aaa1');
insert into t3 values(0,1,'a','aaa');
insert into t3 values(1,2,'a1','aaa1');
select o.root_id,o.id,o.name from (select * from t1) o left join (select * from t2) f on o.id = f.id left join (select * from t3) o on f.id = o.id; 

select o.root_id,o.id,o.name from (select * from t1) o left join (select * from t2) o on id = o.id; 

select o.root_id,o.id,o.name from (select * from t1) o left join (select * from t2) o on id = o.id; 

2023-04-04

operator 别名问题：

select 1 operator;






实现别名不加as，支持OPERATOR作为别名

expr_alias:
    expr alias_name
    {
        $$ = makeNode(ResTarget);
        $$->name = $2;
        $$->indirection = NIL;
        $$->val = (Node *)$1;
        $$->location = @1;
        $$->alias_type = AT_NORMAL;
    }
    | expr OPERATOR alias_name
    {
        $$ = makeNode(ResTarget);
        $$->name = $3;
        $$->indirection = NIL;
        $$->val = (Node *)$1;
        $$->location = @1;
        $$->alias_type = AT_OPERATOR;
    }
    ;

alias_name:
    IDENT
    {
        $$ = pstrdup($1);
    }
    | OPERATOR
    {
        $$ = pstrdup($1);
        if (!pg_strcasecmp($1, "as")) {
            yyerror("invalid operator alias: 'as' is a reserved keyword");
        }
    }
    ;



@@ -441,6 +441,12 @@ typedef struct A_ArrayExpr
        int                     location;               /* token location, or -1 if unknown */
 } A_ArrayExpr;

+typedef enum
+{
+    AT_NORMAL,
+    AT_OPERATOR
+} AliasType;
+
 /*
  * ResTarget -
  *       result target (used in target list of pre-transformed parse trees)
@@ -466,6 +472,7 @@ typedef struct ResTarget
        List       *indirection;        /* subscripts, field names, and '*', or NIL */
        Node       *val;                        /* the value expression to compute or assign */
        int                     location;               /* token location, or -1 if unknown */
+       AliasType alias_type;  /* alias type: normal or operator */
 } ResTarget;


2023-04-06
1、适配docker

在2115C分支，麒麟v10 arm平台适配；


问题：
1、启动uxdb容器后，如何删除该容器
执行命令：
sudo docker ps -a			//查看启动的docker进程；
sudo docker rm -f  xxx		//杀死指定docker进程；

整理输出：
麒麟v10 arm平台基于centos镜像；



参考资料：
https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html

docker能够将所需的软件包及其依赖项打包成容器，并在不同的平台上运行。
不过，不能在不同cpu的架构运行，由于不同的 CPU 架构之间存在差异，
例如：它们具有不同的指令集和寄存器等；


2023-04-07

切换到root时，yum可以正常执行，使用sudo时，yum就有问题

这个问题可能是由于sudo用户环境变量配置不正确导致的。可以尝试以下几个解决方案：

1.使用sudo -i命令切换到root用户，这将会完全切换到root用户的环境。

2.尝试在/etc/sudoers文件中配置Defaults env_keep += "PYTHONPATH"，这将保留PYTHONPATH环境变量并在sudo用户中设置正确的Python路径。

3.如果您已经使用了以上两种方法但仍然无法解决问题，请检查您的PYTHONPATH环境变量是否正确配置，并使用echo $PYTHONPATH命令检查。

4.如果PYTHONPATH环境变量未正确配置，请在sudo用户的.bashrc文件中设置正确的PYTHONPATH环境变量，或者将PYTHONPATH添加到sudo命令的命令行中。

5.最后，您可以尝试重新安装yum和相关的依赖项，以确保所有文件都已正确安装并配置。


2023-04-10


打包：
./build.sh --version=2.1.1.5C --license=commercial --nouxfs --extended_parameters --block-size=4

JA01070578202220398 电科云项目号


问题：
sysbench测试UXDB性能和mysql差距较大：
安装sysbench：
安装依赖：
yum install automake libtool –y


目的：
找到方法、并优化；

系统环境：
centos x86
数据库版本：
MySQL5.7.29  hotfix/ver2.1.1.4p

其他问题记录：
benchmark，读多写少场景，MySQL也优于UXDB（需要测试验证下）

参数解释：
--table_size				//表示表的行数
oltp_write_only 参数：用于运行一个只写的 OLTP 基准测试。这将模拟一个高度并发的写入负载，通常用于测试数据库的写入性能。
使用 oltp_write_only 参数时，不能使用 oltp_read_write 参数，因为后者包含了读取操作。

prepare 命令：用于准备数据库以进行基准测试。该命令将创建所需的表和数据，并将其加载到数据库中，以便进行测试。

--percentile 参数：用于指定要计算的百分位数。例如，如果您希望计算 99.9% 的响应时间，可以使用 --percentile=99.9 参数。sysbench 默认计算 95% 的响应时间。

--report-interval 参数：用于指定报告结果的时间间隔，以秒为单位。例如，如果您希望每 10 秒报告一次结果，则可以使用 --report-interval=10 参数。sysbench 默认每秒报告一次结果。

oltp_read_only 参数：用于运行一个只读的 OLTP 基准测试。这将模拟一个高并发的读取负载，通常用于测试数据库的读取性能。使用 oltp_read_only 参数时，不能使用 oltp_write_only 参数，因为后者包含了写入操作。

run 命令：用于运行基准测试。在使用 run 命令之前，必须使用 prepare 命令来准备数据库。

准备sql：
uxdb:
sysbench --db-driver=pgsql --pgsql-host=127.0.0.1 --pgsql-port=5432 --pgsql-user=uxdb --pgsql-db=uxdb --pgsql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600  --threads=4  oltp_write_only prepare

mysql：
sysbench --db-driver=mysql --mysql-host=localhost --mysql-port=3308 --mysql-user=root --mysql-db=mysql --mysql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600  --threads=4  oltp_write_only prepare

执行sql：
uxdb：
sysbench --db-driver=pgsql --pgsql-host=127.0.0.1 --pgsql-port=5432 --pgsql-user=uxdb --pgsql-db=uxdb --pgsql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600   --threads=8 --percentile=95 --report-interval=60 oltp_read_only run  >> ./log/sysbench_oltpX_8_20230411.log

sysbench --db-driver=pgsql --pgsql-host=127.0.0.1 --pgsql-port=5432 --pgsql-user=uxdb --pgsql-db=uxdb --pgsql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600   --threads=16 --percentile=95 --report-interval=60 oltp_read_only run  >> ./log/sysbench_oltpX_16_20230411.log

sysbench --db-driver=pgsql --pgsql-host=127.0.0.1 --pgsql-port=5432 --pgsql-user=uxdb --pgsql-db=uxdb --pgsql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600   --threads=32 --percentile=95 --report-interval=60 oltp_read_only run  >> ./log/sysbench_oltpX_32_20230411.log

sysbench --db-driver=pgsql --pgsql-host=127.0.0.1 --pgsql-port=5432 --pgsql-user=uxdb --pgsql-db=uxdb --pgsql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600   --threads=100 --percentile=95 --report-interval=60 oltp_read_only run  >> ./log/sysbench_oltpX_100_20230411.log

mysql：
sysbench --db-driver=mysql --mysql-host=localhost --mysql-port=3308 --mysql-user=root --mysql-db=mysql --mysql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600   --threads=8 --percentile=95 --report-interval=60 oltp_read_only run  >> ./log/sysbench_oltpX_8_20230411.log

sysbench --db-driver=mysql --mysql-host=localhost --mysql-port=3308 --mysql-user=root --mysql-db=mysql --mysql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600   --threads=16 --percentile=95 --report-interval=60 oltp_read_only run  >> ./log/sysbench_oltpX_16_20230411.log

sysbench --db-driver=mysql --mysql-host=localhost --mysql-port=3308 --mysql-user=root --mysql-db=mysql --mysql-password=1qaz\!QAZ --table_size=50000000 --tables=8 --events=0 --time=600   --threads=32 --percentile=95 --report-interval=60 oltp_read_only run  >> ./log/sysbench_oltpX_32_20230411.log



输出结果：

events：各个线程执行操作的平均数量；

机器：
ssh -p 60225 uxdb@117.34.70.110
密码：
uxdb/Uxsino@1234


| datadir       | /var/lib/mysql/ |
| basedir       | /usr/ |

my.cnf配置报错：

------------------innodb
innodb_data_file_path           = ibdata1:100M:autoextend
innodb_undo_tablespaces = 3
#------------------- log-
删除带路径的参数

117.34.70.110机器修改记录：
1、
[root@localhost ~]# ll /uxdbdata/
total 3372896
drwx------. 20 mysql mysql       4096 Feb  6 17:00 compatible
drwx------. 20 mysql mysql       4096 Aug 24  2022 compatible_bad1
drwx------. 20 mysql mysql       4096 Aug 23  2022 compatible_bak_bak
-rw-rw-r--.  1 mysql mysql 3453696911 Nov  1 17:11 linuxx64_12201_database.zip
drwx------. 20 mysql mysql       4096 Jul 11  2022 mppworker5
drwx------. 20 mysql mysql       4096 Jul 11  2022 mppworker5_2
drwx------. 20 mysql mysql       4096 Jul 11  2022 mppworker5_3
drwx------. 20 mysql mysql       4096 Jul 12  2022 mppworker5_5
drwx------. 20 mysql mysql       4096 Jul 11  2022 mppworker5_bak
drwxr-x---.  3 mysql mysql        228 Apr 11 17:24 mysql
-rw-------.  1 mysql mysql          0 Aug 23  2022 nohup.out
drwxrwxr-x.  2 mysql mysql        113 Jul 11  2022 tpccs
-rw-rw-r--.  1 mysql mysql     113459 Jul 12  2022 tpccs_225.zip
2、

修改安全上下文类型：
查看：
ls -Z /var/lib/mysql
ls -Z /var/log/mysql
ls -Z /uxdbdata/mysql

修改：
修改成功命令：
sudo chcon -Rv --type=mysql_log_t /var/log/mysql
sudo chcon -Rv --type=mysqld_db_t /uxdbdata/mysql
未验证命令：
sudo semanage fcontext -a -t mysqld_db_t '/uxdbdata/mysql(/.*)?'

3、mysql在非/var/lib路径下初始化集簇，服务器启动报错：
原因：尝试多种方法，修改属组、修改安全上下文类型等方式，发现selinux对这块有做限制；
修改方法：
sudo vi /etc/sysconfig/selinux
将SELINUX的值更改为disabled：
原始值是SELINUX=enforcing

2023-04-12

性能分析：
1、先测试机器瓶颈（如cpu、io）
通过以下命令查看：
查看cpu利用率：
top -c#		//查看%Cpu(s):数值
查看io瓶颈：
iostat -x 10 60 -d sdc			//-d指定数据所在分区盘名称，60表示测试60s，10表示间隔10s统计一次数据，如果%util达到100%，说明磁盘io到达瓶颈；


性能测试：
1、清理内存
清理cache：
sync：将文件系统缓存数据同步到磁盘中，防止数据丢失。
echo 1 > /proc/sys/vm/drop_caches		//：清除 PageCache （页面缓存）。
echo 2 > /proc/sys/vm/drop_caches		//：清除 PageCache 和 dentries （目录缓存）。
echo 3 > /proc/sys/vm/drop_caches		//：清除 PageCache、dentries 和 inodes （索引节点缓存）


性能测试：
ssh -p 60225 uxdb@117.34.70.110
uxdb/Uxsino@1234




2023-04-13

qt安装环境：
中标麒麟Linux服务器5.0（mips64el）安装QT开发环境

qt相关问题单：
173757 

qt 5.9.8安装：

一、源码安装
1、下载地址
https://download.qt.io/archive/qt/5.9/5.9.8/single/

configure前安装依赖库：
expat-devel、fontconfig-devel、freetype-devel、glib2-devel、gl-manpages、libdrm-devel、libICE-devel、libjpeg-turbo-devel、libSM-devel-1.2.2-2、libX11-devel、libXau-devel、libxcb-devel、libXdamage-devel、libXext-devel、libXfixes-devel、libXi-devel、libXxf86vm-devel、mesa-libEGL-devel、mesa-libGL-devel、pcre-devel、pkgconfig、xorg-x11-proto-devel、zlib-devel

qt编译命令：
./configure -no-opengl -opensource -confirm-license -prefix /opt/Qt5.9.8 -nomake examples -nomake tests


./configure -no-opengl -opensource -confirm-license -release -qt-zlib -qt-libpng -qt-libjpeg -qt-freetype -qt-harfbuzz -qt-pcre -nomake examples -nomake tests mips64el-neokylin-linux-g++

现场编译命令（现场命令可以编译成功，最终用的这个命令）：
./configure -prefix /opt/Qt-5.9/qt5.9.8 -release -opensource -nomake tests -nomake examples -confirm-license -shared -qt-zlib -pch -gui -make libs -make tools

2、编译驱动

步骤一：先rebrand驱动psql，需要修改rebrand脚本文件substitution.data，添加PSQL为UXSQL

步骤二：
修改头文件：
./qtbase/src/sql/kernel/qsqldriver.h
QSqlDriver类中添加宏UXSQL
修改代码：
将QSqlDriver类PSQL引用改为UXSQL
src\plugins\sqldrivers\uxsql\qsql_uxsql.cpp

步骤三：编译
编译路径：
qt-everywhere-opensource-src-5.9.8/qtbase/src/plugins/sqldrivers/uxsql
修改编译文件uxsql.pro：
添加以下两行变量：
INCLUDEPATH += "/opt/uxdbinstall/include"
LIBS += -L/opt/uxdbinstall/lib -luxsql
步骤四：
编译命令(可以手动修改驱动名称)：
qmake uxsql.pro
make
make install

报错：
1）
报错信息：
psql库不存在（未找到）
解决方法：
将文件psql.pro下面这一行注释：
QMAKE_USE += psql



二、安装包安装
https://hpzwl.blog.csdn.net/article/details/123840699



qt安装机器：
10.1.106.9 root/Uxsino@2021

qt驱动测试：
qmake test_uxsql_qt.pro
make
./test_uxsql_qt



解决问题：
1、解决指针转int精度问题：错误：从‘void*’到‘int’的转换损失精度
在makefile中，添加以下参数：
CXXFLAGS="-fpermissive"

2、添加库路径
export LD_LIBRARY_PATH=/usr/lib64/:/usr/lib/:$LD_LIBRARY_PATH



在使用 GCC 编译器时，你可以在 Makefile 中加入 -Wno-pointer-to-int-cast 选项。




`疑难问题解决：`

1、yum源问题
问题：
yum源无法下载需要的库（对于头文件或者缺少哪个库依赖哪个源，通过百度或者gpt搜索）

解决方法：
步骤一：先确定需要哪个源库（通过报错，在百度或者gpt搜索对应的库源）
步骤二：查看yum源文件
例如：中标麒麟（cpu 龙芯（mips64））（NeoKylin Military Server 5.0 ）
对应源文件路径：/etc/yum.repos.d/neokylin.repo
yum源链接：http://download.cs2c.com.cn/neokylin/server/releases/5.2/ls_64/os/V5.2-Build10.8/

工作内容：
2023/4.17-4.21
#182593：兼容mysql数据库bit类型比较操作符
#129384：qt5.9.8、qt5.6.2部署
#183028：北华商舟.net适配
#169347：支持云上贵州.net问题


2023-04-20
.net相关：
.net介绍：

.net包含.net Framework与.net core
.net core是.net Framework的升级，.net core可以跨平台使用；
.net、.net core与Entity Framework区别：
1、
Entity Framework是为.NET Framework设计的
Entity Framework 对应Npgsql的库，通过以下命令安装：
Install-Package Npgsql
这将会安装Npgsql驱动以及与Entity Framework集成所需的相关依赖项
2、
Entity Framework Core是.NET平台的一个组件，它是.NET Core中的官方ORM（对象关系映射）框架，用于简化数据库操作和数据访问；
Entity Framework Core是专为.NET Core设计的；
Entity Framework Core对应Npgsql的库，通过以下命令安装：
Install-Package Npgsql.EntityFrameworkCore.PostgreSQL
3、
npgsql在3.1版本及以后支持.net core

关于Entity Framework Core介绍，以及简单用例编写，Entity Framework Core就是用C#语句实现sql操作：
https://blog.csdn.net/lihuxie/article/details/132677571
Entity Framework Core官方网址：
https://learn.microsoft.com/zh-cn/ef/core/



使npgsql在linux可以使用：
centos x86:
步骤：
1、centos安装.net运行环境
见链接：
https://learn.microsoft.com/zh-cn/dotnet/core/install/linux-centos

sudo yum install dotnet-sdk-5.0

kylin v10 x86安装dotnet：
sudo yum install dotnet-sdk-3.1.x86_64

查看dotnet版本、及安装路径：
dotnet --list-sdks

2、在npgsql源码路径下执行：
生成dll驱动：
dotnet build -c Release Npgsql.sln


创建一个新的 .NET Core 项目或打开一个现有项目，将 Npgsql.dll 添加到项目引用
dotnet add <项目名称>.csproj reference <Npgsql.dll路径>
<Npgsql.dll路径>应替换为实际生成的 Npgsql.dll 文件的路径。

3、修改program.cs工程文件，将测试代码添加到工程文件中
工程测试代码：

using System;
using Npgsql;

class Program
{
    static void Main(string[] args)
    {
        try
        {
            using (var conn = new NpgsqlConnection("Host=myserver;Username=mylogin;Password=mypassword;Database=mydatabase"))
            {
                conn.Open();
                Console.WriteLine("Connection successful!");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Connection failed: " + ex.Message);
        }
    }
}

实际操作步骤：

拉取npgsql分支代码：
git clone https://github.com/npgsql/npgsql.git

查看sdk版本，确定npgsql版本，切换分支：
查看dotnet版本、及安装路径：
dotnet --list-sdks
git checkout tags/v7.0.1

编译命令：
dotnet build -c Release Nuxsql.sln -p:FrameworkPathOverride=/usr/share/dotnet/sdk

生成路径：
./src/Npgsql/bin/Release/net7.0/Npgsql.dll


nuxsql驱动测试用例：
1、创建控制台应用程序：
dotnet new console -o testapp

2、工程引用驱动库：
如果是Npgsql：
dotnet add package Npgsql --version 5.0.0

如果是Nuxsql:
修改工程文件<项目名称>.csproj，
<ItemGroup>
  <Reference Include="Nuxsql.dll路径">
  </Reference>
</ItemGroup>

需要安装依赖项有两种方式：
1）、可以修改工程文件<项目名称>.csproj，添加以下内容：
<ItemGroup>
  <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
</ItemGroup>

2）、也可以通过命令安装：
dotnet add package Microsoft.Extensions.Logging.Abstractions

3、编写Program.cs文件
4、运行工程文件：
dotnet run

kylin arm64适配dotnet：


安装dotnet
wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh
运行此脚本之前，需要授予此脚本作为可执行文件运行的权限：
sudo chmod +x ./dotnet-install.sh
若要安装最新版本（可能不是 (LTS) 版本），请使用 --version latest 参数，本次安装6.0版本，使用命令：
./dotnet-install.sh --channel 6.0 --install-dir /home/uxdb/script/uxdb --verbose

编译nuxsql：
首先拉取npgsql代码，此版本需要与dotnet版本对应，比如：dotnet为6.0版本，npgsql也需要6.0版本：
git clone https://github.com/npgsql/npgsql.git

rebrand源码npgsql到nuxsql；
在nuxsql源码目录下执行编译命令：
dotnet build -c Release Nuxsql.sln -p:FrameworkPathOverride=“dotnet的sdk安装路径”

生成路径：
src/Npgsql/bin/Release/net7.0/Npgsql.dll


要使用 Entity Framework Core PostgreSQL 库，需要先安装 NuGet 包,安装命令：
Install-Package Npgsql.EntityFrameworkCore.PostgreSQL





2023-04-23
4月份工作：
1、#179300：bit与int类型比较操作支持支持	
2、#178914：redis_fdw 主线安全、兼容适配，并进行打包验证
3、#180580：mysql兼容：支持bit类型与bool类型比较操作
4、#169347：云上贵州 银河麒麟v10 x86打包支持
5、#175655：2115c项目打包
6、#176624：ux_cron支持妙计精度移植云上贵州分支并编译测试打包
7、#180943：保密四期资质:提供平台版本	
8、#136538：cdps-UXDB静默安装
9、#136538：odbc测试用例支持验证
10、#181576：兼容oracle系统视图DBA_JOBS
11、#181580:兼容oracle左右链接as相同别名指定多次
12、#181577:支持operator关键字不带as可以作为别名
13、#181982:银河麒麟 arm适配docker（50%）
14、#177093：用友项目交流中反馈sysbench测试UXDB性能和mysql差距较大
15、#129384：qt5.9.8、qt5.6.2部署
16、#180580：bit操作符编译冲突报错
17、#183028：北华商舟在linux适配.net

drop table tb3;
create table tb3(id BIGINT);
insert into tb3 values(1);
NUMERIC、DECIMAL、FLOAT、DOUBLE
SELECT B'1' = CAST(1 AS TINYINT);
SELECT B'1' = CAST(1 AS SMALLINT);
SELECT B'1' = CAST(1 AS MEDIUMINT);
SELECT B'1' = CAST(1 AS INT);
SELECT B'1' = CAST(1 AS BIGINT);
SELECT B'1' = CAST(1 AS decimal(5,2));
SELECT B'1' = CAST(1 AS double);
SELECT B'1' = CAST(1 AS serial);

varbit更类似mysql bit类型，但比较操作符转换还是需要开发；


bit类型调研：
mysql：

bit操作符：
https://dev.mysql.com/doc/refman/5.7/en/bit-value-literals.html

调研内容：
首先介绍bit类型
1、bit类型存储方式
2、使用方法

不同点：
mysql可以插入整数（有符号），uxdb只能插入01字串
insert into t1 values(-5);
当bit位数不一致时，uxdb会进行强转，对右边进行截断、或加0；

还需调研内容：
pg的类型bit与varbit区别；


bit类型等于一个值的时候，不加引号，好改吗 。
create  table t1(id  bit);
select * from  t1  where id =1; 

bit类型：

mysql中bit类型一般都是使用整数类型表示，所以支持的bit位数最大只能是64位。而在pg中有专门的bit类型bit(范围1～83886080)，以及可变长度的bit类型varbit。
 
区别一：
插入值， mysql可以获取到， uxdb不能；

相关问题单：180580、180502

字节定义：
8个二进制位为一个字节，1024字节为1kb

bit与bool操作符添加

-- -- support 'bit > bool' or 'bool > bit'
-- CREATE OR REPLACE FUNCTION UX_CATALOG.gtbitbool(BIT, BOOLEAN)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1::INTEGER > $2;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OR REPLACE FUNCTION UX_CATALOG.gtbitbool(BOOLEAN, BIT)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1 > $2::INTEGER;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OPERATOR UX_CATALOG.> (PROCEDURE = gtbitbool, LEFTARG = BIT, RIGHTARG = BOOLEAN, COMMUTATOR = <, NEGATOR = <=);
-- CREATE OPERATOR UX_CATALOG.> (PROCEDURE = gtbitbool, LEFTARG = BOOLEAN, RIGHTARG = BIT, COMMUTATOR = <, NEGATOR = <=);

-- -- support 'bit >= bool' or 'bool >= bit'
-- CREATE OR REPLACE FUNCTION UX_CATALOG.gtebitbool(BIT, BOOLEAN)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1::INTEGER >= $2;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OR REPLACE FUNCTION UX_CATALOG.gtebitbool(BOOLEAN, BIT)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1 >= $2::INTEGER;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OPERATOR UX_CATALOG.>= (PROCEDURE = gtebitbool, LEFTARG = BIT, RIGHTARG = BOOLEAN, COMMUTATOR = <=, NEGATOR = <);
-- CREATE OPERATOR UX_CATALOG.>= (PROCEDURE = gtebitbool, LEFTARG = BOOLEAN, RIGHTARG = BIT, COMMUTATOR = <=, NEGATOR = <);

-- -- support 'bit < bool' or 'bool < bit'
-- CREATE OR REPLACE FUNCTION UX_CATALOG.ltbitbool(BIT, BOOLEAN)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1::INTEGER < $2;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OR REPLACE FUNCTION UX_CATALOG.ltbitbool(BOOLEAN, BIT)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1 < $2::INTEGER;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OPERATOR UX_CATALOG.< (PROCEDURE = ltbitbool, LEFTARG = BIT, RIGHTARG = BOOLEAN, COMMUTATOR = >, NEGATOR = >=);
-- CREATE OPERATOR UX_CATALOG.< (PROCEDURE = ltbitbool, LEFTARG = BOOLEAN, RIGHTARG = BIT, COMMUTATOR = >, NEGATOR = >=);

-- -- support 'bit <= bool' or 'bool <= bit'
-- CREATE OR REPLACE FUNCTION UX_CATALOG.ltebitbool(BIT, BOOLEAN)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1::INTEGER <= $2;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OR REPLACE FUNCTION UX_CATALOG.ltebitbool(BOOLEAN, BIT)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1 <= $2::INTEGER;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OPERATOR UX_CATALOG.<= (PROCEDURE = ltebitbool, LEFTARG = BIT, RIGHTARG = BOOLEAN, COMMUTATOR = >=, NEGATOR = >);
-- CREATE OPERATOR UX_CATALOG.<= (PROCEDURE = ltebitbool, LEFTARG = BOOLEAN, RIGHTARG = BIT, COMMUTATOR = >=, NEGATOR = >);

-- -- support 'bit = bool' or 'bool = bit'
-- CREATE OR REPLACE FUNCTION UX_CATALOG.eqbitbool(BIT, BOOLEAN)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1::INTEGER = $2;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OR REPLACE FUNCTION UX_CATALOG.eqbitbool(BOOLEAN, BIT)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1 = $2::INTEGER;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OPERATOR UX_CATALOG.= (PROCEDURE = eqbitbool, LEFTARG = BIT, RIGHTARG = BOOLEAN, COMMUTATOR = =, NEGATOR = <>, HASHES, MERGES);
-- CREATE OPERATOR UX_CATALOG.= (PROCEDURE = eqbitbool, LEFTARG = BOOLEAN, RIGHTARG = BIT, COMMUTATOR = =, NEGATOR = <>, HASHES, MERGES);

-- -- support 'bit != bool' or 'bool != bit'
-- CREATE OR REPLACE FUNCTION UX_CATALOG.neqbitbool(BIT, BOOLEAN)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1::INTEGER != $2;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OR REPLACE FUNCTION UX_CATALOG.neqbitbool(BOOLEAN, BIT)
-- RETURNS BOOLEAN AS 
-- $$
-- 	SELECT $1 != $2::INTEGER;
-- $$LANGUAGE SQL PARALLEL SAFE STRICT STABLE;

-- CREATE OPERATOR UX_CATALOG.<> (PROCEDURE = neqbitbool, LEFTARG = BIT, RIGHTARG = BOOLEAN, COMMUTATOR = <>, NEGATOR = =);
-- CREATE OPERATOR UX_CATALOG.<> (PROCEDURE = neqbitbool, LEFTARG = BOOLEAN, RIGHTARG = BIT, COMMUTATOR = <>, NEGATOR = =);


2023-05-05
Enable/Disable/Validate/Novalidate:
http://t.csdn.cn/l9ndZ
Enable/Disable:对未来插入数据进行校验；
Validate/Novalidate：对已有数据进行校验；


create table t3 (like tu INCLUDING INDEXES);
create table t2 (like t INCLUDING all);
create table tc4 (like tc2 INCLUDING CONSTRAINTS);

create table tb(id int unique);
ALTER TABLE tb disABLE validate CONSTRAINT TB_ID_KEY;
create table tt(like tb including all);

1、系统表相关
ux_constraint 表的CONINDID（conindid）字段对应ux_index的INDEXRELID(indexrelid)字段值
if ((parent_con->conindid == idxRel->rd_index->indexrelid)

判断是否唯一字段，
通过ux_index的 indisunique 字段判断；


create table tb(id int unique, name text);
create index index_id on tb(id);
create index index_1 on tb(name);

源码：
DefineRelation

like including语法调用栈：
transformIndexConstraints



发现问题：
1、alter disable未实现tab功能；
2、create table ..(like .. including ..); 		//同一个字段只能创建一个索引，且存在优先级；


2023-05-11
问题单：
176708

报错文件：
compatible_testcase/results/window.out

报错sql：
SELECT i,COUNT(*) OVER (ORDER BY i ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING)
   FROM (VALUES(1,1),(2,2),(3,NULL),(4,NULL)) t(i,v);



+{ aggfnoid => 'count(any)', aggtransfn => 'numeric_inc_any',
+  aggcombinefn => 'numeric_add', aggmtransfn => 'numeric_inc_any',
+  aggminvtransfn => 'numeric_dec_any', aggtranstype => 'numeric',
+  aggmtranstype => 'numeric', agginitval => '0', aggminitval => '0' },
+{ aggfnoid => 'count()', aggtransfn => 'numeric_inc', aggcombinefn => 'numeric_add',
+  aggmtransfn => 'numeric_inc', aggminvtransfn => 'numeric_dec', aggtranstype => 'numeric',
+  aggmtranstype => 'numeric', agginitval => '0', aggminitval => '0' },


2023-05-16
设置number类型显示宽度：
set numwidth 15;

number类型数据字段插入double类型数据
CREATE TABLE my_table (
  numeric_column NUMBER primary key
);
insert INTO my_table values(CAST(6.000000000263789E15 as BINARY_DOUBLE));

2023-05-17

pg15升级：
代码分支：
feature/V2.1.1.5D/#176814



2023-05-18

问题单：#185134

增加审计日志外发接口

DM审计外部接口：
支持接口采用标准外发日志，达梦是使用windows nc -lvp 端口号 命令 可以接收到审计内容 

dm机器：
ssh 192.71.0.186

获取dm数据库信息linux命令：
ps -ef | grep dmserver			//查看dm数据库配置文件路径

dm命令：
select * from v$version;		//查看dm数据库版本信息
SELECT CURRENT_USER;			//显示当前用户
SELECT * FROM V$DM_INI WHERE PARA_NAME='ENABLE_AUDIT';		//查询ENABLE_AUDIT 的当前值（或者select * from V$PARAMETER where NAME='ENABLE_AUDIT';）
select sf_get_para_value(1,'ENABLE_AUDIT');					//查看ENABLE_AUDIT的值，审计开关通过参数ENABLE_AUDIT控制




nc使用：
服务端：
nc64.exe -l -p 1234			//-l 打开监听，-p指定本地与远端通讯端口

客户端（发送端）：
nc -nv 192.71.0.181 1234	//nc -nv +ip + 服务端端口，-v相信信息



SELECT * FROM ux_get_replication_slots();			//获取复制槽信息
SELECT * FROM ux_drop_replication_slot('mu_slot1');	//删除复制槽
SELECT * FROM ux_create_logical_replication_slot('my_subscription', 'uxoutput');		//创建复制槽
select * from ux_copy_logical_replication_slot('my_subscription','my_slot');			//复制复制槽




create user u1 password '1';
create schema u1;
grant USAGE on SCHEMA u1 to u1;
grant ALL ON SCHEMA u1 TO u1;

\c uxdb u1 ;
CREATE TABLE u1.sensitive_data (
  id SERIAL PRIMARY KEY,
  username TEXT,
  password TEXT
);

\c - uxdb ;
create extension cve_2020_14350 schema u1;



2023-05-23

CVE-2022-2625:
扩展脚本替换不属于扩展的对象
某些扩展使用 或命令。有些不遵守记录的规则，仅针对已知已是扩展成员的对象。攻击需要具有在至少一个架构中创建非临时对象的权限，能够引诱或等待管理员在该架构中创建或更新受影响的扩展，以及能够引诱或等待受害者使用 或 中的目标对象。给定所有三个先决条件，攻击者可以作为受害者角色（可能是超级用户）运行任意代码。已知受影响的扩展包括 PostgreSQL 捆绑扩展和非捆绑扩展。PostgreSQL在核心服务器中阻止了这种攻击，因此无需修改单个扩展。CREATE OR REPLACE CREATE IF NOT EXISTS 

 修复CREATE OR REPLACE & CREATE IF NOT EXISTS时，存在一个不属于该扩展的现有对象，覆盖该对象并将其纳入该扩展

排序、外部表、物化视图、模式、序列、服务、表

2023-05-26

ENABLE VALIDATE				//约束生效
ENABLE NOT VALIDATE			//不验证已经存储的数据（check有效），主键与唯一索引等效于ENABLE VALIDATE
DISABLE VALIDATE			//禁止修改数据
DISABLE NOT VALIDATE		//约束禁用



2023-05-29


kylin v10+loongarch

2023-05-30

CopyFrom
	NextCopyFrom
		NextCopyFromRawFields
			CopyReadLine
				CopyReadLineText
					CopyLoadRawBuf
						CopyGetData

dpkg编译安装：
https://blog.csdn.net/abcdu1/article/details/121105870

2023-06-02

需求：可以针对同一个对象创建多个同义词

用户		表		同义词
UserA
SCOTT 		TAB 

在 UserA 用户下，为 SCOTT.TAB 创建私有同义词 MyTab




RemoveSynonymById			//删除ux_synonym系统表数据
SynonymDrop					//删除同义词依赖表关系



GetNewRelFileNode			//ux_class生成relfilenode

2023-06-06


dbms_application_info、dbms_crypto、dbms_obfuscation_toolkit、dbms_profiler、dbms_pipe、dbms_alert、dbms_debug、utl_smtp、utl_http、utl_url、dbms_xmldom、dbms_xmlparser


已经调研的包：
dbms_alert				//已实现
dbms_pipe				//116830、94802 已实现函数（create_pipe、pack_message、send_message、db_pipes、receive_message、next_item_type、unpack_message_text、next_item_type）

dbms_xmlparser			//pg内部有部分函数支持，可能语法和行为与Oracle的DBMS_XMLPARSER包有所不同，需要调整代码和查询；预估1人/天
dbms_application_info	// SET_MODULE有实现，见问题单151650、136373
dbms_crypto				//180682 		ORACLE12C文档中，DBMS_OBFUSCATION_TOOLKIT已经被DBMS_CRYPTO代替，uxcrypto插件部分有实现
dbms_obfuscation_toolkit	//180682

dbms_debug				//180682 有调研未实现,Oracle 数据库 19c开始，DBMS_DEBUG 
包已被弃用，被替换为DBMS_DEBUG_JDWP，pg中通过pldebugger插件可以调试PL/SQL，可通过包装pldebugger插件进行兼容；



未调研的包：
dbms_profiler			//该软件包提供了一个接口来分析现有的PL/SQL应用程序并识别性能瓶颈。然后，您可以收集并持久存储 PL/SQL 探查器数据，
需实现3个表PLSQL_PROFILER_RUNS、PLSQL_PROFILER_UNITS、PLSQL_PROFILER_DATA；常用函数START_PROFILER、STOP_PROFILER（启动停止会话数据收集），可参考扩展pg_stat_statements，但pg插件pg_stat_statements与PLSQL_PROFILER_DATA表字段对应较多，其他两个表得调研分析，START_PROFILER、STOP_PROFILER函数需要调研分析；预估 2-3人/天



utl_smtp				//可以尝试使用 plpythonu 插件调用 Python 的 smtplib 发送电子邮件	预估 2天

utl_http				//可以尝试使用 PL/Python 中的 http.client 模块发送 HTTP 请求		预估 2天
utl_url					//可以使用pgcrypto扩展实现url编码解码功能							预估 2天
dbms_xmldom				//子函数较多，部分实现即可，可以尝试使用plpython3u插件进行适配		预估 2天


dbms_xmlparser：

NEWPARSER


186397:二十八所core问题：

复现语句：
【前置条件】清空环境:
create extension if not exists plsql ;
set default_pl_language =plsql;
drop schema if exists DBSJGX_BJXF cascade;
drop package if exists "ZZBZ_ZBZJXN_LD$RP" cascade;
-【步骤1】创建包及包体:
create schema DBSJGX_BJXF;
--specialsql
CREATE OR REPLACE PACKAGE DBSJGX_BJXF."ZZBZ_ZBZJXN_LD$RP" as
column_changed$$ RAW(1000);
procedure rep_delete(
"BZL_O" IN VARCHAR2,
"DHZDZYJL2_o" IN NUMBER,
"DHZXZYJL3_o" IN NUMBER,
"DHZYZDYJ4_o" IN NUMBER,
"DKZDZYJL5_o" IN NUMBER,
"DKZXZYJL6_o" IN NUMBER,
"DMBGJS7_o" IN NUMBER,
"DMBGZS8_o" IN NUMBER,
"DW9_o" IN VARCHAR2,
"EQMGTCJL10_O" IN NUMBER,
"FWFBL11_O" IN NUMBER,
"FXMBGL12_O" IN NUMBER,
"FZGL13_O" IN NUMBER,
"GZFS14_O" IN VARCHAR2,
"JLFBL15_O" IN NUMBER,
"JLTCJD16_O" IN NUMBER,
"LDPTLX17_O" IN NUMBER,
"LQFS18_O" IN VARCHAR2,
"MBRL19_O" IN NUMBER,
"MQBJ20_O" IN NUMBER,
"SJDHZDZYJL21_O" IN NUMBER,
"SJDHZDZYJL22_O" IN NUMBER,
"SJDHZYZDYJ23_O" IN NUMBER,
"SJDKZDZYJL24_O" IN NUMBER,
"SJDKZXZYJL25_O" IN NUMBER,
"SJDMBGJS26_O" IN NUMBER,
"SJDMBGZS27_O" IN NUMBER,
"SJEQMGTCJL28_O" IN NUMBER,
"SJFWFBL29_O" IN NUMBER,
"SJFXMBGL30_O" IN NUMBER,
"SJFZGL31_O" IN NUMBER,
"SJGZFS32_O" IN VARCHAR2,
"SJJLFBL33_O" IN NUMBER,
"SJJLTCJD34_O" IN NUMBER,
"SJLDPTLX35_O" IN VARCHAR2,
"SJLQFS36_O" IN VARCHAR2,
"SJMBRL37_O" IN NUMBER,
"SJMQBJ38_O" IN NUMBER,
"SJSJ39_O" IN NUMBER,
"SJSJSJ40_O" IN NUMBER,
"SJSS41_O" IN NUMBER,
"SJWQMGTCJL42_O" IN NUMBER,
"SJWYWMGTCJL43_O" IN NUMBER,
"SJX44_O" IN NUMBER,
"SJYFWJ45_O" IN NUMBER,
"SJYWMGTCJL46_O" IN NUMBER,
"SJZFWJ47_O" IN NUMBER,
"DKZXZYJL101" IN NUMBER,
"DKZXZYJL111" IN NUMBER,
"DKZXZYJL121" IN NUMBER,
"DKZXZYJL131" IN NUMBER,
"DKZXZYJL141" IN NUMBER,
"DKZXZYJL151" IN NUMBER,
"DKZXZYJL161" IN NUMBER,
"DKZXZYJL171" IN NUMBER,
"DKZXZYJL181" IN NUMBER,
"DKZXZYJL191" IN NUMBER,
"DKZXZYJL201" IN NUMBER,
"DKZXZYJL211" IN NUMBER,
"DKZXZYJL221" IN NUMBER,
"DKZXZYJL231" IN NUMBER,
"DKZXZYJL241" IN NUMBER,
"DKZXZYJL251" IN NUMBER,
"DKZXZYJL261" IN NUMBER,
"DKZXZYJL271" IN NUMBER,
"DKZXZYJL281" IN NUMBER,
"DKZXZYJL291" IN NUMBER,
"DKZXZYJL301" IN NUMBER,
"DKZXZYJL311" IN NUMBER,
"DKZXZYJL321" IN NUMBER,
"DKZXZYJL331" IN NUMBER,
"DKZXZYJL341" IN NUMBER,
"DKZXZYJL351" IN NUMBER,
"DKZXZYJL361" IN NUMBER,
"DKZXZYJL371" IN NUMBER,
"DKZXZYJL381" IN NUMBER,
"DKZXZYJL391" IN NUMBER,
"DKZXZYJL401" IN NUMBER,
"DKZXZYJL411" IN NUMBER,
"DKZXZYJL421" IN NUMBER,
"DKZXZYJL431" IN NUMBER,
"DKZXZYJL441" IN NUMBER,
"DKZXZYJL451" IN NUMBER,
"DKZXZYJL461" IN NUMBER,
"DKZXZYJL471" IN NUMBER,
"DKZXZYJL481" IN NUMBER,
"DKZXZYJL491" IN NUMBER,
"DKZXZYJL501" IN NUMBER,
"DKZXZYJL511" IN NUMBER,
"DKZXZYJL521" IN NUMBER,
"DKZXZYJL531" IN NUMBER,
"DKZXZYJL541" IN NUMBER,
"DKZXZYJL551" IN NUMBER,
"DKZXZYJL561" IN NUMBER,
"DKZXZYJL591" IN NUMBER,
"DKZXZYJL571" IN NUMBER,
"DKZXZYJL601" IN NUMBER,
"DKZXZYJL611" IN NUMBER,
"DKZXZYJL1481" IN NUMBER,
"DKZXZYJL1491" IN NUMBER,
"DKZXZYJL1501" IN NUMBER,
"DKZXZYJL1511" IN NUMBER,
"DKZXZYJL1521" IN NUMBER,
"DKZXZYJL1531" IN NUMBER,
"DKZXZYJL1541" IN NUMBER,
"DKZXZYJL1551" IN NUMBER,
"DKZXZYJL1561" IN NUMBER,
"DKZXZYJL1591" IN NUMBER,
"DKZXZYJL1571" IN NUMBER,
"DKZXZYJL1601" IN NUMBER,
"DKZXZYJL1611" IN NUMBER,
"DKZXZYaaaJL611" IN NUMBER,
"DKZXZYaaaJLm611" IN NUMBER,
"DKZXZYaaahhJLm611" IN NUMBER,
"DKZXZYaaahhJdLm6111" IN NUMBER,
"DKZzXfZYaaahhJdLmd611" IN NUMBER,
"DKZzXfZYkmd611" IN NUMBER,
propagation_flag IN CHAR);

procedure rep_insert(
"BZL_n" IN VARCHAR2,
"DHZDZYJL2_o" IN NUMBER,
propagation_flag IN CHAR);
END "ZZBZ_ZBZJXN_LD$RP";
/
--specialsql

2023-06-08

utl_smtp包实现：

使用 PL/Python 和 smtplib 库来实现类似功能的示例代码:

CREATE OR REPLACE FUNCTION UTL_SMTP.OPEN_CONNECTION(
  host text,
  port integer
) RETURNS integer AS $$
import smtplib

def utl_smtp_open_connection(host, port):
    smtp = smtplib.SMTP(host, port)
    return id(smtp)

return utl_smtp_open_connection(host, port)
$$ LANGUAGE plpython3u;

CREATE OR REPLACE FUNCTION UTL_SMTP.CLOSE_CONNECTION(
  c integer
) RETURNS void AS $$
BEGIN
  PERFORM ux_terminate_backend(c);
END;
$$ LANGUAGE pluxsql;


-- newParser需要实现无参数语法，uxdb需要修改语法实现
CREATE SCHEMA DBMS_XMLPARSER;
CREATE OR REPLACE FUNCTION DBMS_XMLPARSER.newParser() RETURNS TEXT AS $$
DECLARE
  parser TEXT;
BEGIN
  -- 初始化一个XML解析器对象
--   parser := XMLPARSE(DOCUMENT '<?xml version="1.0" encoding="UTF-8"?><root><element>Value</element></root>');

--   -- 返回解析器对象
     RETURN parser;
END;
$$ LANGUAGE pluxsql;

CREATE OR REPLACE FUNCTION DBMS_XMLPARSER.freeParser(parser TEXT) RETURNS VOID AS $$
BEGIN
  -- 释放解析器对象
  -- 在PL/uxSQL中，由于垃圾回收的存在，您不需要显式释放解析器对象，它将在函数结束时自动释放。
  -- 因此，这个函数实际上是一个空函数，只是为了与Oracle的DBMS_XMLPARSER.freeParser函数保持一致性。
  -- 如果您需要手动释放资源，请根据您的具体需求执行其他操作。
  RETURN;
END;
$$ LANGUAGE pluxsql;

2023-06-09

uuid与guid区别：


UUID（通用唯一标识符）和 GUID（全局唯一标识符）是用于唯一标识对象的标准化格式。它们在概念上非常相似，但在实际实现上可能存在一些细微差异。

格式：
UUID：UUID 是基于标准化格式的字符串，通常由 32 个十六进制数字组成，以连字符分隔为五个部分。例如，123e4567-e89b-12d3-a456-426655440000。
GUID：GUID 也是一个唯一标识符，但它通常以原始二进制格式表示，通常为 128 位（16 字节）。在特定的上下文中，可以将 GUID 转换为字符串表示。

生成方法：
UUID：UUID 是根据标准定义的算法生成的。其中最常见的是版本 4（基于随机数生成）和版本 5（基于命名空间和名称生成）。
GUID：GUID 的生成方法依赖于具体的实现和平台。在大多数情况下，GUID 使用 MAC 地址、时间戳和随机数等组合生成。

全局唯一性：
UUID：UUID 的目标是在全球范围内保持唯一性。虽然不是绝对保证，但由于算法的随机性和复杂性，生成重复的可能性极低。
GUID：GUID 的目标也是在全球范围内保持唯一性。实际上，GUID 的唯一性由于其生成方法和实现可能存在差异，有时可能会受到一些限制。
总之，UUID 是一种标准化的格式，通常以字符串形式表示，而 GUID 是唯一标识符的概念，可以具有不同的实现方式，包括原始二进制和字符串表示。在实际使用中，根据具体的应用需求和平台支持，可以选择使用 UUID 或 GUID。



/* BEGIN:Added by qiwang for #184669, 2023/6/9 */
CREATE OR REPLACE FUNCTION UX_CATALOG.sys_guid() RETURNS text AS $$
DECLARE
  guid text;
BEGIN
  SELECT translate(mysql_uuid()::text, '-', '') INTO guid;
  RETURN guid;
END;
$$ LANGUAGE PLUXSQL PARALLEL SAFE;
/* END:Added by qiwang for #184669, 2023/6/9 */


CREATE OR REPLACE FUNCTION sys_guid() RETURNS text AS $$
DECLARE
  guid text;
BEGIN
  SELECT regexp_replace(mysql_uuid()::text, '-', '', 'g') INTO guid;
  RETURN guid;
END;
$$ LANGUAGE PLUXSQL;

CREATE OR REPLACE FUNCTION UX_CATALOG.sys_guid() RETURNS text AS $$
DECLARE
  guid text;
BEGIN
  SELECT REPLACE(mysql_uuid()::text, '-', '') INTO guid;
  RETURN guid;
END;
$$ LANGUAGE PLUXSQL PARALLEL SAFE;


2023-06-13

打包脚本
su - uxdb -c "/opt/uxsinodb-2.1/dbsql/bin/ux_ctl -D /opt/uxsinodb-2.1/simo_dev stop"

重载service服务：
sudo systemctl daemon-reload

指定用户执行脚本
sudo -u uxdb sh /opt/uxsinodb-2.1/bin/configure.sh start

init.d启用禁用服务：
sudo update-rc.d uxinodb defaults
sudo update-rc.d uxinodb remove
控制服务的启动、停止和重启：
sudo service uxinodb start
sudo service uxinodb stop
sudo service uxinodb restart

1、修改Systemd服务管理器路径
/lib/systemd/system为链接目录，真实路径为/usr/lib/systemd/system
2、rpm、deb自启动脚本configure.sh修改
增加指定用户名启动数据库（通过UXUSER设置）、增加restart、reload功能、增加文件/opt/uxsinodb-2.1/autoloadconfig
可设置集簇路径等参数
3、deb包数据库安装路径修改dbsql
4、rpm打包与编译脚本build.sh参数保持一致

ip：
192.71.1.10-192.71.1.14

铁塔POC包支持问题单：186842 


repmgr:

repmgr问题：
主机：13机器
备机：14机器
主机13机器stop后，备机14机器未升主成功（此现象必现）；

调查过程：
1、查看备机14机器日志，通过查看代码初步分析是系统函数system返回值问题，后恢复主备环境，此时13机器为备机，14机器为主机，将14机器stop后，13机器可以升主成功，但14机器未启动成功，且日志报错也是system报错，故推测只有14机器执行system函数时返回值有问题，故调查从14机器system返回值问题切入
2、在14机器本地构造测试代码，system执行系统命令返回正常，然后测试主备切换命令，由于切换命令返回状态与当时数据库状态有关，故需改repmgrd守护进程代码，添加system返回值日志，将修改后的守护进程repmgrd替换到14机器，并还原出错前主备状态（13主、14备），由于替换了14机器守护进程，故需要重启14机器守护进程，查看状态正常后（13主、14备），stop 13机器后，查看添加日志，发现system返回值正常，此时查看主备环境切换正常，之后重复执行6次，主备切换正常

3、回想之前操作步骤只进行了2步（1、替换repmgrd 2、重启守护进程）
repmgrd代码改动只加了日志，其他未作修改，故推测可能是守护进程重启后导致主备切换正常，将替换前的repmgrd还原，之后重复主备切换6次，发现主备切换正常；
4、
查看客户机器守护进程是23年4月份启动，后面可能有做操作，14机器/tmp/repmgrd.pid找不到，然后重启后正常，13机器有同样问题存在；

调查结果：
通过以上分析，可知主备未切换成功原因：守护进程未正常启动导致system系统函数返回值异常



而且备机system其他命令也有问题

2023-06-26
问题单：186970
优化自启动脚本：

2023-06-27

youxian写操作：

方案设计
1、非优先写未完成，当写写冲突时，rollback非优先写操作，然后执行youxian写操作，完成后再重新执行非优先写；
2、如果同时带优先写，保持原逻辑不变


2023-06-29

研发需求：
针对 ver2.1.0.4.10 + uxmpp 8.2.1的环境，使用ver2.1.0.3 版本配套的 uxmpp_utility 进行扩缩容测试。
如果无法正常加载，那么基于对应环境，用ver2.1.0.3 中的 uxmpp_utility 代码适配编译一个 对应的包。

ver2.0.4.10 的包 和 uxmpp 8.2.1的包获取路径：
http://cd.uxsino.com:24080/index.php/f/3801484
http://cd.uxsino.com:24080/index.php/f/3801472

ver2.1.0.3对应的现有的  uxmpp_utility 包。
http://cd.uxsino.com:24080/index.php/f/3808453

ver2.1.0.3 代码分支 ：hotfix/ver2.1.0.3p文江



查询正常sql：
def query_user():
    session = DBSession()
    request_args = {"name":"2023","age":"12"}
    q_user = session.query(User).filter_by(**request_args)  # one表示结果有且仅有一个
    print("##############################this is q_user")
    print(q_user)  # 输出查询语句
    print("##############################this is q_user end!!!")
    query = q_user.first()


def query_user():
    session = Session(engine)
    request_args = dict(name='2023', age=30)
    results1 = session.query(User).filter_by(**request_args)
	data1 = [dict(zip(result.keys(), result)) for result in results1]
	data = [{**d1} for d1 in zip(data1)]


python报错：
"Could not determine version from string '%s'" % v
AssertionError: Could not determine version from string 'UXsinoDB 2.1.1.5D on x86_64-pc-linux-gnu

解决方法：
CREATE OR REPLACE FUNCTION ux_catalog.version()
RETURNS text AS $$
	SELECT 'PostgreSQL 12.3 on x86_64-pc-linux-gnu, compiled by gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-16), 64-bit';
$$ LANGUAGE SQL;

该报错提示指出操作符不存在，因为传递的参数类型不匹配。根据报错信息，year的值被解释为数组类型（text[]），而数据库中的列year的类型是bigint类型。
通过查看python脚本，python解析curl的字串后，获取的键值对request_args如下：{'year': ['2023']}；

解决这个问题的一种方法是将 request_args 中的值从数组类型转换为字符串类型。使用列表解析或循环来处理每个键值对，并将值转换为字符串。
代码如下：
# 转换 request_args 中的值为字符串
request_args = {k: v[0] for k, v in request_args.items()}


2023-07-07

EXEC SQL LOB READ :amt FROM :blob AT :offset INTO :buff;
:amt参数指定要读取的数据量，可以是字节数或字符数，取决于LOB对象的类型。
:blob参数指定要读取数据的LOB对象。
:offset参数指定从LOB对象的哪个位置开始读取数据。可以是一个具体的偏移量，表示从LOB对象的特定位置开始读取；也可以是一个变量，动态地指定偏移量。
:buff参数指定一个目标缓冲区，用于存储从LOB对象中读取的数据。

作用：从LOB对象中读取指定数量的数据，然后将其存储到提供的缓冲区中

EXEC SQL LOB WRITE ONE :messlen FROM :buffer INTO :lob;
EXEC SQL LOB WRITE FIRST :amt FROM :buffer INTO :blob AT :offset;
EXEC SQL LOB WRITE NEXT :amt FROM :buffer INTO :blob;
EXEC SQL LOB WRITE LAST :amt FROM :buffer INTO :blob;


//大对象sq1方式插入
exec sql allocate descriptor 'in_lobInsert';
EXEC SOL PREPARE s_lobInsert FROM :m_statement;
EXEC SQL DESCRIBE INPUT s_lobInsert USING DESCRIPTOR 'in_lobInsert';
occurs = 0;
iPos=0;
for (i=0;i<stDbInfo->col_count; i++)
{
	occurs = m_pos[i];
	switch (stDbInfo->m_colType[il)
{
case 3:
	memset(cNumValue,0,100) :
	memcpy(&l,&szCommonValue[iPos],2);
	iPos=iPos+2;
	memcpy(cNumValue,&szCommonValue[iPos],l);
	m_type=stDbInfo->m_colType[i];
	m_length=stDbInfo->m_colLength[i];
	iTemp[i]=atoi(cNumValue);
if(l != 0)
	EXEC SOL SET DESCRIPTOR 'in_lobInsert' VALUE :occurs TYPE=:m_type,LENGTH=:m_length,ref DATA=:&iTemp[i];
else
	EXEC SOL SET DESCRIPTO 'in_loInsert' VALUE :ocurs TYPE=:m_type,LENGTH=:m_length,INDICATOR-:comm_ind,ref DATA=:&iTemp[i];
iPos=iPos+l+1;
simple_counter++;
break;
}
}
exec sql execute s_lobInsert using sql descriptor 'in_lobInsert';

//批量插入
exec sql context use :m_batchcontext;
exec sql for :m_inRows allocate descriptor 'in_insert';
exec sql prepare s_insert from :m_statement;
exec sql describe input s_insert using descriptor 'in_insert';
for (i=0;i<iinput_count;i++)
{
occurs++;
m_intype[i] = m_tableinParam->m_intype[i];
m_inlength[i] = m_tableinParam->m_inlength[i];
m_value[i] = row_value[il;
EXEC SOL FOR :m_inRows SET DESCRITOR 'in_insert' VALUE :occurs TYPE=:m_intype[i],LENGTH=:m_inlength[i],ref DATA=:m_value[i];
}
EXEC SQL FOR :m_inRows EXECUTE s_insert USING SQL DESCRIPTOR 'in_insert';
EXEC SOL WHENEVER SOLERROR CONTINUE;
EXEC SOL DEALLOCATE DESCRIPTOR 'in_insert';



//批量查询
EXEC SQL FOR :iRowsCount ALLOCATE DESCRIPTOR 'BQ_OUT';
EXEC SQL PREPARE bq_sql FROM :szSql;
EXEC SQL DECLARE bq_cur CURSOR FOR bq_sql;
EXECSQL DESCRIBE OUTPUT bq_sql USING DESCRIPTOR 'BQ_OUT';
do
{
	for (int i=0;i<g_stStructInfo.m_vcInfo.size(); i++)
	{
		iOccurs++;
		stColInfo =g_stStructInfo.m vcInfo[i];
		EXEC SQL SET DESCRIPTOR 'BQ_OUT' VALUE :iOccurs TYPE=:stColInfo.m_type, LENGTH=:stColInfo.m_length;
		EXEC SQL FOR :iRowsCount SET DESCRIPTOR 'BQ_OUT' VALUE :iOccurs REF DATA=:pDat, REF INDICATOR=:pInd;
	}
	for (;;)
	{
		iCurnt = sqlca.sqlerrd[2];
		iRem = stQDInfo->m_rowsCount - iTotal;
		if (iRem == 0) break;
		iRowsCount=(iRem > PAGE_COUNT) ? PAGE_COUNT:iRem;
		EXEC SQL FOR :iRowsCount FETCH bq_cur INTO DESCRIPTOR 'BQ_OUT';
		iCurnt = sqlca.sqlerrd[2] - iCurnt;
		CopyToDst(g_stStructInfo,iTotal, iCurnt， szRecBuf);
		iTotal += iCurnt;
		if(sqlca.sqlcode == 1403)
			break;// 取出所有数据 跳出循环
	}
	while(0);
}

//bind 金仓测试出问题的语句
EXEC SOL CONTEXT USE :ctx;
exec sql whenever sqlerror goto get_info_error;
EXEC SOL WHENEVER NOT FOUND CONTINUE:
EXEC SQL ALLOCATE DESCRIPTOR 'out_dml';
EXEC SQL PREPARE s_dml FROM :m_statement;
EXEC SOL DESCRIBE OUTPUT s_dml USING DESCRIPTOR 'out_dml';
EXEC SQL GET DESCRIPTOR 'out_dml' :m_count=COUNT;
m_recInfo->col_count=m_count;
occurs=0;
/*初始化大字段列表为空 ZXQ */
memset(m_recInfo->m_lobColsName,0,MAXSTATEMENTLEN/5);
for (i=0;i<m_recInfo->col_count;i++)
{
	occurs++;
	EXEC SQL GET DESCRIPTOR 'out_dml' VALUE :occurs :m_type=TYPE,:m_lenght=LENGTH,:m_prec=PRECISION,:m_scale=SCALE,:m_colName
	m_recInfo->m_colType[i]=m_type;
	m_recInfo->m_colLength[i]=m_lenght;
	ret=Datatype_Classify(&(m_recInfo->m_colType[i]),&(m_recInfo->m_collength[i]),m_prec,m_scale,&(m_recInfo->lob_in));
	switch (ret)
	{
		case 1:
			break;
		case 2:
			l=strlen(m_recInfo->m_lobColsName);
			break;
		default:
			m_errNO = -80042;
			goto get_info_error;
	}
}
exec sql deallocate descriptor 'out_dml';
return 1;

/*第五部分*/
EXEC SQL FOR :iRowsCount ALLOCATE DESCRIPTOR 'BQ_OUT';
EXEC SQL PREPARE bq_sql FROM :szSql;
EXEC SQL DECLARE bq_cur CURSOR FOR bq_sql;
EXEC SQL DESCRIBE OUTPUT bq_sql USING DESCRIPTOR 'BQ_OUT';
do
{
	for (int i=0;i<g_stStructInfo.m vcInfo.size();i++)
	{
		iOccurs++;
		stColInfo =g_stStructInfo.m_vcInfo[i];
		EXEC SQL SET DESCRIPTOR 'BQ_OUT' VALUE :iOccurs TYPE=:stColInfo.m_type, LENGTH=:stColInfo.m_length;
		EXEC SQL FOR :iRowsCount SET DESCRIPTOR 'BQ_OUT' VALUE :iOccurs REF DATA=:pDat, REF INDICATOR=:pInd;
	}
	for (;;)
	{
		iCurnt = sqlca.sqlerrd[2];
		iRem = stQDInfo->m_rowsCount - iTotal;
		if (iRem = 0) break;
		iRowsCount = (iRem > PAGE_COUNT) ? PAGE_COUNT:iRem;
		EXEC SQL FOR :iRowsCount FETCH bq_cur INTO DESCRIPTOR 'BQ_OUT';
		iCurnt = sqlca.sqlerrd[2] - iCurnt;
		// 拷贝到缓冲区
		CopyToDst(g_stStructInfo,iTotal，iCurnt, szRecBuf);
		iTotal += iCurnt;
		//1403查不到数据或查到的数据少于想要 取出的行数
		if(sqlca.sglcode ==1403)
			break;//取出所有数据 跳出循环
	}
	while(0);
}

proc相关问题单：
186700 

Pro*C介绍：
下面是一些 Pro*C 语法的详细解释：

EXEC SQL：这是 Pro*C 中的一个特殊指令，用于指示接下来的语句是 SQL 或 PL/SQL 语句。

EXEC SQL INCLUDE：这个指令用于包含预定义的 SQLCA 和 ORACA 结构的头文件。SQLCA 是一个结构体，用于获取 SQL 语句的执行结果和错误信息。

EXEC SQL WHENEVER：这个指令用于定义 SQL 执行过程中遇到错误时的处理行为。例如，EXEC SQL WHENEVER SQLERROR 表示如果 SQL 语句执行出错，则执行相应的操作。

EXEC SQL BEGIN DECLARE SECTION 和 EXEC SQL END DECLARE SECTION：这两个指令用于在 C/C++ 代码中声明数据库相关的变量。在 BEGIN DECLARE SECTION 和 END DECLARE SECTION 之间的代码块中，可以声明数据库连接、游标、绑定变量等相关的变量。

EXEC SQL CONNECT：这个指令用于建立与 Oracle 数据库的连接。

EXEC SQL PREPARE 和 EXEC SQL EXECUTE：PREPARE 用于准备一个 SQL 语句以供执行，而 EXECUTE 用于执行预先准备好的 SQL 语句。

EXEC SQL SELECT：这个指令用于执行 SELECT 查询语句，并将结果存储在 C/C++ 变量中。

EXEC SQL FETCH：这个指令用于从游标中提取下一行结果，并将结果存储在 C/C++ 变量中。

EXEC SQL CLOSE：这个指令用于关闭游标。

EXEC SQL COMMIT 和 EXEC SQL ROLLBACK：这两个指令用于提交或回滚事务。



proc编译报错：
根据报错信息，提示说这些用法仅在指定 DYNAMIC=ANSI 时才有效。因此，你需要在编译时指定 DYNAMIC=ANSI。
请修改编译命令，添加 DYNAMIC=ANSI 选项，例如：

proc iname=testwq.pc sqlcheck=full DYNAMIC=ANSI

proc语法：
1、EXEC SQL INCLUDE <header_file>;：该语句用于引入特定的 ProC 头文件
2、EXEC SQL PREPARE 语句是 Pro*C/C++ 中的一个关键语句，用于预编译 SQL 查询语句或 PL/SQL 块。

3、BEGIN DECLARE SECTION 和 END DECLARE SECTION 之间声明需要在 SQL 语句中使用的 C 变量，用于声明 C 变量和 SQL 声明之间的分隔符；eg：
EXEC SQL BEGIN DECLARE SECTION;
    char query[100] = "SELECT * FROM employees WHERE department_id = :dept_id";
    int department_id = 10;
EXEC SQL END DECLARE SECTION;

EXEC SQL WHENEVER <condition> <action>;：这个语句用于设置错误处理机制。<condition> 可以是 SQLERROR（SQL 错误）或 NOT FOUND（未找到结果）。
<action> 可以是 CONTINUE（继续执行后续语句）或 GOTO <label>（跳转到指定标签处）。通过设置错误处理机制，可以在 SQL 执行过程中检测到错误并采取相应的处理措施。

4、EXEC SQL DECLARE 语句是 Pro*C/C++ 中用于声明和定义游标的语法。
游标是用于在 SQL 查询中遍历结果集的一种机制。下面是 EXEC SQL DECLARE 语句的详解和示例：
语法：EXEC SQL DECLARE cursor_name CURSOR FOR query_statement;
示例：
EXEC SQL BEGIN DECLARE SECTION;
    int department_id = 10;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE emp_cursor CURSOR FOR
    SELECT * FROM employees WHERE department_id = :department_id;

通过声明游标后，可以使用 EXEC SQL OPEN、EXEC SQL FETCH 和 EXEC SQL CLOSE 等语句对游标进行操作，实现对结果集的遍历和数据操作。

EXEC SQL FETCH使用方法：
示例：
EXEC SQL BEGIN DECLARE SECTION;
    int department_id = 10;
    char employee_name[50];
    int employee_salary;
EXEC SQL END DECLARE SECTION;

EXEC SQL DECLARE emp_cursor CURSOR FOR
    SELECT name, salary FROM employees WHERE department_id = :department_id;

EXEC SQL OPEN emp_cursor;

while (1) {
    EXEC SQL FETCH emp_cursor INTO :employee_name, :employee_salary;
    if (SQLCODE != 0) {
        break;  // 无更多数据，退出循环
    }
    // 处理获取的数据
    printf("Name: %s, Salary: %d\n", employee_name, employee_salary);
}

EXEC SQL CLOSE emp_cursor;

5、EXEC SQL ALLOCATE DESCRIPTOR 'out_dml'; 是 Pro*C/C++ 语法，用于分配一个描述符。描述符是一个用于存储关于数据结构和数据类型的信息的对象。
在 Pro*C/C++ 中，描述符通常用于处理动态 SQL 查询的结果集或对大对象（LOB）的操作。
	
EXEC SQL ALLOCATE DESCRIPTOR 'out_dml';
EXEC SQL PREPARE s_dml FROM :m_statement;
EXEC SOL DESCRIBE OUTPUT s_dml USING DESCRIPTOR 'out_dml';
EXEC SQL GET DESCRIPTOR 'out_dml' :m_count=COUNT;			//该语句将从描述符 'out_dml' 中获取 COUNT 值，并将其赋值给变量 value，COUNT 是描述符属性，用于获取结果集的列数。

以上语句将m_statement语句输出的结果集存储到描述符'out_dml'中；

EXEC SQL DESCRIBE描述符与定义游标EXEC SQL DECLARE有什么区别：

EXEC SQL DESCRIBE： 语句用于描述查询结果集的元数据，例如列名、数据类型、长度等。
EXEC SQL DECLARE：用于声明和定义游标，以便在程序中遍历和操作查询结果集

EXEC SQL GET DESCRIPTOR 'out_dml' VALUE :occurs :m_type=TYPE,:m_lenght=LENGTH;		//:occurs 变量的值应该是一个整数，表示要获取的列的索引位置。通常，索引从 1 开始，依次递增。


金仓proc编译方式：
proc iname=testwq.pc sqlcheck=full DYNAMIC=ANSI
gcc -I /home/uxdb/kbproc/include/ -I /home/uxdb/kbproc/include/oci/ -L /home/uxdb/kbproc/lib/ -lclntsh -lsqllib -o testwq testwq.c

oracle编译方式：
proc iname=testwq.pc sqlcheck=full DYNAMIC=ANSI
gcc testwq.c -L$ORACLE_HOME/lib -lclntsh -o testwq

https://blog.csdn.net/sxqinjh/article/details/127388037


修改用户密码：
登录
ALTER USER MDSYS IDENTIFIED BY 123456;

the account is locked：用户被锁定后，解锁命令：
ALTER USER MDSYS ACCOUNT UNLOCK;

proc相关语法设置：

配置链接oracle的proc代码：
相关文件：ora_test.pc
修改点：
1、引用ORACA结构体
EXEC SQL INCLUDE SQLCA; /* 说明一个 SQL 通信区 */
EXEC SQL INCLUDE ORACA; /* 说明一个 SQL 通信区 */

2、添加报错函数，其中通过sqlca.sqlcode、sqlca.sqlerrm.sqlerrmc获取错误码
    void handle_error() {
        printf("SQL error occurred:\n");
        printf("Error code: %d\n", sqlca.sqlcode);
        printf("Error message: %s\n", sqlca.sqlerrm.sqlerrmc);
        exit(1);
    }
3、链接oracle 字串信息：

    char username[30] = "mdsys";
    char password[30] = "123456";
    char connection_string[100] = "192.72.1.76:1521/orcl";			//oracle连接串设置
	/* 连接数据库 */
    EXEC SQL CONNECT :username IDENTIFIED BY :password USING :connection_string;

4、编译proc方式
proc iname=ora_test.pc sqlcheck=full DYNAMIC=ANSI
gcc ora_test.c -L$ORACLE_HOME/lib -lclntsh -o ora_test


oracle问题：
1、插入数据其他客户端查不到

原因：oracle默认未commit，但存在自动commit，隔的时间比较长


2023-07-13

人大金仓官网：
https://www.kingbase.com.cn/tyxsjk/index.htm

金仓安装教程：
https://blog.csdn.net/yang_z_1/article/details/123252832

安装后
/home/uxdb/Kingbase/Server/bin




现场反馈2个需求：
相关问题单：
186397

oracle官方文档：
proc语法相关文档：
Pro*C/C++ Programmer's Guide


1、for 语法
EXEC SQL FOR 语法修改


char d_data1[5][500];
EXEC SQL FETCH 4 FROM mem_c_lobquery INTO SQL DESCRIPTOR mydesc;
/*for(i = 0; i < 5; i++)
{
EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :d_data1 = DATA;
printf("d_data1 = %s\n", d_data1);
}*/

EXEC SQL GET DESCRIPTOR mydesc VALUE 1 :d_data1 = DATA;			//对于多行数据，需要通过数据方式接收数据；
for(i = 0; i < 4; i++)
{
        printf("d_data1 = %s\n", d_data1[i]);
}





2、大对象操作语法
LOB语法有：
EXEC SQL LOB READ :amt FROM :blob AT :offset INTO :buffer;
EXEC SQL LOB WRITE ONE :messlen FROM :buffer INTO :lob;
EXEC SQL LOB WRITE FIRST :amt FROM :buffer INTO :blob AT :offset ;
EXEC SQL LOB WRITE NEXT :amt FROM :buffer INTO :blob ;
EXEC SQL LOB WRITE LAST :amt FROM :buffer INTO :blob ;




EXEC SQL FOR 语法：
Pro*C/C++ Programmer's Guide 第8节
EXEC SQL FOR :limit FETCH emp_cursor INTO DESCRIPTOR 'OUTPUT'


EXEC SQL FOR 子句用来设置由以下任何 SQL 语句处理的数组元素的数量,
DELETE

EXECUTE

FETCH

INSERT

OPEN

UPDATE



ecpg使用方式：

main.cpp
编译方式：
ecux -o dbapi.cpp

proc相关问题单：
186769、

数据库参数修改：
1、log_statement = 'all'			//sql打印获取
2、log_connections = on				//切换sql会话链接验证


1、SDatabaseInfo 结构体中私有、共有链接
2、链接为空问题
3、begin、end问题

2023-08-22

大连银行项目（#191400）

项目名称：大连银行新一代信息化建设项目-大连银行基础软硬件采购项目(一期) -分布式数据库直接立项对应商机
项目编号：A02435246202210963




2023-08-23

调研mysql：
TINYINT与bit类型

BOOL，BOOLEAN是TINYINT(1)的同义词；


CREATE TYPE tinyint AS (value smallint);

CREATE FUNCTION mysql_tinyint_to_ux_tinyint(mysql_value smallint) RETURNS tinyint AS $$
BEGIN
    RETURN ROW(mysql_value)::tinyint;
END;
$$ LANGUAGE pluxsql;

CREATE FUNCTION ux_tinyint_to_mysql_tinyint(ux_value tinyint) RETURNS smallint AS $$
BEGIN
    RETURN ux_value.value;
END;
$$ LANGUAGE pluxsql;

CREATE TABLE test_table (
    id serial PRIMARY KEY,
    flag tinyint DEFAULT ROW(0)::tinyint
);

门户系统数据库适配群（#191051）

#191051:兼容门户系统数据库适配TINYINT类型
开始时间：2023-08-23
结束时间：2023-08-25
描述：调研TINYINT类型，分析实现方案


CREATE DOMAIN tinyint

  AS smallint

  CONSTRAINT tinyint_check CHECK (VALUE >= 0 AND VALUE <= 255);

ALTER DOMAIN tinyint

  OWNER TO uxdb;

COMMENT ON DOMAIN tinyint

  IS 'tinyint type between 0 and 255';


高斯源码下载：
https://gitee.com/opengauss/openGauss-server

pg新添加一个typle类型：

涉及文件：
1:ux_type.data		添加类型
2:ux_proc.data		实现类型函数
3:utils/adt			路径添加ux_proc对应函数实现
4:ux_cast.data		//添加隐式转换

隐士转换：
1、ux_cast.data			//添加隐士转换
2、ux_proc.data			//添加对应转换函数




get_DSN_or_Driver
获取DSN参数值：
getDSNinfo


odbcinst -q -s -n uxdb		//获取DNS对应的参数信息

修改成这种方式：
uxdb@127.0.0.1:5432

uxdb@192.71.1.11:5432




2023-09-08

常见问题总结：

1、c++源码，在linux编译没问题，但在windows编译，提示好多：语法错误，例如：“缺少;、{”引用问题，变量定义问题
解决方法：

存在重复引用问题、同名文件应该添加目录的时候会出问题


咱们本地如何模拟构造windows编译，还需要哪些；


C99编译器支持bool类型，
stdbool.h于C99中引入，C99是Visual C ++ 2013的引入；

#pragma comment(lib,"libecux")			//vs c++引用动态库，在c++源码中添加；


2023-09-19

#189684: 二十八所项目proc*c适配
二十八所适配主要工作内容：
1、协助现场适配RSHANDLE句柄相关proc接口；
2、批量查询代码修改，修改后存在死循环报错（待处理）
3、本地实现链接串通过odbc配置文件DNS服务名获取；
4、解决现场windows编译问题，并实现odbc链接串；
5、dll链接应用程序报错分析；

#191051:兼容门户系统数据库适配TINYINT类型	（完成50%）
#191051：门户系统数据库适配支持
#162840：交通委项目打包支持






52.92 + 81.93 + 84.96 + 46.47 = 266.28


418.71 

327.24 + 81.93 + 84.96



南京二十八：

修改内容记录
1、odbc相关修改
1）
修改文件路径：
unixodbc-2.3.12\include\sqltypes.h
修改内容：
TCHAR修改为UXTCHAR
WCHAR修改为UXWCHAR

2）
unixodbc修改：
a、linux
修改文件路径：
unixodbc-2.3.12\include\odbcinst.h
修改内容：
注释下面代码：
#define  SQLGetPrivateProfileString     SQLGetPrivateProfileStringW

b、windows：
dns获取windows使用接口GetPrivateProfileStringA：文档中有记录：
GetPrivateProfileStringA


2、proc相关问题单：

select to_char(update_time, 'yyyy-mm-dd hh24:mi:ss') from AD_MENU_CONFIG where unit_name = '1';

create table AD_MENU_CONFIG(update_time timestamp, unit_name int);
insert into AD_MENU_CONFIG values('2023-10-1',1);

动态库编译命令
g++ -shared -o libdbapi.so demo_project.cpp

链接动态库命令：
g++ -o demo_dbapi demo_project.cpp -ldbapi -L/home/uxdb/uxdbinstall/dbsql/bin

3、现场应用报错记录

1）语法错误
a、select语句字段存在‘双,’报错: eg：select mbnm,,mbfx from tb;

b、where()报错，eg：select zbnm from tb where();



2）右边不存在报错

游标C1不存在报错：
eg：
declare C1 cursor for select语句;

3) sql编码报错：
修改客户端编码
client_encoding = GBK  


4、ecpg源码问题记录

-DUXDB_ECUX_INTERNAL 用于取消获取sqlca错误码；

错误回调函数，哪个在最后，调用哪个；
例如，下面goto在最后，回调调用goto语句；
EXEC SQL WHENEVER SQLERROR CALL
EXEC SQL WHENEVER SQLERROR GOTO 

5、linux编译odbc步骤如下，windows使用odbc见链接connect路径

odbc:

A、unixodbc不存在
安装
sudo yum install unixODBC-devel.x86_64 -y

B、error: odbc_config not found (required for unixODBC build)
修改--with-unixodbc参数为：
--with-unixodbc=/usr/bin/odbc_config

C、获取不到系统函数
SQLGetPrivateProfileString

-lodbcinst

D、编译odbc测试用例：

g++ main.cpp -lodbc -luxsql -lodbcinst -L /home/uxdb/uxdbinstall/dbsql/lib -o demo_odbc -g

E、odbc配置文件设置：
export ODBCSYSINI=/opt/uxdbinstall/unixODBC/etc
export ODBCINI=/opt/uxdbinstall/unixODBC/etc/odbc.ini

编译的话，需要加-lodbcinst：
g++ main.cpp  -lodbcinst -L /home/uxdb/uxdbinstall/dbsql/lib -o demo_odbc -g

F、
odbc主线配置文件路径：
dbsql/lib/oci/config.ini

6、宏定义UXDB_ECUX_INTERNAL的作用：

咱两现象不一致是-DUXDB_ECUX_INTERNAL这个宏导致的，用你的传参的方式， 获取不到错误信息，
ecpg是通过ECUXget_sqlca函数来申请内存，并与当前线程信息进行关联；ECUXget_sqlca这个函数是通过DUXDB_ECUX_INTERNAL进行控制的，
当添加DUXDB_ECUX_INTERNAL宏后，sqlca就不会调用ECUXget_sqlca函数；修改方法：
1）、 makefile里面应该加了这个-DUXDB_ECUX_INTERNAL宏，所以导致全局变量没生效， 你可以把这个宏去了试下
2）、在proc.pc里面添加宏定义，Makefile中需要添加宏 -DUXDB_ECUX_INTERNAL：#define sqlca (*ECUXget_sqlca())

7、大对象注意问题
大对象测试用例Lob_Insert_Data_Mem，数据需要带双引号，因为代码中存在strlen获取字串长度，所以传参必须为字串;
Lob_Query_Data_Mem, 接收数组按照前面字段顺序；

Lob_Query_Data与Lob_Query_Data_Mem，对于普通字段字符串接收数组，接收数组需要大于实际类型长度，否则windows会报core问题；

8、ecux中 使用语法DESCRIBE INPUT问题：
有问题接口：
Lob_Insert_Data_Proc
Lob_Update_Data_Proc
Lob_Update_Data_Proc_mem
Lob_Insert_Data_Proc_Mem
Batch_Bind_Value_Proc

20231220：
去现场最新修改点：
a、修改大对象描述符语法；
b、修改大对象numeric条件判断，将其修改为与oracle条件一致；
c、查看oracle原始大对象字符串获取类型；


9、现场glibc版本2.23

2023-12-28


现场数据200GB

2023-12-29

最新问题：

本地测试numeric类型不带精度，走的int逻辑，因为precision不等于0，但现场代码numeric应该走double逻辑；

验证numeric类型，分别验证类型：numeric、numeric(38,0),numeric(4,2);
验证float类型：
create table tb(V1 float, v2 float(4),v3 float(8),v4 float(64), V5 float(126));




疑问：

周工，关于应用调试，我们有几个问题麻烦你下，好继续安排我们接下来的任务：
1、启动应用后有几个应用会报错，这些报错解决完之后，是否应用算是调通了，
我看应用界面上还有一些选项按钮，是否我们这边还需要测试这些按钮功能是否正常，
这些都调通才能算我们应用已经调通吗，还是还有其他应用界面需要调试；

2、我们批量查询和批量插入还未开发，对目前阶段的应用调试有什么影响没，
是否有基本的功能也有调用到批量查询、插入功能；



2023-10-11

1、单个应用进程有大量sql，无法进行调试
2、有多个崩溃应用链接


CREATE TABLE zzll_gjgwry_fxy_ydxlqk(
ND CHARACTER VARYING(15) NOT NULL,
YF CHARACTER VARYING(15) NOT NULL,

SFZHM CHARACTER VARYING(20) NOT NULL,
DWDM CHARACTER VARYING(7) NOT NULL,
FXYDH CHARACTER VARYING(4),
BYJHSJ NUMERIC,
BYZSJ NUMERIC,
XFJXBYSJ NUMERIC,
RJSJBY NUMERIC,
BYRJSJ NUMERIC,
BYHSSJ NUMERIC,
BYZJSJ NUMERIC,
BYYJSJ NUMERIC,
BYZSSJ NUMERIC,
BYACSJ NUMERIC,
BYZYSJ NUMERIC,
BYYYSJ NUMERIC,
BYZZHCC NUMERIC,
BYFZHCC NUMERIC,
BYFXZJC NUMERIC,
BYTCSJ NUMERIC,
BYDAIFSJ NUMERIC,
BYDANFSJ NUMERIC,
BYRWSJ NUMERIC,
BYXJKMSJ NUMERIC,
BYZZHCC_ZJ NUMERIC,
BYZZHCC_YJ NUMERIC,
BYZZHCC_KZY NUMERIC,
BYZZHCC_XBY NUMERIC,
BYFZHCC_ZJ NUMERIC,
BYFZHCC_YJ NUMERIC,
BYFZHCC_KZY NUMERIC,
BYFZHCC_XBY NUMERIC,
SYN_NM CHARACTER VARYING(32) NOT NULL DEFAULT MD5(RANDOM() || TO_CHAR(NOW(),'yyy-m-dd hh24:mi:ss:ms:us'::TEXT))::BYTEA,
ZBNM CHARACTER VARYING(24),
BYYZSJ NUMERIC,
BYHSJC NUMERIC,
BYHSZSJ NUMERIC,
BYWCZSJ NUMERIC,
BYWCBFB NUMERIC,
MNQ_FXJC_BY NUMERIC,
MNQ_ZSJ_BY NUMERIC,
MNQ_ZFSJ_BY NUMERIC,
CONSTRAINT UNIQUE_ZZLL_GJGWRY_EXY_YDXLQK_SYS_C00121256 CHECK (YF IS NOT NULL) ENABLE VALIDATE,
CONSTRAINT UNIQUE_ZZLL_GIGWRY_FXY_YDXLQK_SYS_CO0121255 CHECK (ND IS NOT NULL) ENABLE VALIDATE,
CONSTRAINT UNIQUE_ZZLL_GIGWRY_FXY_YDXLQK_SYS_C00121259 CHECK (SYN_NM IS NOT NULL) ENABLE VALIDATE,
CONSTRAINT UNIQUE_ZZLL_GIGWRY_FXY_YDXLQK_SYS_C00121258 CHECK (DWDM IS NOT NULL) ENABIE VALIDATE,
CONSTRAINT UNIQUE_ZZLL_GIGWRY_FXY_YDXLQK_SYS_C00121257 CHECK (SFZHM IS NOT NULL) ENABIE VALIDATE,
CONSTRAINT FXY_YDXLQK_FK_SFZHM FORBIGN KEY (SFZHM) REFERENCES DBSJGX.ZZLL_GJGMRY(SFZHM) ON DBLETE CASCADE,
CONSTRAINT FK_GJGW_EXYYDXL_ZB FOREIGN KEY (ZBNM) REFERENCES DBSJGX.ZZBZ_S_TY_ZB(ZBNM) ON DELETE CASCADE
)
USING HEAP;



CREATE OR REPLACE VIEW VIEW_EXY_YDXLQK ("SFZHM", "DWDM","FXYDH", "ND", "YF","BYJHSJ", BYZSJ, XFJXBYSJ, RJSJBY, BYHSJC, BYHSZSJ, BYWCZSJ, BYWCBFB) AS select a.sfzhm, a.dwdm, a.fxydh, a.nd,a.yf,a.byjhsj,a.byzsj,a.xfjxbysj,a.rjsjby,a.byhsjc,a.byhszsj,a.bywczsj,a.bywcbfb
from ZzLL_GJGWRY_FXY_YDXLQK a;



insert into VIEW_EXY_YDXLQK(SFZHM, DWDM,FXYDH, ND, YF,BYJHSJ, BYZSJ, XFJXBYSJ, RJSJBY, BYHSJC, BYHSZSJ, BYWCZSJ, BYWCBFB) values('123456','30414', '', '2014','01',0,0,0,'',0,0,0,0);



oracle编译proc方式：

1、修改配置文件pcscfg.cfg
/u01/app/oracle/product/12.1.0.2/db_1/precomp/admin/pcscfg.cfg

2、执行编译proc文件
proc proc.pc

3、编译.c文件
gcc -o login login.c -L/u01/app/oracle/product/12.1.0.2/db_1/lib -l clntsh


编译c文件提示sqlca头文件报错：
gcc -o demo_test ScrollDemo1.c -L/u01/app/oracle/product/12.1.0.2/db_1/lib -I/u01/app/oracle/product/12.1.0.2/db_1/precomp/public -I/u01/app/oracle/product/12.1.0.2/db_1/rdbms/public -l clntsh

gcc -o demo_test proc.c -L/u01/app/oracle/product/12.1.0.2/db_1/lib -I/u01/app/oracle/product/12.1.0.2/db_1/precomp/public -I/u01/app/oracle/product/12.1.0.2/db_1/rdbms/public -l clntsh

orale登录用u及密码：
用mdsys


selda = sqlald(MAX_SELECT_ITEMS, MAX_NAME_SIZE, 0);
EXEC SQL PREPARE S FROM :stmt;
EXEC SQL DECLARE C SCROLL CURSOR FOR S;
EXEC SQL OPEN C;
EXEC SQL DESCRIBE SELECT LIST FOR S INTO selda;
EXEC SQL FETCH CURRENT C USING DESCRIPTOR selda;

for (sli=0; sli<selda->N; sli++)
          printf("%.10s ", c_data[sli]);

EXEC SQL CLOSE C;

393220		0
393219		-1
393218		-2
393217		-3
393216		-4
393215		-5

批量查询相关代码：
MallocBuf.cpp
TestLock.cpp
MallocBuf.h
TestLock.h
resource.h


2023-10-31

1、数据下载这块，我们当时接触的demo用例中，数据结构体的申请内存大小（结构体申请元组个数）是固定写死的，那么应用中用于接收数据的内存大小也是固定写死的吗？
2、如果数据结构体的申请内存大小是固定写死的，那么如果数据库返回的行数超过这个结构体申请个数的话，应用内存会输出越界，那这种应用是怎么处理的？


create table tb(v1 varchar(20), v2 int, v3 double, v4 numeric, v5 numeric(10,0), v6 numeric(5,2), v7 text);
aaa |  1 | 1.1 |  4 |  5 | 6.20 | end

insert into tb select 'aaa',generate_series(1,1000000),1.1,1.2,3,4.2,to_char(now(), 'yyyy-mm-dd');	

类型											偏移长度
char、varchar 与 varchar2 						定义长度+1			eg：varchar2(20)	//偏移21
int												sizeof(int)
double											sizeof(double)
numeric与decimal								if (precision[i] == -1 || col_scale[i] > 0) //sizeof(double)   	else  //sizeof(int)
timestamp										20
像to_char等其他函数返回不定长字串				根据实际长度偏移带\0


windbg调试：
https://zhuanlan.zhihu.com/p/43972006

https://www.52pojie.cn/thread-599555-1-1.html

windbg 错误示例关键字：
Bug Check 0x1E

analyze输出显示章节：
Using the !analyze Extension


命令：
1、设置符号路径
.symfix

.sympath 设置pdb文件夹路径
.srcpath 设置源代码位置

ImagePath 可执行文件路径


28s现场问题记录：
高频崩溃：
GDisplay.exe（GDisplay Microsoft 基础类应用程序）//导致指挥系统界面不显示的进程
GAppFrame.exe
Tx_DataManager.exe
YDMultiProcessShell.exe			//libuxsql.dll
LDProc.exe（席位端雷达进程）
ZZZH.exe


偶现崩溃：
HKBJSMainDll.exe
SjlHyMultiProc.exe
QDmzh.exe





dns获取windows使用接口GetPrivateProfileStringA：文档中有记录：
GetPrivateProfileStringA



查看进程的PID：
tasklist
查看进程的父子关系:
wmic process get Caption,ParentProcessId,ProcessId



2023-11-15

完善的proc修改路径：
D:\mywork\mywork_2023\南京28所\优炫_001


#pragma warning(disable : 4566)



win7 dump生成路径：
%SystemRoot%\MEMORY.DMP


windbg线程调试方式：

~*kbn			//显示所有线程信息

!analyze -vv	//显示详细信息

~~[threadid]s						//跳转到对应线程堆栈

.  0  Id: 42fc4.43f1c Suspend: 0 Teb: 00000000`009aa000 Unfrozen
   1  Id: 42fc4.43024 Suspend: 0 Teb: 00000000`009ba000 Unfrozen
   2  Id: 42fc4.4446c Suspend: 0 Teb: 00000000`009c2000 Unfrozen
   3  Id: 42fc4.42c54 Suspend: 0 Teb: 00000000`009c6000 Unfrozen
0:000> ~~[43024]s

在 64位系统上运行的32位应用程序，会由 WOW64（Windows 32-bit on Windows 64-bit）进行兼容性支持,
需要使用 wow64exts 扩展。

1、加载 wow64exts 扩展：
.load wow64exts

2、设置 Wow64 环境：
!wow64exts.sw


2023-11-20
uxdb获取的返回类型：
1、max、min			//double


count(*) 	//uxdb使用bigint接收

大对象设置：
guc参数：
lob_with_oid			//设置为on，  显示oid，向oid中插入数据；

大对象对应的系统表：
select * from ux_largeobject;


select distinct B.MC,A.GZWQ,case when A.GZWQLB = '1' then '空空导弹' when A.GZWQLB = '2' then '空面导弹' when A.GZWQLB = '3' then '制导航空炸弹' else '空地导弹' end  as GZWQLB,A.SL, A.GJJL from SJGC.WQZB_ZBXN_FJWQGZ A join JCSJ.JCSJ_S_WQZB_FJ B on A.ZBNM = B.ZBNM order by B.mc;

create table SJGC.WQZB_ZBXN_FJWQGZ(ZBNM VARCHAR(24), ZBMC VARCHAR(40), FJLB VARCHAR(24), GB VARCHAR(8), XH NUMERIC(8,0), GZWQ VARCHAR(100), GZWQLB VARCHAR(24), SL NUMERIC(8,0), GJJL NUMERIC(8,2));

create table jcsj.jcsj_s_wqzb_fj(zbnm VARCHAR(24), xh VARCHAR(40),mc VARCHAR(80), jldw VARCHAR(20),zzbz VARCHAR(2));



insert into SJGC.WQZB_ZBXN_FJWQGZ select 'aaa','bbb', 'ccc', 'aaa',generate_series(1,330), 'ddd', '空空导弹', generate_series(1,330), 1.1;
insert into jcsj.jcsj_s_wqzb_fj select 'aaa', 'bbb', 'ccc'||generate_series(1,330), 'ddd', 'ee';

select count(*) from SJGC.WQZB_ZBXN_FJWQGZ A join JCSJ.JCSJ_S_WQZB_FJ B on A.ZBNM = B.ZBNM order by B.mc;

ecpg类型问题：
date	//1、数据长度问题（wins 26位、linux 19位）	2、数据显示不正确问题

28s机器IP：
6.66.66.106

2023-11-23

windows exe多进程进程相关代码：
// demo_project.cpp : 定义控制台应用程序的入口点。
//
#include <stdio.h>
#include<iostream>
#include<Windows.h>
#include <tchar.h>


// 函数声明
HANDLE CreateChildProcess(LPTSTR exePath);

int main() {
    // 创建子进程1
	LPTSTR cConDir1 = _T("C:\\Users\\ljf\\Documents\\Visual Studio 2010\\program1\\program1\\Debug\\program1.exe");
	LPTSTR sConLin1 = new TCHAR[MAX_PATH]; // 为连接后的字符串分配足够的空间

	    // 使用 wcscpy_s 安全地拷贝常量字符串到缓冲区
    if (wcscpy_s(sConLin1, MAX_PATH, cConDir1) != 0) {
        cerr << "Failed to copy string." << endl;
        delete[] sConLin; // 释放分配的内存
        return 1;
    }
	LPTSTR cConDir2 = _T("C:\\Users\\ljf\\Documents\\Visual Studio 2010\\program1\\program1\\Debug\\program2.exe");
	LPTSTR sConLin2 = new TCHAR[MAX_PATH]; // 为连接后的字符串分配足够的空间

	    // 使用 wcscpy_s 安全地拷贝常量字符串到缓冲区
    if (wcscpy_s(sConLin2, MAX_PATH, cConDir2) != 0) {
        cerr << "Failed to copy string." << endl;
        delete[] sConLin; // 释放分配的内存
        return 1;
    }
  //  HANDLE hChildProcess1 = CreateChildProcess("C:\Users\ljf\Documents\Visual Studio 2010\program1\program1\Debug\program1.exe");
	HANDLE hChildProcess1 = CreateChildProcess(sConLin1);
    if (hChildProcess1 == NULL) {
        fprintf(stderr, "Error creating program1.exe: %ld\n", GetLastError());
        return 1;
    }

    // 创建子进程2
    //HANDLE hChildProcess2 = CreateChildProcess("C:\Users\ljf\Documents\Visual Studio 2010\program1\program1\Debug\program2.exe");
	HANDLE hChildProcess2 = CreateChildProcess(sConLin2);
    if (hChildProcess2 == NULL) {
        fprintf(stderr, "Error creating program2.exe: %ld\n", GetLastError());
        CloseHandle(hChildProcess1); // 关闭第一个子进程的句柄
        return 1;
    }

    // 在这里可以添加等待子进程完成的代码

    // 等待子进程1完成
    WaitForSingleObject(hChildProcess1, INFINITE);

    // 等待子进程2完成
    WaitForSingleObject(hChildProcess2, INFINITE);

    // 关闭子进程句柄
    CloseHandle(hChildProcess1);
    CloseHandle(hChildProcess2);

    return 0;
}

// 创建子进程的函数
HANDLE CreateChildProcess(LPTSTR exePath) {
    PROCESS_INFORMATION pi;
    STARTUPINFO si;

    // 初始化 STARTUPINFO 结构体
    ZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);

    // 创建子进程
    if (!CreateProcess(
            NULL,             // 不使用可执行文件名，使用命令行参数中的可执行文件路径
            exePath,   // 可执行文件路径
            NULL,             // 进程安全描述符
            NULL,             // 线程安全描述符
            FALSE,            // 子进程不继承句柄
            0,                // 创建标志
            NULL,             // 使用父进程的环境变量
            NULL,             // 使用父进程的当前目录
            &si,              // STARTUPINFO 结构体
            &pi               // 进程信息结构体
    )) {
        fprintf(stderr, "Error creating %s: %ld\n", exePath, GetLastError());
        return NULL;
    }

    // 关闭主线程的句柄，因为我们不会使用它
    CloseHandle(pi.hThread);

    // 返回子进程的句柄
    return pi.hProcess;
}

成功用例：
#include<iostream>
#include<Windows.h>
#include <tchar.h>
using namespace std;


int _tmain(int argc, _TCHAR* argv[])
{
    LPTSTR cConDir = _T("C:\\Windows\\System32\\cmd");
    LPTSTR sConLin = new TCHAR[MAX_PATH]; // 为连接后的字符串分配足够的空间

    // 使用 wcscpy_s 安全地拷贝常量字符串到缓冲区
    if (wcscpy_s(sConLin, MAX_PATH, cConDir) != 0) {
        cerr << "Failed to copy string." << endl;
        delete[] sConLin; // 释放分配的内存
        return 1;
    }

    // 使用 StringCchCat 安全地连接字符串
  /*  if (StringCchCat(sConLin, MAX_PATH, _T("cmd.exe")) != S_OK) {
        cerr << "Failed to concatenate strings." << endl;
        delete[] sConLin; // 释放分配的内存
        return 1;
    }*/

    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory(&si, sizeof(si));
    ZeroMemory(&pi, sizeof(pi));

    //创建一个新进程
    if (CreateProcess(
        NULL,    // 指向一个NULL结尾的、用来指定可执行模块的宽字节字符串
        sConLin, // 命令行字符串
        NULL,    // 指向一个SECURITY_ATTRIBUTES结构体，这个结构体决定是否返回的句柄可以被子进程继承。
        NULL,    // 如果lpProcessAttributes参数为空（NULL），那么句柄不能被继承。
        false,   // 指示新进程是否从调用进程处继承了句柄。
        0,       // 指定附加的、用来控制优先类和进程的创建的标
                 // CREATE_NEW_CONSOLE  新控制台打开子进程
                 // CREATE_SUSPENDED    子进程创建后挂起，直到调用ResumeThread函数
        NULL,    // 指向一个新进程的环境块。如果此参数为空，新进程使用调用进程的环境
        NULL,    // 指定子进程的工作路径
        &si,     // 决定新进程的主窗体如何显示的STARTUPINFO结构体
        &pi      // 接收新进程的识别信息的PROCESS_INFORMATION结构体
    ))
    {
        cout << "create process success" << endl;

        // 下面两行关闭句柄，解除本进程和新进程的关系，不然有可能不小心调用TerminateProcess函数关掉子进程
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
    }
    else {
        cerr << "failed to create process" << endl;
    }
	

    // 释放分配的内存
    delete[] sConLin;

	Sleep(10000);

    return 0;
}

注意点：
1、windows代码中exe执行路径需要用转义符，eg：C:\\Users\\ljf\\Documents\\Visual Studio 2010\\program1\\program1\\Debug\\program1.exe
2、CREATE_NEW_CONSOLE,  // 创建新控制台打开子进程


执行 dumpbin /DEPENDENTS + 你的exe工程，输出exe依赖的dll文件，

dumpbin /headers your_file.exe




libecux.dll
libecux_compat.dll
libuxsql.dll
libuxtypes.dll
libssl-1_1.dll
libcrypto-1_1.dll



libodbcinst-2.dll
libltdl-7.dll
libwinpthread-1.dll

2023-12-05

select cast(count(*) as number(10,2)) from
(select a1.MC ZBNM, a2.MC DZZFJLXNM,a0.DZZYT, a0.FSJMJ,a0.DZZDX,a0.SYN_NM,a0.XLGD,
a0.ZDXLSH,a0.GRJL,a0.GRYS,a0.GRQD, ao.GRFRFW,a0.GRFGQY from kjsjgx.WQZB_ZBXN_DK_DKZYFJZSB a0,
dbsjgx.ZZBZ_S_TY_ZB a1, kjsjgx.ZZBZ_S_KJ_FJLB a2 where a0.ZBNM=a1.ZBNM(+) and a0.DZZFJLXNM=a2.FJLBBM(+));

select cast(count(*) as number(10,2)) from
(select * from test where v2 > 0 order by v2 desc);



1、总共跑了四次，每次core一两个，堆栈看着都是应用报错；
2、今天tx应用那个exe编译过了，但是调试到qt的一个接口卡住了，跑了两次都是这种情况，然后替换oracle新编译的dll是好的；


2023-12-06
1、在函数
Query_Data_File(SDatabaseInfo * stDbInfo,char * szSqlContent,char *szFileName);
中也添加下多线程日志信息，第二个参数szSqlContent是sql语句，在函数中尾部添加标识
2、
可以通过屏蔽接口函数体的内容，例如：Lob_Query_Data_Mem_Proc 函数体的内容，
排查core问题，观察下应用崩溃现象

3、查看内存泄漏工具

Visual Leak Detector


2023-12-12
问题：
rpm包安装后，root登录后闪退；

原因：
系统库影响，因为rpm安装的数据库中使用了系统的库文件，猜测可能是libtinfo这个库导致；
uxdb包含的系统库如下：
libz、liblz4、libreadline、libossp-uuid、libtinfo、
libxml2、libzstd

2023-12-14

deb包问题：

update-rc.d报错：
解决方法：
1、先加载系统服务
systemctl daemon-reload
2、再停止服务
sudo service uxdb stop

dpkg -i + deb包		//安装命令
dpkg -l |grep + 包名关键字			//查看已安装包
sudo dpkg -r +包名关键字			//卸载软件包，保留配置信息
sudo dpkg -P +包名关键字			//卸载软件包，不保留配置



















截至12-7：

不稳定崩溃；
高频崩溃：
LDProc.exe（席位端雷达进程）


偶现崩溃：
YDMultiProcessShell.exe
Tx_DataManager.exe
HKBJSMainDll.exe

界面显示：
有时显示正常，有时不显示，显示界面时，部分功能无法正常使用；

12-4
跑了四五次，第六次出现libuxsql的报错；

12-5、12-6、12-7
也偶现libuxsql的报错；

后续计划：
1、大对象内存插入、内存下载构造测试用例验证修改，
内存检测目前除大对象未检测，其他均检测正常，无内存泄露问题；

2、目前对于libuxsql不稳定报错，后面尝试使用vs2010编译看是否可以编译成功；

3、对于非libuxsql的报错，由于目前报错基本在以上应用，通过结合客户提供源码，分析报错；



2023-12-15

1、修复大对象接口的自测试问题。
2、走读代码，编写各类型自测试用例，排查其他问题；

发现问题：
1、链接信息错误，会导致core问题；


2023-12-18

1、proc与现场代码区别整理

1）windows下date强转类型改为timestamp；

2）proc代码需要将以下类型做下字节对齐，空和非空都要改下：
long、long long

3）main.cpp需要修改odbc获取dns域名的代码

4）释放内存

2023-12-19
ecux编译命令：
编译生成cpp文件：
ecux user.pc -o user.cpp
编译生成二进制文件：
g++ user.cpp -lecux -luxsql -I/home/uxdb/uxdbinstall/dbsql/include -L/home/uxdb/uxdbinstall/dbsql/lib -o usertest -g


压缩包包含以下内容
一、proc.pc修改点：
1、相对上次发送proc节点修改，以下3点现场应该已做修改，可以再对比下代码，看是否还有差异；
a）windows下date强转类型改为timestamp；
b）proc代码需要将以下类型做字节对齐，空和非空都要改下：
long、long long放一块处理；
c）断开链接释放链接串内存；

2、
a) date类型处理长度修改为9, 偏移为10；
b) 修复大对象DESCRIBE INPUT问题，有问题接口如下：
Lob_Insert_Data_Proc
Lob_Update_Data_Proc
Lob_Update_Data_Proc_mem
Lob_Insert_Data_Proc_Mem
Batch_Bind_Value_Proc


二、main.cpp修改遗留dns域名获取；
三、
包含以下依赖库，后面有时间可以尝试将这些库进行替换，替换前记得备份之前的库；
libecux.dll
libecux_compat.dll
libuxsql.dll
libuxtypes.dll

四、包含两个文档：
兼容性说明文档；
uxdb差异点整理；



由于klyv4+x86机器部署还需要一定的时间，这次使用centos x86进行打包，理论上centos也可以用，
可以到现场先安装试下，如果有问题，那么替换回原来的包，
这次2122最新更新的缺陷应该与现场core问题没有关系，所以使用上次的包也不影响应用的调试；


编译问题：



configure: error: library 'xml2' (version >= 2.6.23) is required for XML support
解决方式，安装以下库，解决思路查看config.log日志：
liblzma-dev





#189684：ECPG现场问题支持，查看分析exe调用栈，调研现场proc与ecpg函数差异问题，windows段错误问题分析文档整理+proc格式修改+ proc代码告警修改验证；
#189684：ECPG现场问题支持，查看分析exe调用栈，分析windows date类型打印长度问题
#189684：ECPG现场问题支持，分析proc链接报错代码，模拟windows多进程调用exe
#189684：ECPG现场问题支持，dll工程编译，验证多字符集编译
#189684：ECPG现场问题支持，确定windows编译是否存在线程安全参数、整理嵌入式sql依赖库、重新编译libuxsql与libecux动态库；
#189684：ECPG现场问题支持，查看分析exe调用栈，make check windows 32客户端链接linux 64位数据库
#189684：ECPG现场问题支持，28s现场线程oracle编译问题协助，验证ecux linux与windows make check问题；
#189684：ECPG现场问题支持，编译vld，并在vs2010使用验证内存泄露，分别验证1、数据增删改, 2:数据下载, 3:大字段数据操作 ,4:事务方式入库 5、数据库链接断开测试；
#180943：保密四七资质登陆界面无法登录成功，自启动脚本修改并验证、kylin10-aarch64与中科方德NFS4-x86_64打包验证
#197635：涉密rpm包自启动脚本报错，并提交到2122、2123分支；
#186397：二十八所项目链接报错问题windows、linux分析链接core问题、count类型返回值问题分析、大对象基本类型demo测试
#194913、#190637代码合入2122、2123分支
#186397：二十八所项目链接报错问题windows、linux分析链接core问题已确定、大对象类型demo测试验证， 大对象存在DESCRIBE INPUT问题，已修改验证正常；

2023-12-26

kylinV4+x86源设置：
deb http://archive.kylinos.cn/kylin/KYLIN-ALL 4.0.2-desktop main restricted universe multiverse

现场数据库类型：
number(x,0)		number(x)
number(*,x)		number(38,x)
number(x,y)		number(x,y)
char(x)			char(x)
timestamp(x)	timestamp(x)
varchar2(x)		varchar(x)
float(x) 	float
nvarchar2(x)	varchar(x)
raw 			bytea
nchar(x)		varchar(x)
urowid(x)		varchar(x)
nclob			clob
rowid(10)			varchar(18)
long raw		bytea
date			date
clob			clob
blob			blob
long			text


存在问题的映射：

nvarchar2(x)	varchar(x)

rowid			varchar(18)

float(x) 	float
raw 			bytea
urowid(x)		varchar(x)
nclob			clob
long raw		bytea
long			text

以上转换，如果数据用于内存下载可能都有问题，

1、迁移建议修改转换：
raw->varchar(32)
long raw->varchar(240)
long->varchar(240)

2、float(x)超强看下x是都有哪种形式，如果是4和8的话，咱们数据库有对应的类型float4与float8，
迁移工具可以修改为：
float(4)->float4
float(8)->float8
3、
对于以下映射关系还需确认下
urowid(x)		varchar(x)
nclob			clob


avg、count、max、min、sum


自定义枚举类型，无法强转成numeric；	（因为存储的数据类型不匹配）
INTERVAL、INET、OID、TIMESTAMP WITH TIME ZONE 无法强转成numeric；

当类型是text是，存储数据非数字时，会提示语法错误；
INTEGER[]数组类型无法强转成numeric；

LENGTH(NUMERIC)函数不存在

FUNC--		TYPE1--			TYPE2--
min			RAINBOW			INET
max			RAINBOW			INET
avg			INTERVAL


oracle中，聚合函数 avg、count、max、min、sum 的处理：

create table tb(v1 numeric, v2 numeric(4,3), v3 numeric(4,0), v4 float, v5 float(8), v7 date, v8 varchar(20));
select count(v1),count(v2),count(v3),count(v4),count(v5),count(v7),count(v8) from tb;

select avg(v1),avg(v2),avg(v3),avg(v4),avg(v5),avg(v8) from tb;
select sum(v1),sum(v2),sum(v3),sum(v4),sum(v5),sum(v8) from tb;
select max(v1),max(v2),max(v3),max(v4),max(v5),max(v8) from tb;
select min(v1),min(v2),min(v3),min(v4),min(v5),min(v8) from tb;

select avg(v7),sum(v7),max(v7),min(v7) from tb;




























2123 make编译报错，执行以下命令：
export STALIB_INSTALL=/home/uxdb/uxdb-ng/thirdparty/stalib_install










