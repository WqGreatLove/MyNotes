报销流程：李悦
发票报销：王淼

资料查找网站：

阿里云：
https://developer.aliyun.com/

remine问题：邓杰、钱金龙


提交代码：
代码分支：
标准版：
dev/ver2.1.1.4_dev
安全版：
dev/ver2.1.0.4s_dev

重构版：
dev/ver2.1.1.4s_dev

对外支持分支：
support/#101817

分支命名：

我的分支feature/ver2.1.1.3_dev/#91139

feature/ver2.1.1.3_dev/#94056
bug/ver2.1.1.3_dev/#94937

bug/ver2.1.0.4s_dev/#101492

测试分支：dev/ver2.1.1.3_dev_merge_into

对外支持分支：
1、开发基版分支
support/#102593

2、提交分支
102680_zwj

代码提交：
redmine提交merge：

•Root Cause (Bug) or Purpose (RFE/Task): #177029:kylin4/arm环境编译db冲突报错
•Affected Area:
•Solution:
问题分析：
代码分支：
support/#125828
repmgr、uxmpp、ux_probackup编译存在冲突问题；

处理方案：
删除冗余定义变量，解决冲突问题；

•Recommended Test Area:
•Reviewed by: 高升明
•Approved by: 高升明
•svn checkin rev Number：
2a299215fc3b8b05f04ca085dc12404a287834b0
•Affected files：3
uxdb-2.1-upper/contrib/repmgr/repmgr-client-global.h
uxdb-2.1-upper/contrib/uxmpp/src/include/distributed/uxmpp_nodes.h
uxdb-2.1-upper/src/bin/ux_probackup/src/backup.c


Unit test: 测试编译通过
测试步骤：
SELECT
    FORMAT(111111, 2),
	FORMAT(111111., 2),
    FORMAT(111111.111, 2),
    FORMAT(111111.111, 0),
    FORMAT('111111', 2),
	FORMAT(12332.123446,4),
	FORMAT(12332.123456,4),
    FORMAT(NULL, 2),
	FORMAT(12332.123456,4,'de_DE'),
	FORMAT(12332.123456,4,'en_US');

测试结果：






问题单记录：
问题分析、处理方案、验证结果、提交记录都要在单子上体现



uxdb项目：

1、项目目的：制作产品安全

2、熟悉项目框架
（1）通过微博、Google、百度、PDSN、等找到程序的体系结构，找到星星点点资料（很重要）

（2）[community | standard | professional | enterprise]

CE：社区版
EE：企业版
SE：标准版



3、项目组成

uxdb主要由DB以及DFS组成
DFS：分布式文件系统（Distributed file system），DFS由DIR、MRC和OSD三个模块组成，以Volume（卷）的形式管理文件
DIR：目录服务器，用来记录集群中可用的元服务器和数据存储器的状态，可用的Volume信息，mapping OSD/MRC的URL到服务。
MRC：元服务器，用来记录集群的基本信息，volume信息，文件对OSD的索引以及文件属性（大小，路径，所有者，访问Mask，时间信息等）和replication的信息
OSD：数据服务器，用来存储文件内容。
Volume：提供层级化的名称空间，相当于逻辑的卷。在电脑中， volume（文件集）是一个可辨认的数据存储（storage）单元。

4、配置文件

pg_hba.conf 配置详解：
https://blog.csdn.net/yaoqiancuo3276/article/details/80404883
trust：表示无需密码

/********************************************work*******************************************/

1、svn://192.29.1.2/svn/uxdb/11.开发/05.计划/2020/ver2.1.0.3/ver2.1.0.3 db自测基本用例.xls 组内自测


数据库机器：
mysql

mysql使用：
https://blog.csdn.net/weixin_43268590/article/details/123776118
1、mysql数据库安装
安装mariadb：
yum install mariadb-devel
yum install mariadb

yum install mariadb-server

mysql: (192.71.0.243 root/123456)
  cd /home/mysql/mysql157/bin
  ./mysql -uroot -p 123456		//登陆后，使用mysql数据库: use mysql



uxdb通过fdw访问mysql数据库：
步骤如下：
1、新建mysql_fdw插件
create extension mysql_fdw;

2、创建MySQL服务器定义(mysql库ip和端口)。
CREATE SERVER mysql_server FOREIGN DATA WRAPPER mysql_fdw OPTIONS (host '192.71.0.243', port '3107');

3、创建用户映射，将MySQL服务器定义映射到uxdb的某个用户上，将来使用这个用户访问MySQL的数据。
CREATE USER MAPPING FOR uxdb SERVER mysql_server OPTIONS (username 'root', password '123456');

4、使用上一步骤的uxdb用户创建MySQL的外部表（在mysql创建表test1）。
登录mysql：
使用root用户创建表test1(mysql 必须带主键)：
create table test1 (name text primary key, age int);

uxdb执行创建外部表
CREATE FOREIGN TABLE tkb_test (name text, age int) server mysql_server options (dbname 'mysql', table_name 'test1');
5、通过uxdb可以访问mysql的外部表
Insert into tkb_test values ('111',1);
Insert into tkb_test values ('222',2);
select * from tkb_test;


oracle_fdw:
Oracle的外部连接
Oracle机器上的
连接到默认数据库
sqlplus / as sysdba
 create user C##ora_tkb1 identified by "123456";
grant dba,resource,connect to C##ora_tkb1;
切换到定义的用户
conn C##ora_tkb
create table test_tab(id int,name varchar(100));
select * from test_tab;

uxdb数据库上执行
create extension oracle_fdw;
create server osdba_fdw foreign data wrapper oracle_fdw options (dbserver '//192.71.0.244:1521/orcl');
CREATE USER MAPPING FOR uxdb SERVER osdba_fdw OPTIONS (user 'C##ora_tkb', password '123456');
CREATE  FOREIGN TABLE "test_tab" (id int,name varchar(100)) SERVER osdba_fdw OPTIONS (table 'TEST_TAB');
select * from test_tab;
INSERT INTO test_tab select generate_series(1,10),'bb';
select * from test_tab limit 5,10;



  启动服务：
  1./etc/init.d/mysqld start 
  2. ./mysqld --defaults-file=/home/mysql/mysql57/conf/my.cnf --initialize --user=mysql --basedir=/home/mysql/mysql57 --datadir=/home/mysql/mysql57/data
ORACLE:(192.71.0.244 oracle/123456)
  以oracle用户登录服务器，
  执行sqlplus / as sysdba进入管理员模式
达梦:(192.71.0.245 root/123456)
  cd /dm8/bin 
  启动服务：./DmServiceTest start 
  启动客户端：./disql

金仓:(192.71.0.248 root/123456)
  cd /opt/Kingbase/ES/V8/Server/bin 
  创建实例：./initdb -W -D testdb
  启动服务端：./sys_ctl -D testdb -l logfile start
   目录：/opt/Kingbase/ES/V8/ClientTools/bin 
  启动客户端：./ksql -d test -p 54328

2020-06-15

一、数据位置

1、我的密码
redmine/git/svn 账号/密码:1413014046.wq
wangqi/1qaz!QAZ

我的服务号：
服务 #80869

云账号:
云账号密码：
账号是wang_qi  密码：1413014046.wq
云网址：
http://111.204.26.202:10103/learning/hrux/user/hruxHome/index.html

svn://192.30.1.2/svn/uxdb/40.部门管理/03.产品服务部/01.年度计划/03.2022年/01.部门计划/产品服务部计划_2022年.xlsx

版本云存放路径：
rdshare/reading/rdshare/xian/release/uxdb

1、Nuxsql云路径：
http://cd.uxsino.com:24080/apps/files/?dir=/rdshare/reading/rdshare/xian/release/uxdb/ver2.1.1.4/release/04%20%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Windows&fileid=3039523

2、版本云存放路径：
/rdshare/reading/rdshare/xian/release/uxdb/ver2.1.1.4/release

3、Npgsql github链接：
https://github.com/npgsql/npgsql/tree/main/src

密码：
vpn：

VPN 
账号 tianjinyang
        密码 tianjinyang@123
gaomingsheng
gaomingsheng@123

工时登记：
密码：12345678

云：
用户名：wangqi
密码：
1413014046.wQ

绩效考核：
密码：12082499

绩效考核+工时：
http://cd.uxsino.com:2090/#/login
账号：wang_qi
密码：12082499

ci机器：

windows：
ci界面登录：
用户名/密码：uxdb/123456
ci机器登录
windows CI 117.34.70.110:63389 用户密码：uxdb / uxdb@123

ci打包链接：
http://117.34.70.110:58085/job/uxdb-package/

2、我的ip

192.29.0.XX  81--85  255.255.254.0  192.29.1.1  192.29.1.1

用户名  IPv4前缀  IP段  掩码  网关  DNS

新办公场地：
IP段  掩码  网关  DNS
192.71.0.136~192.71.0.140
255.255.254.0
192.71.0.1
218.30.19.40

svn和ftp：
192.30.1.2

3、我的邮箱

wang_qi@uxsino.com
密码：1413014046.whj

4、git链接
svn地址：svn://192.29.1.2/svn/uxdb uxdb 1qaz!QAZ						//工具路径
git地址：git clone https://222.212.87.87:10943/db/uxdb-ng.git			//版本代码路径
https://cd.uxsino.com:10943/db/uxdb-ng
ftp地址：ftp://192.30.1.2/tools/VM/centoOS/    uxsino  123456
ftp地址：sftp://192.29.2.229   uxsino  123456							//工具路径与上面svn作用一样


wins CI机器：
117.34.70.110:63389
密码：
uxdb/uxdb@123




sftp地址：Uxsino_1918													//版本代码与git作用一致
客户端FileZilla
协议：sftp
主机：222.212.87.87
端口号：40232
用户名：rdshare
密码： Uxsino_KZoc8j5E

对外支持：

1、对外支持项目编号：
http://192.30.1.2:8090/pages/viewpage.action?pageId=11501920


项目工作：
河南移动：A01097617202210156
中防生态：SP202203310011
沈抚项目：A02403729202110949
9601项目：A01021769202210515
陕西军民融合信创项目: A02903359202210715
山西临汾xc：MA35103088202120147
中船WRT项目:
重庆传晟:
云上贵州：A851142725202211194
旋极军工项目(#129384)：JA01070578202220026
军工二十四套数据库项目:JA01070578202120039
交通委 A01036272202210173

XX车型号数据库
JA01070578202220026

3.28-4.2
1、准备研发部培训										12h
2、#135974 河南移动中标项目支持，rowid转bigint转换		4h
3、#138262 中防生态适配打包								16h		
4、#136367 dbms_utility.get_hash_value功能支持			4h
5、#138648 沈抚项目实施内部群							4h		
6、#138851 trunc、decode、nvl、mod等函数支持			8h		


4.6-4.8
1、#138851 add_months、months_between、last_day、to_char等函数支持		8h
2、uxpool研发部培训准备													8h
3、#135974:listagg、grouping_id、regexp_like、pg_backend_pid、chartorowid、userenv等函数功能支持
																	8h

虚拟机存放位置：
1.2上/tools/VM/uxdb：
linux虚拟机：CentOS 64 位7.4_UXDB_DEV.rar
windows：

版本存放位置：
/opt/rdshare/reading/rdshare/xian/release/uxdb/

流程规范参考地址:
http://cd.uxsino.com:19503/projects/dev_uxdb/wiki/%E6%B5%81%E7%A8%8B%E8%A7%84%E8%8C%83

postgre资料：

1、uxdb文档
http://192.30.1.2/uxdb.html			//版本说明


2、pg查找资料

pg相关结构体关联源码查询
https://doxygen.postgresql.org/

pg学习资料：
1）、学习笔记
https://zhmin.github.io/archives/page/3/

2）、数据内核

http://mysql.taobao.org/monthly/

3、pg知识点
autoprewarm功能：
1）定时将内存中的数据写入autoprewarm.blocks文件中，定时时间pg_prewarm.autoprewarm_interval默认300s；
2）执行stop时，autoprewarm进程会将内存数据写入autoprewarm.blocks文件中；

pg内核：

1、PostgreSQL 基于heap表 存储引擎实现原理
https://zhuanlan.zhihu.com/p/557482910


2020-06-16

1、source insight

（1）、搜索某个变量、宏的方法


问题：

2、uxdb安装
Please input uxdb user[uxdb]:uxdb
Do you want to install UXFS?[Y/N]:
Please input UXFS install dir[/home/uxdb/uxdbinstall]:
UXFS will be installed to [/home/uxdb/uxdbinstall/uxfs].
记录了398729+1 的读入
记录了398729+1 的写出
204149704字节(204 MB)已复制，8.04415 秒，25.4 MB/秒
UXFS installed completely.
Do you want to install DBSQL?[Y/N]:
Please input DBSQL install dir[/home/uxdb/uxdbinstall]:
DBSQL will be installed to [/home/uxdb/uxdbinstall/dbsql].
[sudo] uxdb 的密码：
记录了398729+1 的读入
记录了398729+1 的写出
204149704字节(204 MB)已复制，9.13671 秒，22.3 MB/秒
DBSQL installed completely.
installing deploy tools ... done
installing license tools ... done
configuring environment variable of uxdb ... done
Install UXDB success!


2020-06-17

1、专业名词缩写

uxdb：
uxfs:

osd：
DIR：

2020-06-19

1、安装DB和DFS文档
编译安装DB和DFS gdb调试总结--李佩维.docx

license：
编译启动DB：
进入uxdb-2.0 目录，执行 ./build.sh –-release=enterprise –-version=2.1.0.3 –-liense=internal –-debug=yes
编译license代码，生成license生成工具：
uxdb-ng/uxdb-tools/UXDBLicense-encoder/UxdbLicense
uxdb-ng/install/linux/AutoGetLicenseInfo

2、进入uxdb安装目录下的license目录

修改IpAdd.ini文件		文件路径：/home/uxdb/uxdbinstall/license

./GetUserInfo.sh --version_type=enterprise --version=2.1.1.3
3、将UxdbLicense.json拷贝到 /home/uxdb/uxdbinstall/encryptLicense/encryptor/config/ 目 录下；
4、在 /home/uxdb/uxdbinstall/encryptLicense目录下执行 ./UxdbLicense ；
5、将 /home/uxdb/uxdbinstall/encryptLicense/encryptor/output目录下生成的uxdb.lic 拷贝 到 /home/uxdb/uxdbinstall/license/ 目录下即可。


二、初始化本地集群			//D:\old\svn\10.团队建设\01.新员工\01.总结心得\Uxdb安装、配置、使用--张栋梁.docx

进入DB目录（/home/uxdb/uxdbinstall/dbsql/bin），执行


./initdb -W -D uxdbtest
初始化本地集群

前台启动集群：

./uxdb -D uxdbtest
后台启动数据库：
./ux_ctl -D uxdbtest  start

查看server状态
./ux_ctl -D uxdbtest1 status

访问本地集群
./uxsql -d uxdb -U uxdb

关闭集群：
./ux_ctl -D uxdbtest1 stop

三、分布式集群

1、启动DFS和创建volume
创建volume：./mkfs.xtreemfs localhost/demo
//文档：D:\10.团队建设\01.新员工\01.总结心得\uxdb安装和编译-常鑫.docx

王若静

2、进入：/home/uxdb/uxdbinstall/dbsql/bin初始化集群
./initdb -W -Z -D test02

3、设置分布式集群端口
./uxsql -p 5455

4、启动分布式集群
./uxdb -Z -B 1024 -N 100 -p 5455 -D test02
5、查看DB server状态
./ux_ctl -Z -D test02 status

6、访问分布式集群
./uxsql -d uxdb -U uxdb



2020-06-23

1、
产品到期时间是可以手动修改的，在UxdbLicense.json中为ExpiredDate字段。目前标准版是10年，企业版是20年，专业版是30年。这些时间可以由产品序列号管理员根据需要手动修改调整。

2、生成器和json文件区别


2020-06-29

一、shell脚本中if语句用法：

Shell中判断语句if中-z至-d的意思
[ -a FILE ] 如果 FILE 存在则为真。

[ -b FILE ] 如果 FILE 存在且是一个块特殊文件则为真。

[ -c FILE ] 如果 FILE 存在且是一个字特殊文件则为真。

[ -d FILE ] 如果 FILE 存在且是一个目录则为真。

[ -e FILE ] 如果 FILE 存在则为真。

[ -f FILE ] 如果 FILE 存在且是一个普通文件则为真。

[ -g FILE ] 如果 FILE 存在且已经设置了SGID则为真。

[ -h FILE ] 如果 FILE 存在且是一个符号连接则为真。

[ -k FILE ] 如果 FILE 存在且已经设置了粘制位则为真。

[ -p FILE ] 如果 FILE 存在且是一个名字管道(F如果O)则为真。

[ -r FILE ] 如果 FILE 存在且是可读的则为真。

[ -s FILE ] 如果 FILE 存在且大小不为0则为真。

[ -t FD ] 如果文件描述符 FD 打开且指向一个终端则为真。

[ -u FILE ] 如果 FILE 存在且设置了SUID (set user ID)则为真。

[ -w FILE ] 如果 FILE 如果 FILE 存在且是可写的则为真。

[ -x FILE ] 如果 FILE 存在且是可执行的则为真。

[ -O FILE ] 如果 FILE 存在且属有效用户ID则为真。

[ -G FILE ] 如果 FILE 存在且属有效用户组则为真。

[ -L FILE ] 如果 FILE 存在且是一个符号连接则为真。

[ -N FILE ] 如果 FILE 存在 and has been mod如果ied since it was last read则为真。

[ -S FILE ] 如果 FILE 存在且是一个套接字则为真。

[ FILE1 -nt FILE2 ] 如果 FILE1 has been changed more recently than FILE2, or 如果 FILE1 exists and FILE2 does not则为真。

[ FILE1 -ot FILE2 ] 如果 FILE1 比 FILE2 要老, 或者 FILE2 存在且 FILE1 不存在则为真。

[ FILE1 -ef FILE2 ] 如果 FILE1 和 FILE2 指向相同的设备和节点号则为真。

二、linux下使用tar与openssl进行加解密

https://blog.csdn.net/libinbin_1014/article/details/50386016

三、sudo -su和sudo -s
sudo su 和 sudo -s都是切换到root用户，不同的是：

sudo su 环境用的是目标用户(root)的环境

sudo -s 环境用的是当前用户本身的环境

2020-07-01

1、守护进程：postmaste
服务器主进程PostmasterMain（守护进程入口函数）
源码位置：uxdb-2.0\src\backend\main\main.c

2、服务进程：Postgres
入口函数：PostgresMain（UxdbMain）
源码位置：uxdb--2.0\src\backend\tcop

3、辅助进程：系统日志进程SysLogger ，后台写进程bgWriter，预写式日志写进程WalWriter，预写式日志归档进程pg_archive,系统自动清理进程AutoVacuum,统计数据收集进程pg_state

logger Progress
功能：输出数据库运行过程中的日志信息
函数：SysLogger_Start（SysLoggerMain）
源码位置：src\backend\uxmaster\syslogger.c

Checkpointer Progress（检查点进程）
功能：数据库恢复，如果没有检查点操作，一旦系统由于断电等原因崩溃，数据库系统无法确切地知道哪些更新已经写入磁盘，做了永久性确认；哪些更新还没有写入磁盘，需要重新执行或者回退。这时数据库系统的恢复需要使用系统运行以来的所有日志文件，整个恢复过程复杂而漫长。

函数：StartCheckpointer
源码位置：uxdb-2.0\src\backend\main\main.c

Bg writer Progress
功能：对共享缓冲区的写操作进行统一的管理（管理共享缓冲区的数据，把脏数据刷出到磁盘）
函数：StartBackgroundWriter
源码位置：src\backend\uxmaster\uxmaster.c

wal writer Progress
功能：系统崩溃时，最近事物能够得到恢复（帮助恢复系统，先写日志后写数据，以便恢复数据）
fsync:（数据的一致性）
该参数直接控制日志是否先写入磁盘。默认值是ON(先写入)。开启该值时表明，更新数据写入磁盘时系统必须等待WAL的写入完成。
synchronous_commit:（事务的完整性）
参数表明是否等待WAL完成后才返回给用户事务的状态信息。默认值是ON，表明必须等待WAL完成后才返回事务状态信息。
函数：
|_ PostmasterMain()
	|_ ServerLoop()
		|_ StartWalWriter ()

autovacuum launcher Progress（用于释放系统空间）
功能：自动执行VACUUM和ANALYZE命令，释放空间
源码位置：
|_ main()
	|_ PostmasterMain()
		|_ ServerLoop()
			|_StartAutoVacLauncher()

stats collector Progress（数据库的统计）
功能：数据库统计信息收集器，专门负责收集数据库系统运行中的统计，如表的增删改次数
源码位置：
|_ main()
	|_ PostmasterMain()
		|_ ServerLoop()
			|_ uxstat_start ()


2020-07-03

git命令

1、将状态改变的代码提交至缓存
git add + 文件
git add -u + 路径：将修改过的被跟踪代码提交缓存
git add -A + 路径: 将修改过的未被跟踪的代码提交至缓存

2、git status			//显示所有修改记录

3、生成patch
git format-patch HEAD^ 　　　　　　　　　　　　　   #生成最近的1次commit的patch

指定commit的patch：
git format-patch -1 + commit号

4、打patch，通过git apply或git am
https://www.cnblogs.com/ArsenalfanInECNU/p/8931377.html
git apply和git am区别：git apply不会还原add和commit信息，git am会
git apply --stat 0001-limit-log-function.patch   　　　　  # 查看patch的情况
git apply --check 0001-limit-log-function.patch   　　　  # 检查patch是否能够打上，如果没有任何
如果没有问题，执行：
git apply 0001-limit-log-function.patch

git am 0001-limit-log-function.patch
git am --signoff 0001-limit-log-function.patch                  # 添加-s或者--signoff，还可以把自己的名字添加为signed off by信息，作用是注明打patch的人是谁，因为有时打patch的人并不是patch的作者
git am --abort                                                                   # 当git am失败时，用以将已经在am过程中打上的patch废弃掉(比如有三个patch，打到第三个patch时有冲突，那么这条命令会把打上的前两个patch丢弃掉，返回没有打patch的状态)
git am --resolved                                                             #当git am失败，解决完冲突后，这条命令会接着打patch
如果发生冲突，通过下面方式修改：
https://www.cnblogs.com/ArsenalfanInECNU/p/8931377.html

5、合并其他分支的commit到本地分支
git cherry-pick  0128660c08e325d410cb845616af355c0c19c6fe

然后就将A分支的某个commit合并到了B分支了

6、git记录用户名和密码：

git config --global credential.helper store

7、git push

git push <远程主机名> <本地分支名> <远程分支名>
将本地分支推到远端分支：
git push origin dbg_lichen_star:dbg_lichen_star				//dbg_lichen_star:dbg_lichen_star：本地：远端（可以随意起）

删除远端分支名：
git push origin --delete + 分支名

git常见问题
1：误将代码提交到缓存中（利用 git add 命令误将代码提交的缓存中）
解决办法：利用 git reset 命令将撤回缓存中的代码。

2：误将代码提交到本地仓库（利用 git commit 命令误将代码提交到本地仓库）
解决办法：
git reset —hard + 版本号
彻底回退到某个版本，本地的代码也会改变上一个版本内容。

8、git记住用户名密码、清除用户名密码

git config --global credential.helper store
git config --global --unset credential.helper

9、跟踪分支
1）、设置跟踪分支：
git branch --set-upstream-to=origin/support/#139826


linux命令：

1、scp命令
将id_rsa.pub拷贝并重命名为id_rsa.pub.slave
scp id_rsa.pub root@192.21.0.171:/home/uxdb/.ssh/id_rsa.pub.slave

2、重启ssh命令
service sshd restart

3、查看文件大小命令
ls -lh	#该命令以更接近文件大小的单位显示文件的大小。在Linux中显示文件大小时，通常的做法是使用“ls -I”，这是文件的大小

du -h –max-depth=1 *			//查找各个文件的大小
du -sh							//显示当前目录总大小

4、
linux上windows文件结尾符转换
sed -e 's/.$//' results/privileges.out > 1.out

5、vi显示行尾符
set invlist

6、makefile打印

打印top_builddir变量：
$(warning $(top_builddir))
打印字符串：
$(warning "------------------------------------------------------")

7、查看系统版本
cat /proc/version

8、查看MD5
md5sum uxsinodb-2.1-1.nfs.x86_64.rpm

9、查看cpu执行占有率

执行nmon命令后，
输入D查看

10、
systemctl status numad

11、sed命令
1）替换某个文件某个字符串
sudo sed -i "s/被替换字串/替换字串/g" + 文件名
eg：含有特殊字符的需要转义，例如$
sudo sed -i "s/\$13/\'1\'/g" + mean_time_g1ms_10ms.text

12、查看实时网速
sar -n DEV 2 100  # 查看网卡流量，每秒输出一次，输出100次。

13、

gdb调试：

1）、查看指针内存地址值
第一个x：查看
b：以单字节查看：b表示单字节，h表示双字节，w表示四字节，g表示八字节
20：表示显示20个字节
eg：
x/20b + 变量		//默认按10进制显示，参数使用d

2）、

set args -n -d > uxpool.log 2>&1
屏蔽信号处理，例如屏蔽SIGUSR1信号，让程序不中断
handle SIGUSR1 nostop
b trigger_failover_command

3）
gdb查看汇编（产生core时，在gdb命令行输入）：
layout asm

4）gdb调试打印内存上下文
gdb调试进程，sql执行完成后，
在gdb窗口执行以下命令打印：
print MemoryContextStats(TopMemoryContext)
相关链接：
https://www.modb.pro/db/486292

5）查看sql详细日志：
打开guc参数
debug_print_parse


14、系统命令
centoes系统：
查看已安装包：
yum list|grep gssapi

ubuntu系统：
查看已安装包：
dpkg --list|grep gssapi
查看可安装包：
apt list|grep uuid
卸载安装包：
sudo apt remove libxslt1.1

15、配置动态库加载
方法一：
以下文件目录创建conf文件，文件配置加载库路径（需要加载的库路径），然后使用ldconfig /etc/ld.so.conf.d/加载该路径；
/etc/ld.so.conf.d/
方法二：使用patchelf --set-rpath			//动态库在/home/uxdb/uxdbinstall/dbsql/lib/gmssl/lib路径下：
patchelf --set-rpath /home/uxdb/uxdbinstall/dbsql/lib/gmssl/lib /home/uxdb/uxdbinstall/dbsql/lib/gmssl/bin/gmssl
方法三：打开/etc/ld.so.conf，将需要加载的库路径加入该文件，然后执行sudo ldconfig即可



16、查看磁盘io读写速度

iostat -x 3

17、绑定cpu使用命令numactl：

使用numactl -C 0-63启动集群：
numactl -C 0-63 ./ux_ctl -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=1 -p 5432" start
numactl -C 0-63 ./ux_ctl -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=2 -p 5433" start

taskset -c 0-63 ./ux_ctl -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=1 -p 5432" start

18、查看进程占用内存情况
smem -k | grep -e [P]ID -e 6197			//6197为进程id

2020-11-16

hao_xingang@uxsino.com

2020-07-08

uxdb使用zpack打包及视图化安装
1、启动uxdb：systemctl start uxdb

查看uxdb状态：systemctl status uxdb
登录uxdb：	uxsql -d uxdb

关闭服务：systemctl stop uxdb

2、log文件：在/home/test/uxdbinstall/dbsql/data/dbhome_1/ux_log/startup.log

3、所属用户：chown -R test encryptLicense
修改用户组：chgrp -R test encryptLicense


2020-07-09
同步代码到服务器：
https://blog.csdn.net/qq_39187019/article/details/90045064

2020-07-13

1、
CREATE DATABASE name
    [ [ WITH ] [ OWNER [=] user_name ]
           [ TEMPLATE [=] template ]
           [ ENCODING [=] encoding ]
           [ LC_COLLATE [=] lc_collate ]
           [ LC_CTYPE [=] lc_ctype ]
           [ TABLESPACE [=] tablespace_name ]
           [ ALLOW_CONNECTIONS [=] allowconn ]
           [ CONNECTION LIMIT [=] connlimit ]
           [ IS_TEMPLATE [=] istemplate ] ]

移除数据库：DROP DATABASE

2、CREATE DOMAIN

CREATE DOMAIN — 定义一个新的域

3、CREATE EXTENSION

CREATE EXTENSION — 安装一个扩展


2020-07-20

warning protobuf-2.5.0 or gtest-1.7.0 can not fuound,Please make sure it exists in the /Users/xyz/thirdyparty directory,and set the the environment variable THIRDPARTY_ROOT to the thirdyparty base directory before executing 'make',  e.g., export THIRDPARTY_ROOT=/Users/xyz/thirdyparty



2020-07-29

1、如何将linux代码编译成win32
sudo apt-get install mingw32
i586-mingw32msvc-cc main.c -o main.exe

2、linux下编译运行java代码
类名和文件名保持一致

javac -cp . HelloWorld.java
java -cp . HelloWorld
或者
javac *.java
java test



2020-08-03
工具配置：
1、vscode
排除文件：
*.po,*.out,*sql,*.html,*.md,*sgml,README,*.source

安装idea：
1、idea解码
https://blog.csdn.net/qq_43604667/article/details/98321517?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param

centos安装idea软件
http://www.mamicode.com/info-detail-2294728.html

2020-08-10

远端分支：
origin/dev/ver2.1.1.3_dev
ver2.1.1.3_dev

2020-08-19

1、select语句用于从数据库中选取数据
eg：select name,country FROM Websites;

2、CAST($1 AS text)		//将$1转化为文本

3、COUNT(*)：统计行数


./build.sh --release=enterprise  --version=2.1.1.2  --license=commercial
./build.sh --release=security  --version=2.1.0.3  --license=internal



support/#86836_merge
support/#86836_wbc

2020-08-25
*************rebrand***********
转换pg与uxsql
进入目录：
/home/uxdb/uxdb-ng/scripts/bash/rebrand
执行./rebrand.sh

2020-08-31

编译izpack源码

izpack编译：
/home/uxdb/uxdb-ng/install/izpack/izpack
mvn clean install
izpack使用：
/home/uxdb/uxdb-ng/install/izpack/izpack/izpack-dist/target
java -jar izpack-dist-5.1.4-SNAPSHOT.jar





git config --global user.name "wang_qi"
git config --global user.email "wang_qi@uxsino.com"

 wang_qi@uxsino.com
密码：Wang0519

2020-09-02
build：
编译debug版本
./build.sh -d -l internal


pgsql命令：

系统表：
数据字典

控制端sql命令：
create view v1 as select name from t1;		//创建视图

create schema repmgr；						//创建模式

insert into t1 select generate_series(1,10000),'a';			//循环插入10000行数据

explain (analyze,buffers) + sql语句							//输出执行时间

explain (analyze,buffers) MERGE INTO t2 A USING (select id,name from t1 B) C ON (A.id=C.id)
WHEN MATCHED THEN
UPDATE SET A.YEAR=C.YEAR

创建超级用户和密码：
CREATE ROLE kkxgd superuser PASSWORD '123' login;
CREATE ROLE test superuser PASSWORD '123' login;

创建数据库kkxgd：
create database kkxgd;
create database test;

切换用户：
\c - kkxgd

登录
./uxsql -U kkxgd -d kkxgd

恢复数据：
./ux_dump -U test -d test < /home/uxdb/wangqi/test_dump.sql

pg信任登录：初始化集群不需要密码
将-W 改为-Atrust

查看表名：
通过表明查看文件
./oid2name -t + tablename


grant命令：

执行计划命令：
explain (analyze true,buffers true) select * from emp1 where empno=7369 ;

通过explain (analyze true,buffers true)可以查看，从磁盘中读取了多少个数据块；

查看系统函数（查看系统函数名中含HASH的函数）：
select proname from ux_proc where proname like '%HASH%'

循环插入数据：

create table t1(id int);
insert into t1(id) select generate_series(1,10000);

create table t2(id int,b text);
insert into t2 select generate_series(1,10000), repeat(md5(random()::text),10);

循环插入多个字段数据：
insert into t2 select i,i||'aaa' from generate_series(1,100) i;

去重命令：
distinct

查看表磁盘文件：
select ux_relation_filepath('t1');

查找自上次使用 重置统计信息以来从未使用的索引，重置统计信息函数ux_stat_reset()
SELECT s.schemaname,
       s.relname AS tablename,
       s.indexrelname AS indexname,
       ux_relation_size(s.indexrelid) AS index_size
FROM ux_catalog.ux_stat_user_indexes s
   JOIN ux_catalog.ux_index i ON s.indexrelid = i.indexrelid
WHERE s.idx_scan = 0      -- has never been scanned
  AND 0 <>ALL (i.indkey)  -- no index column is an expression
  AND NOT i.indisunique   -- is not a UNIQUE index
  AND NOT EXISTS          -- does not enforce a constraint
         (SELECT 1 FROM ux_catalog.ux_constraint c
          WHERE c.conindid = s.indexrelid)
ORDER BY ux_relation_size(s.indexrelid) DESC;

查看numeric相关操作符
\dC numeric

查看所有数据库占用大小的语句：
select ux_database.datname, ux_database_size(ux_database.datname) AS size from ux_database;
select ux_database.datname, ux_size_pretty(ux_database_size(ux_database.datname)) AS size from ux_database; 这个可以带单位







pgsql网站：
pg源码：
https://www.postgresql.org/download/

pgsql文档：
https://www.postgresql.org/docs/13/index.html




2020-09-04
note：

/* [qiwang] Add begin */

/* [qiwang] Add end */

2020-09-09

/************系统表：*****************/
1、创建ux*.h文件
作用：定义数组，用于存放系统表数据

2、修改initdb.c
作用：给系统表数据赋值

3、在indexing.h添加索引
作用：加快查询

4、修改syscache.c
作用：添加到缓存，加快sql执行

/************隐藏列：*****************/
1、添加字段号，唯一识别隐藏列

2、修改heap.c
将隐藏列添加到数组SysAtt

3、ux_config.c
作用:设置隐藏列的值

4、heaptuple.c
作用：识别到隐藏列后，获取隐藏列的值

/************with time：*****************/



2020-09-14

转正流程：
陈明波 + 郝鑫刚 + 张文江 + 赵宗鹏 +






2020-09-10


案例一：

查看ux_config的代码结构
确定功能实现是在编译前获取宏值
linux：
宏定义在编译前通过configure编译
了解configure功能结构
通过AC_DEFINE_UNQUOTED宏可以定义该
windows：
通过msvc获取
这块通过脚本solution.pm将宏定义生成在ux_config.h.win32
编译后将ux_config.h.win32生成ux_config.h


案例二：
刚开始拿到这个问题后，首先通过java入口追踪代码，最后没追到，这块封装的比较深。
然后通过查看关键字，发现这块代码是通过xml实现的，然后查看这块的功能代码
确定该功能是自定义界面实现
确定修改方案：
首先需要确定语言选择框的机制，通过查看之前代码的汉化，系统会识别对应的字符串，中文：chn，英文：eng
确定汉化的几种方式：
目前我知道的有三种：
	系统内部实现、通过id判断、通过变量判断（变量这块又分为代码、标签两部分）
这块通过标签对变量进行判断


一共三种方式：
1、汉化通过判断系统语言进行显示






2020-09-21

1、虚拟机：












2020-09-25

Makefile：
1、指定头文件路径：
CFLAGS和CPPFLAGS


2020-10-14

安全版数据库：

src/bin/uxsql/startup.c				//修改数据库5分钟后断开链接
将145行SIGALRM==sig修改为0



2020-10-28

学习gdb
1、core dump

gdb ./uxdb core******

2、gdb教程
http://c.biancheng.net/gdb/

3、https://jingyan.baidu.com/article/215817f7e6a3b81eda142323.html
gdb跟踪子进程
set follow-fork-mode child
set follow-fork-mode parent

set detach-on-fork off
有的时候，我们想同时调试父进程和子进程，以上的方法就不能满足了。Linux提供了set detach-on-fork mode命令来供我们使用。其使用的mode可以是以下的一种：

on
只调试父进程或子进程的其中一个(根据follow-fork-mode来决定)，这是默认的模式。
off
父子进程都在gdb的控制之下，其中一个进程正常调试(根据follow-fork-mode来决定)
另一个进程会被设置为暂停状态。

set follow-exec-mode mode
我们使用set follow-exec-mode mode提供的模式来跟踪这个exec装载的程序。mode可以是以下的一种：
new 当发生exec的时候，如果这个选项是new，则新建一个inferior给执行起来的子进程，而父进程的inferior仍然保留，当前保留的inferior的程序状态是没有执行。

same 当发生exec的时候，如果这个选项是same(默认值)，因为父进程已经退出，所以自动在执行exec的inferior上控制子进程。




2020-10-29

1、添加注释

我们现在写代码时有两种注释，标记注释和真正有效的注释。下面1和2都是标记注释，第3个是真正注释。希望写注释的时候大家有意识想清楚注释的原则，而不是不管三七二十一，有代码就往上加标记注释。

1、为了和pg内核代码区分，并方便以后进行内核升级或者代码追踪，
当在内核代码中嵌入大段新增代码时，需要前后加begin/end的注释。
如果是小段代码或者一行两行代码，就开头写上“add by XXX for #单号” 就行

添加内容：
/* Begin add by wangqi for #94833 at 2020.12.29 */
/* End add by wangqi for #94833 at 2020.12.29 */


修改内容：
/* Begin modify by wangqi for #94833 at 2020.12.29 */
/* End modify by wangqi for #94833 at 2020.12.29 */

2、如果一个函数本身就是我们新增的，那么在这个函数中改正，也不需要再加begin end。
如果你有新增或者修改，只需要在关键的地方标注，这个代码是谁加的“add by XXX”，或者是谁改的 “modify by xxx”，任务单号是多少 “for #单号”等关键信息就可以了。

eg：
/* add by wangqi for #94833 at 2020.12.29 */
/* modify by wangqi for #94833 at 2020.12.29 */

3、除了上述的标记注释，对关键逻辑代码需要加说明注释，是真正的注释。大部分情况下该类注释都是需要有的。

/* Begin modify by wangqi for #94833 at 2020.12.29 */
/* End modify by wangqi for #94833 at 2020.12.29 */
/* only merge run this */

英文注释：
注释不能用//
注释要有空格
函数要有

文件头参考pg

添加内容：
/* Begin add by wangqi for #91139 at 2020.10.31 */
/* End add by wangqi for #91139 at 2020.10.31 */


修改内容：
/* Begin modify by wangqi for #91139 at 2020.10.31 */
/* End modify by wangqi for #91139 at 2020.10.31 */

/* modify by wangqi for #91139(merge into) at 2020.11.09 */

/* Begin modify by wangqi for #104112 at 2021.04.29 */
/* End modify by wangqi for #104112 at 2021.04.29 */

修改注意：
1、变量初始化
2、变量对齐
3、语句对齐


二、redmine

1、提交记录
Root Cause (Bug) or Purpose (RFE/Task):
应用端输入小写用户名无法连接；
Affected Area:
Solution:
由于客户端链接服务器前，会将用户名和密码做加密处理，导致传到后端md5值不一致，故在加密前做大写转换，但后端接收到的port结构体用户还是大写，这块需做分析
test:
Recommended Test Area:
Reviewed by:张文江
Approved by:
git checkin rev Number：f7ccf19a4d1b25e37188077cbd424472a8c703f8
target branch:security10_develop
Affected files：
modify:
uxdb-2.0/src/backend/libuxsql/auth.c
uxdb-2.0/src/interfaces/libuxsql/fe-auth.c

•Root Cause (Bug) or Purpose (RFE/Task):应用端输入小写用户名无法连接；
•Solution:
integer报错原因：由于客户端链接服务器前，会将用户名和密码做加密处理，导致传到后端md5值不一致，故在加密前做大写转换，但后端接收到的port结构体用户还是大写，这块需做分析
•Unit test:

•Reviewed by: 张文江
•svn checkin rev Number：f7ccf19a4d1b25e37188077cbd424472a8c703f8
•Affected files：
uxdb-2.0/src/backend/libuxsql/auth.c
uxdb-2.0/src/interfaces/libuxsql/fe-auth.c

2、redmine登记参考问题单177363 




2、查看linux内存大小
https://jingyan.baidu.com/article/e2284b2b13165da2e7118d46.html

du -sm *|sort -nr | head -n 10
du -sh gdb-8.1/


2020-11-02

1、测试pgsql是否存在内存泄漏
uxbench -i

uxbench -T 100			//测试100s pg是否存在


uxbench使用方法：
1、登录控制台，创建uxbench数据库：
create database uxbench;
2、在bin目录下，初始化数据
./uxbench  -i  -s  100

3、uxbench测试：
./uxbench -s 300 -T 300 -P 5 -c 32

tpcc：
主要修改两个文件：
dbfarm.pg		//客户端链接
props.pg		//tpcc配置文件

参数说明：
warehouses：		单位100M
loadWorkers：		一般为warehouses的1/10
terminals：			客户端数量
runMins：			tpcc执行时间

tpcc的使用方法：
1、加载数据
./runDatabaseBuild.sh props.pg

2、测试数据

runBenchmark.sh props.pg

2020-11-16

1、辅助进程在postmaster的监听循环中执行


2020-11-17

1、
查看checkpoint检查点
./ux_controldata -D 数据库


2020-11-18



2020-11-18

1、代码命名方式
功能单
feature/ver2.1.1.3_dev/#91139

缺陷单
bug/ver2.1.1.3_dev/#94056


2020-11-20
恢复uxdb超级用户权限：
sudo -S setcap cap_setuid+ep uxdb  恢复uxdb的权限

1、使用pg_resetxlog修复PostgreSQL控制文件的方法
https://developer.aliyun.com/article/59113

2、pg_controldata详解
https://blog.csdn.net/allway2/article/details/95440443
https://www.askmaclean.com/page/8?m=bbs&amp%3Ba


2020-11-27

https://www.cnblogs.com/sxmny/p/11224842.html

1、端口设置

1、开启防火墙
    systemctl start firewalld
防火墙状态：
systemctl status firewalld
关闭防火墙：
systemctl stop firewalld

2、开放指定端口
      firewall-cmd --zone=public --add-port=1935/tcp --permanent
 命令含义：
--zone #作用域
--add-port=1935/tcp  #添加端口，格式为：端口/通讯协议
--permanent  #永久生效，没有此参数重启后失效

3、重启防火墙
      firewall-cmd --reload

4、查看端口号
netstat -ntlp   //查看当前所有tcp端口·

netstat -ntulp |grep 5432   //查看所有1935端口使用情况·

关闭端口：
sudo lsof -i:5432
kill -9 PID


2020-12-02

c语言知识点

1、段错误
1）段错误是什么？
本质上是指指针错误（地址错误），之所以叫做段错误，是因为C语言中，内存结构是由不同的内存段组成的，所以称为段错误

2）一般导致段错误原因

数组越界、引用空指针

2、函数
strtok（s，","）		//分隔字符串，每次取出一个分割字符串，并指向下一个字符首位


2020-12-4

uxdb知识记录：
1、
uxdb控制台：\i sql文件			//导入sql命令

创建用户hrcm， create role hrcm;
给用户超级权限：alter

2、
benchmark路径：
/home/uxdb/uxdb-ng/test/tools/uxdb_tpcc-tool/benchmarksql-5.0

3、repmgr功能

repmgr配置主备同步异步模式：
synchronous_standby_names ='2(node1,node2)'
https://www.cnblogs.com/tiany1224/p/16199370.html

在备节点克隆数据库
repmgr -h 192.71.0.138 -U uxdb -d uxdb -f /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf standby clone

守护进程：
1、启动守护进程：
repmgr daemon start -f /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf
2、查看守护进程：
repmgr -f /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf daemon status

3、杀掉守护进程
kill `cat /tmp/repmgrd.pid`

4、循环插入多条数据
create table tbl_tests(id int, info text, c_time timestamp) tablespace myspace;
insert into tbl_tests select generate_series(1,10000000),md5(random()::text),clock_timestamp();

5、汉化
进入po同级目录执行：
make update-po

然后修改zh_CN.po.new
vim po/zh_CN.po.new

重新注册主备节点

1、
注册主节点
repmgr -f /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf primary register --force
注销主节点
repmgr primary unregister -f  /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf --node-id=2

2、
注册备节点
repmgr -f  /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf standby register --force
注销备节点
repmgr standby unregister -f  /home/uxdb/uxdbinstall/dbsql/bin/repmgr.conf --node-id=3



4、配置
local   replication   uxdb                             trust
host    replication   uxdb      127.0.0.1/32            trust
host    replication   uxdb      192.71.0.0/24           trust
local   uxdb        uxdb                              trust
host    uxdb        uxdb      127.0.0.1/32             trust
host    uxdb        uxdb      192.71.0.0/24            trust


5、
gram.y调试：

修改gram.Y文件
diff --git a/src/backend/parser/gram.y b/src/backend/parser/gram.y
index d1ce2ab042..43d5d5413b 100644
--- a/src/backend/parser/gram.y
+++ b/src/backend/parser/gram.y
@@ -65,6 +65,7 @@
#include "utils/numeric.h"
#include "utils/xml.h"

+int yydebug=1;

/* Precedence: lowest to highest */
+%debug

安全版记录：
1、控制台自动关闭时间控制：
login_idle_timeout




2020-12-6

数据库知识库：

学习内容：
1、大对象clob
2、国密算法，用例只列出sm4
3、增量备份
4、增量恢复
5、表删除后恢复，闪回功能
6、列注释
7、分区表（hash，range分区）
8、merge into
9、+连接符
10、CONNECT BY
11、ROW_NUMBER() OVER
12、UNION/UNION ALL/INTERSECT/MINUS
13、INTERSECT
14、NOT EXISTS/EXISTS/NOT IN/IN
15、ROWID
16、包和包体 PACKAGE PACKAGE BODY
17、Bulk collect
18、VPD技术 Oracle Virtual Private Database
19、列式存储表 用例好像不太一样
20、人资域 数据来源为 oracle11.2.0.1 expdp导出dmp文件
21、oracle 显式游标，隐式游标支持
22、资产域 数据来源为 oracle11204 expdp导出dmp文件 Oracle 11g expdp导出dmp文件
23、rownum
24、集群高可用

一、触发器

1、定义
相当于一个回调函数，在指定的事务发生时，自动触发函数功能。

2、属性
 FOR EACH ROW ：如果选中，每一行修改都会触发一次
 FOR EACH STATEMENT：如果选中，不管修改多少行，每个语句只触发一次

3、用法

删除触发器
drop trigger ${trigger_name} on ${table_of_trigger_dependent};

trigger_name：触发器名字
table_of_trigger_dependent：触发器对应的表名


实例：

insert:
drop trigger example_trigger on student;
drop table student,score,AUDIT;
drop function auditlogfunc;


CREATE TABLE student (
  id   int primary key,
  name varchar(50)
);

CREATE TABLE score (
  studentId  int,
   math     int
);

CREATE TABLE AUDIT(
   EMP_ID INT NOT NULL,
   ENTRY_DATE TEXT NOT NULL
);

INSERT INTO student VALUES(1,'April');
INSERT INTO student VALUES(2,'Harris');

INSERT INTO score VALUES(1, 98);
INSERT INTO score VALUES(2,77);
INSERT INTO score VALUES(3,87);

CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$
   BEGIN
      INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp);
      RETURN NEW;
   END;
$example_table$ LANGUAGE pluxsql;

CREATE TRIGGER example_trigger BEFORE INSERT ON student FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();

MERGE INTO student A USING (select B.studentId,B.math from score B) C ON(A.id=C.studentId)
WHEN NOT MATCHED THEN
INSERT (id, name) VALUES(C.id,C.math);

删除触发器：
drop trigger example_trigger on student;


update:
drop trigger example_trigger on student;
drop table student,score,AUDIT;
drop function auditlogfunc;


CREATE TABLE student (
  id   int primary key,
  name varchar(50)
);

CREATE TABLE score (
  studentId  int,
   math     int
);

CREATE TABLE AUDIT(
   EMP_ID INT NOT NULL,
   ENTRY_DATE TEXT NOT NULL
);

INSERT INTO student VALUES(1,'April');
INSERT INTO student VALUES(2,'Harris');

INSERT INTO score VALUES(1, 98);
INSERT INTO score VALUES(2,77);
INSERT INTO score VALUES(3,87);

CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$
   BEGIN
      INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, current_timestamp);
      RETURN NEW;
   END;
$example_table$ LANGUAGE pluxsql;

CREATE TRIGGER example_trigger BEFORE INSERT ON student FOR EACH ROW EXECUTE PROCEDURE auditlogfunc();

MERGE INTO student A USING (select B.studentId,B.math from score B) C ON(A.id=C.studentId)
WHEN NOT MATCHED THEN
INSERT (id, name) VALUES(C.id,C.math);

2020-12-09

uxdb整理总结：
uxdb资料：

1、查看postgre各个文件关联
https://docs.huihoo.com/doxygen/postgresql/catalog_8c.html

2、gdb打印语法树
call elog_node_display(15,"111",parsetree,1)


uxdb命令：
查看数据库大小：
SELECT ux_size_pretty( ux_database_size('uxdb') );
查看单张表：
SELECT ux_size_pretty( ux_total_relation_size('uxbench_accounts') );

查看表oid：
select oid from ux_class where relname = 'test_name';

查看oid对应的ux_attribute属性
select * from ux_attribute where attrelid = 16391;


uxdb按端口启动集群：
./ux_ctl -o "-p 5433" -D test2 start

安全版功能：

1、身份鉴别：
用户标识：
在服务器端，存储每个用户的身份标识（用户名）、用户口令（具有唯一性，标识该用户）、有效期等

用户鉴别：
鉴别用户的真实性、连接超时处理


2、密码到期
用uxop用户登录数据库
./uxsql -U uxop -d uxdb
修改密码：
alter role uxdb valid until '2022-01-21 16:37:46.085415+08';


3、解密sql语句
export SKIP_WRAPPER=1

4、备份sql、tar数据
-Fp参数以sql输出
./ux_dump -U uxop -d uxdb -Fp -t test_column > hidecolumnsFt.sql
-Fp参数以tar格式输出
./ux_dump -U uxop -d uxdb -Ft -t test_column > hidecolumnsFt.tar

5、打包命令：
cd /home/uxdb/uxdb-ng/install/linux
./release.sh --release=security --version=2.1.0.4 --min_version=03 --license=commercial


6、切换inuser用户：

加载ux_authority插件

7、设置加密信息

select inuser.IU_encrypted_column('uxdb','uxdb','student','sname','keyname1','AES-128','ECB','none',0,'iv1','69,156,226,95,210,79,68,47,193,46,150,98,169,220,63,151','o_data_type1','n_data_type1',1,'2021/02/27'::timestamp,'2021/10/12'::timestamp,1);

安全版数据迁移：
select data_migration('uxdb', 'student', 'sname', 'bytea', 1, 100);

8、grant功能

1、用u2用户访问u1表数据
create user u1;
create user u2;
set session authorization u1;
create table t1(id int);
\c - uxdb
grant u1 to u2;
set session authorization u2;
select * from u1.t1;

9、解锁用户
set_deblocking_user（'用户名'）；

2020-01-14

linux 中文显示修改
1、/etc/profile
添加export LANG=zh_CN.UTF-8
2、/etc/locale.conf
添加LANG=zh_CN.UTF-8

3、/sbin/service
在env -i 后面加上 LANG="$LANG"
LANG="$LANG"

4、显示系统语言
locale



2020-1-21
loadrunner:
1、
loadrunner脚本配置（select与insert）：

Action()
{
	web_url("index.jsp",
		"URL=http://192.71.0.139:8080/HttpTest/index.jsp",
		"Resource=0",
		"RecContentType=text/html",
		"Referer=",
		"Snapshot=t1.inf",
		"Mode=HTML",
		LAST);

	web_add_cookie("JSESSIONID=52CB9C7CE365A5D520FAE1E7A55FED04; DOMAIN=192.71.0.139");

	lr_start_transaction("l1");

	web_reg_find("SaveCount=para_count","Search=Body",
		"Text=successful",
		LAST);
	web_link("执行查询",
		"Text=执行查询",
		"Snapshot=t2.inf",
		LAST);

	web_url("index.jsp_2",
		"URL=http://192.71.0.139:8080/HttpTest/index.jsp",
		"Resource=0",
		"RecContentType=text/html",
		"Referer=",
		"Snapshot=t3.inf",
		"Mode=HTML",
		LAST);

	web_reg_find("SaveCount=para_counts","Search=Body",
		"Text=successful",
		LAST);
	web_link("执行插入",
		"Text=执行插入",
		"Snapshot=t4.inf",
		LAST);
   web_url("index.jsp_2",
		"URL=http://192.71.0.139:8080/HttpTest/index.jsp",
		"Resource=0",
		"RecContentType=text/html",
		"Referer=",
		"Snapshot=t5.inf",
		"Mode=HTML",
		LAST);

if((atoi(lr_eval_string("{para_count}"))>=1)||(atoi(lr_eval_string("{para_counts}"))>=1))
{lr_end_transaction("l1", LR_PASS);}
else
{lr_end_transaction("l1", LR_FAIL);}

return 0;
}

2、loadrunner使用：
https://blog.csdn.net/aijaijgnaw/article/details/122882690

2021-02-05

1、参加企业文化、公司制度、办公系统、财务等新员工培训，并做新员工培训笔记
2、
功能单：
83571、
merge into

问题单：
84308、84307、85967、88022

90557、86469、94056、88558、88734、88737、94937

南网项目支持

93980、94680、94833、98534、97571、98960、97708、95981、

#83571：ux_config增加支持查询打包信息
#84308：root用户图形化界面中文安装2.1.1.2，创建实例界面是英文，没有汉化
#84307：root用户图形化界面中文安装2.1.1.2，创建用户界面是英文，没有汉化
#85967：不能创建第三方插件chkpass
#88022：AK项目支持
#90557：创建分区表后，分区表级别存在问题，hash与主表为同一级别
#86469：一主两备（一同步一异步）流复制，主库所在的服务器（227）在遇到断电并恢复后，主库无法启动，部分wal日志遭到损坏
#94056：merge into、同义词、大小写敏感 代码告警消除
#88558：使用ux_archivecleanup命令清除wal日志，集群实例无法正常启动
#88734：使用ux_diagnose进行数据库恢复，能够正常启动实例，但数据库表丢失，建立新表，之前丢失的表恢复
#88737：使用ux_diagnose进行重置wal日志，完成后实例无法正常启动
#94937：merge into操作分区表 服务器意外关闭
#93980：语法开关前后创建视图同义词失败
#94680：在ignore-case集群下，使用merge into语句与表中字段大小写不一致，报字段不存在错误
#94833：merge into触发器相关函数修改未调用
#98534：tpcc稳定性测试：warehouse=10000仓时，初始化数据报错
#97571：postgres_adaptor 插件更新
#98960：XC测试-验证在线升级和节点故障
#97708：使用简体中文安装完成程序，进行集群实例初始化，提示的语言不统一
#95981：南网项目支持
#
#
#
#
#
#
#
izpack汉化


年度工作总结：

1、izpack安装卸载问题单修复
1、2.1.1.3版本功能开发与修改
2、2.1.1.3版本迭代一、迭代二开发及问题单修复
3、AK、XC、南网测试支持
4、

通过添加merge into语句，对sql处理流程有一定的分析，学习查看postgresql数据库内核分析、、高可用功能学习及了解、
通过处理wal日志问题单，清楚了wal日志、checkout机制、学习了解安全版功能。

总共耗时：
787

学习：104h
对外支持：56h
解决问题单：627h

需研究sql文件：
rules


2021-03-03

84858问题单测试步骤：
set ora_grammar = on;
create table test(id int);
insert into test select generate_series(1,100);
select * from (select id from test where id < 3);
select * from (select id from (select  * from test where id < 3));

问题单处理：

uxdb-2.0:
c=1546270693
1871169857

uxdb-2.1:
c=2326301040
1356382148

hash值处理：
transformAExprOp
	-》make_op
		-》oper
			-》find_oper_cache_entry
				-》hash_search
					-》hash_any					hashfunc.c:307
					-》hash_search_with_hash_value


key值命名空间oid列表获取：
oper
	-》make_oper_cache_key
		-》fetch_search_path_array	namespace.c:4210
			-》recomputeNamespacePath

ka:
uxdb2.0:
{oprname = "=", '\000' <repeats 62 times>, left_arg = 20, right_arg = 16907, search_path = {11, 16957, 2200, 0 <repeats 13 times>}}
uxdb2.1:
oprname = "=", '\000' <repeats 62 times>, left_arg = 20, right_arg = 16384, search_path = {11, 2200, 0 <repeats 14 times>}

问题一：右操作符类型问题

代码流程：
transformAExprOp										parse_expr.c:857
	-》transformExprRecurse											:944
		->transformTypeCast											:207
			->typenameTypeIdAndMod									:2677		//获取oid
				-》typenameType							parse_type.c:298
					->LookupTypeName					parse_type.c:251
			->coerce_to_target_type									:2737
				->coerce_type								parse_coerce.c:102
					-》makeRelabelType									  :456


2021-03-12

大小写敏感：

分为存储和匹配两个过程
pg自身：					按小写存储，匹配时将大小写转化为小写匹配，匹配大小写不敏感；（目的：显示按小写显示）

大小写不敏感改造：			按大写存储，匹配时按大小写不敏感匹配（目的：显示按大写显示）

默认大写：


原理：
1、

1、原生场景：表名、字段名默认转小写，且敏感；字段值敏感。
2、--ignore-case场景：表名、字段名默认不变直接存储，不敏感；字段值不敏感。
3、计划可实现：表名、字段名默认不变直接存储，且敏感；字段值敏感。
4、计划可实现：表名、字段名默认不变直接存储，不敏感；字段值敏感

大小写不敏感：按原文存储，匹配按大小写不敏感匹配

1、将匹配也改为大小写敏感处理（存在以下问题）

2、不修改转换逻辑，只需要在结果集将输入sql的列名做下替换


敏感：调用pg本身函数
不敏感：使用自身封装函数

07887d377bb9ebbb864e6750e0049279fe24ad89

0653fa8c38951ecd9e14a15f7b8bc3a3253e1b8a

#define UX_STRCASE_CMP(s1, s2)  \
		(ignore_case ? ux_strcasecmp(s1, s2) : strcmp(s1, s2))

#define UX_STRNCASE_CMP(s1, s2, len)  \
		(ignore_case ? ux_strncasecmp(s1, s2, len) : strncmp(s1, s2, len))

#define UX_MEMCASE_CMP(s1, s2, len)  \
		(ignore_case ? ux_strncasecmp(s1, s2, len) : memcmp(s1, s2, len))


不敏感测试用例：

/* Case-sensitive table name */
create table oldtable(id int);
create table oLdtaBle(id int);
create table OLDTABLE(id int);

/* Case-sensitive field names */
create table fieldname(num int, nUm int, NUM int);
insert into fieldname values(1, 2, 3);
select num from fieldname;
select nUm from fieldname;
select NUM from fieldname;

/* Case-sensitive table names and field names */
create table fieldtable(ID int, id int);
create table FieldTable(ID int, id int);
create table FIELDTABLE(ID int, id int);

/* Case sensitive field value */
create table t2(name text);
insert into t2 values('zhangsan'),('Zhangsan'),('ZHANGSAN');
select * from t2 where name = 'zhangsan';
select * from t2 where name = 'Zhangsan';
select * from t2 where name = 'ZHANGSAN';

/* Case sensitive name keyword verification */
create table t3(name text,Name text);
\d


make check不敏感：

7154e5971fdd603995e70e3ecac67052d04fadf6

ade2318dfa39f4feb3b1cb5cbf32ede93f392313

uxsql报错：

uxdb-2.1/src/backend/catalog/information_schema.sql
uxdb-2.1/src/backend/catalog/system_views.sql
uxdb-2.1/src/backend/snowball/snowball_func.sql.in
uxdb-2.1/src/bin/initdb/initdb.c


参数：
--ignore-case
--no-downcase






language c：

CREATE FUNCTION ux_catalog.ux_file_write(text, text, bool)
RETURNS bigint
AS 'MODULE_PATHNAME', 'ux_file_write'
LANGUAGE C VOLATILE STRICT;

RECORD：

CREATE FUNCTION dbms_pipe.__list_pipes()
RETURNS SETOF RECORD
AS 'MODULE_PATHNAME','dbms_pipe_list_pipes'
LANGUAGE c VOLATILE STRICT;

大小写实现功能：

字段名不区分大小写：
但字段名显示区分大小写

方案二：

1、按原文存储，
比较用大小写不敏感
语法层给字段名加后缀
2、在字段名处加后缀，strcmp处如果有后缀，不做转换
否则转小写处理
3、在结果集将后缀去掉即可

/home/uxdb/uxdb-ng/uxdb-2.1/src/port/uxstrcasecmp.c
strcmp：

unsigned int ux_num = strlen(s1);
		unsigned char dest[4] = {""};
		strncpy(dest, s1+ux_num-3, 3);

		if(strcmp(dest,"_ux") == 0) {
			strcmp(s1, s2);
			return 0;
		}

字符串显示：

unsigned int ux_num = strlen(att->attname);
		unsigned char dest[4] = {""};
		strncpy(dest, att->attname+ux_num-3, 3);

		if(strcmp(dest,"_ux") == 0) {
			att->attname + ux_num -3 = '\0';
		}

2021-03-16
pg兼容oracle：

1、Postgres兼容Oracle语法研究-extension
https://www.jianshu.com/p/cdb84a9f49a1



新增知识点：

1、target_list分析：
https://www.cnblogs.com/gaojian/tag/gram.y/









邮件1：
猜想1：可能输入sql时，将字段名加了双引号
猜想2：结果集中的值与输入sql的值不一致导致

邮件2（王若楠）：



2021-03-19

初始化数据库：
./initdb -W -D db1 -I -M

./ux_ctl -M -I -o "-I" -D /home/uxdb/uxdbinstall/dbsql/bin/db1 start


create user test with password '1qaz!QAZ'；

rpm安装：
rpm -ivh --force uxsinodb-2.3-1.nfs.x86_64.rpm

打包注意点：
1、如果有uuid
拷贝/lib64/libossp-uuid.so.16 到安装目录下；
一、rpm打包：
编译：
./build.sh --release=standard --license=internal --version=2.1.1.4 --nouxfs --enable-root
打包：
执行/install/autopkg/rpmpkg/release.sh
~/rpmbuild/RPMS/aarch64/下生成rpm包。

二、打tar包：--useizpack=no: no：打tar包，yes打run包，默认run包

注意：
编译前需要确认以下密码是否正确：
uxdb-2.1/src/Makefile.global.in			//注释掉代码：
echo 123456 | sudo -S setcap cap_setuid+ep '/home/uxdb/uxdbinstall/dbsql/bin/uxdb'

编译：
./build.sh --release=standard --license=commercial --version=2.1.1.4 --nouxfs/

打包

1）将uuid动态库拷贝到安装路径下；
2）./release.sh --release=standard --version=2.1.1.4 --license=commercial --nouxfs --useizpack=no

2114p编译：
./build.sh --release=standard --version=2.1.1.4 --license=commercial --extension-adaptor=yes --nouxfs --extended_parameters

pljava编译报错：
1)修改uxdb-2.1/contrib/pljava/build.sh：
#mvn -Dpljava.libjvmdefault=/usr/local/java/jre/lib/amd64/server/libjvm.so                                                                                         \
mvn -Dpljava.libjvmdefault=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.342.b07-0.p01.ky10.aarch64/jre/lib/aarch64/server/libjvm.so    \
    -Duxsql.uxconfig=${UXDB_INSTALL}/dbsql/bin/ux_config                                           \
    -Dnar.aolProperties=./pljava-so/aol.aarch64-gcc.properties                                     \
    -Pwnosign                                                                                                          \
    -Dnar.cores=1                                                                                                      \
    clean install -X
2)uxdb-2.1/contrib/pljava/pljava-so
在以上路径添加文件aol.aarch64-gcc.properties		//文件路径D:\mywork\20220901_137770

uos系统编译，以下参数有问题
--with-pam --with-gssapi  --with-systemd



jdbc编译打包：
编译打包脚本：
uxdb-drivers/uxdb-jdbc-42.2.12/uxdbjdbc/build.sh
jar包生成路径：
uxdb-drivers/uxdb-jdbc-42.2.12/uxdbjdbc/target/uxdbjdbc-42.2.12.jar
将jar包copy到路径：
uxdbinstall/driver/jdbc/jar/

商密分支：

调查问题的分支 support/support_BM3p

最新分支：
support/#99334_BM4p


bug/support/#99334_BM4p/#103474


commit：

266507b1825af22fb6a86e72fde837ff9fc2ed31
3653b86059c83aca07141a0a758bc828211665d0
bb3cee1c568b95e41a746a5cb341534c2f1a08d6
7b9797d3501fe6344f31b3d4f9043b56f15620b7
933295e65761ef5c17abd1eaafb72a551a669ad0

7088819bf126a0cd43ebd35745036e638e0a8edd

0001-99335-json.patch
0001-modify-define-LOG_NUMBER.patch
0001-devid-created-extensions.patch
0001-.patch
0001-99335.patch
0001-101986.patch


生成包路径：
/home/uxdb/rpmbuild/RPMS/x86_64

打包：
银河麒麟V10+aarch64、中科方德4.0+海光x64、银河麒麟V10+龙芯 mips

北京服务器：
10.1.106.61   uxdb/Uxsino@123       银河麒麟V10+aarch64
10.1.106.233  uxdb/123123           中科方德4.0+海光x64

10.1.106.61   uxdb/Uxsino@123       银河麒麟V10+aarch64(鲲鹏与飞腾)

10.1.106.195 root/Uxisno@123		中标麒麟

10.1.106.11   ARM  中科方德     uxdb UXGRfHc*&bX4KC2022    port:46722
10.1.106.61   ARM  银河麒麟V10  uxdb UXFU!qbsJ<gsM+2022    port：46722
10.1.106.98   ARM  银河麒麟V10_海军  xj  1qaz!QAZ   port:46722
10.1.106.67   ARM 中标麒麟v7      uxdb   uxdb   UXQt>Eb_FF9MK22022   port:46722
10.1.106.110  root  UXg9uu$f+Yj7bE2022     uxdb   UXg9uu$f+Yj7bE2022    端口号  46722
龙芯 mips：
10.1.106.51   root/UX3wbl9plq+uA=2022 uxdb/UXZX5FU7/egMs=2022   端口37622
uos arm的机器：
10.1.106.50   ARM  UOS         uxdb  UX<rbfXZR*tkVf2022  port：46722			（arrch64）

10.1.106.252  ARM  银河麒麟V10   uxdb/Uxsino@2021 port:22		（arrch64）

10.1.108.110  kylin10/x86_64      root UXg9uu$f+Yj7bE2022 uxdb UXg9uu$f+Yj7bE2022 port:46722
10.1.108.128  kylin10/x86_64      root UX15Bdtwx/AOk=2022 uxdb UXgWjYKJHl+ig=2022 port:46722


dev/ver2.1.1.5A_dev修改文件：
        修改：     install/linux/Install_SE.XML
        修改：     install/linux/install.sh
        修改：     install/linux/release.sh
        修改：     uxdb-2.1/build.sh
        修改：     uxdb-2.1/contrib/repmgr/config.h.in
        修改：     uxdb-2.1/contrib/uxgmssl/build_gmssl.sh
        修改：     uxdb-2.1/contrib/uxmpp/src/include/uxmpp_config.h.in

中科方德：
10.1.108.12   nfs4.0/x86_64      uxdb/Uxsino@123 port:46722


10.1.108.50
root/UXnJcEJGltZ+C+Mo2O6fAlz0HTdso=2022
uxdb/UXt85HBkal7jREDG2H4gq/EARmHAg=2022
ssh端口46722



银河麒麟V10+龙芯mips  Gmssl编译方式：
./Configure linux64-mips64




修改uxdb用户报错：
char *cmd = "whoami";
        FILE* pipe = popen(cmd, "r");
        char ebuf[64] = {0};
        fgets(ebuf, 64, pipe);
        pclose(pipe);
        ebuf[strlen(ebuf)-1]='\0';
values[2] = ebuf;


删除dbsql：

UxdbAgent/UxdbAgent/UxdbAgent/debug/bin/Agent_initdb.sh
UxdbAgent/UxdbAgent/UxdbAgent/detection/src/detection.c
UxdbAgent/UxdbAgent/UxdbAgent/service/src/StartOrStopDatabase.c


保密四期研发进度报告：
1、以root用户启动数据库 （ 已修复）
2、备份和恢复权限中没有起作用  （ 已修复）
3、低限告警中插入语句非常缓慢   （未复现）
4、没有默认打开错误登录次数提示  （已修复）
5、审计进程启动失败  （ 未复现）
6、对于密码复杂度校验问题 （已修复）
6、ux_rman 32k   数据目录8k （已修复）
7、用户密码有效时长问题  （已修复）
8、空闲登出时间只针对当前用户生效问题（会话级别设置只对当前会话级别生效，数据库级别设置对所有会话生效）
9、uxsql登录显示logon time不是当前时间 （已修复）
10、后台任务(例如存储过程)运行中，但前台无操作超时后，也会被强制登出（已修复）

昨日进展：
1、用户密码有效时长问题  （已修复）
2、后台任务(例如存储过程)运行中，但前台无操作超时后，也会被强制登出（已修复）
3、带-I-M参数初始化集群后，给数据库中注入100warehouses的数据时，会持续卡在注入数据页面，cpu使用率在80%左右，登录数据库会卡死。（目前正在分析调查）

用户密码有效时长问题
后台任务(例如存储过程)运行中，但前台无操作超时后，也会被强制登出(
目前需分析定时器之前)


connection_timeout作用：
login_idle_timeout 30s
connection_timeout 60s

当操作时间小于30s时，30s断开
当操作时间大于30s时，60s断开
当idle空闲时间大于连接时间，超过连接时间断开


该问题原因：

uxsql在trust时，默认不记录登陆时间，


2021-03-25

打包顺序：

修改版本号为2.1
db:
1、build.sh 块大小为8k
2、编译db和uxdbagent、编译java工具（修改uxdbagent脚本）
3、将uxdbadmin和uxdbweb放到uxdbinstall目录下
4、替换rpmbuild目录下的build.sh
5、编译打包，分别在本地和opt验证

所有工具加可执行权限：
uxdbagent:
1、编译uxdbagent
2、修改shell脚本中root启动报错
uxdb-monitor：


/home/uxdb/uxdbinstall/dbsql/bin/uxdb --single -F -O -j -c search_path=ux_catalog -c exit_on_error=true   template1 >/dev/null
gdb：
set args -Atrust -D data1
b initialize_data_directory
r
b 3959
set follow-fork-mode child
handle SIGUSR1 nostop

报错函数：
setup_conversion

问题单调试：
set follow-fork-mode child
handle SIGUSR1 nostop
b InitUxdb


4590：effective_user = "uxdb";

1、#103871：uxsql登录显示logon time不是当前时间
2、#103820：密码首尾不能输入空格
3、#103666：保密四期要求root能启动数据库
4、#103680：解决龙芯和arm平台gmssl编译问题
5、#103959：审计进程中，log日志写死导致审计日志为空
6、#104108：initdb初始化时无法指定-U 参数
7、#104126：控制台前台无操作超时后，也会被强制登出
8、#104210：修改log_directory路径导致core dump



2021-03-30

ux_rman备份过程：
1、启动数据库
2、初始化备份目录
3、全量备份
4、校验全量备份
5、增量备份
6、校验增量备份


验证结果：
1、目标数据库第一次增量恢复后，目标数据库不能恢复源数据库之后的备份数据

#log_filename = 'uxsinodb-%Y-%m-%d_%H%M%S.log'

log_filename = 'uxsinodb-%a.log'


log_truncate_on_rotation		//等于on时，日志回卷
log_rotation_size				//单位M

测试语句：
create tablespace myspace location '/home/uxdb/tbs';
create table test (id1 int,id2 int) tablespace myspace;
alter tablespace myspace set (max_space_size='10M');
create or replace function insert_test() returns
boolean as
$body$
declare ii integer;
begin
ii:=1;
for ii in 1..1000000 loop
insert into test(id1, id2) values (116, ii);
end loop;
return true;
end;
$body$
language pluxsql;

select insert_test();

pg:
create tablespace myspace location '/home/uxdb/tbs';
create table test (id1 int,id2 int) tablespace myspace;
create or replace function insert_test() returns
boolean as
$body$
declare ii integer;
begin
ii:=1;
for ii in 1..1000000 loop
insert into test(id1, id2) values (116, ii);
end loop;
return true;
end;
$body$
language plpgsql;


问题单记录：

安全版：
99928

标准版：
99334

2021-04-07

cell->rolname
cell->last_login_timestamp
cell->failuretime

select rolname from ux_login_table;



国产平台configure阶段报错“cannot guess build type; you must specify one”问题解决：
方案一：
添加参数 --build=[cpu架构]-[系统类型]  例如：./configure --build=mips64el-linux
方案二：
更新最新版config.sub和config.guess，然后再次执行configure
wget -O ./config.sub "git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub;hb=HEAD"
wget -O ./config.guess "git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD"

2021-04-08

1、
select rolname from ux_login_table where rolname = 'options.username';

insert into ux_login_table values('','','');

update ux_login_table set last_login_timestamp = 'last_login_timestamp', failuretime = 'failuretime' where rolname = 'uxdb';

char se_buf[256] = "select rolname from ux_login_table where rolname = '";
strcat(se_buf, options.username);
strcat(se_buf, "';");

char in_buf[256] = "insert into ux_login_table values('";
strcat(in_buf, options.username);
strcat(in_buf, "','");
strcat(in_buf, last_login_timestamp);
strcat(in_buf, "','");
strcat(in_buf, failuretime);
strcat(in_buf, "');");

char up_buff[256] = "update ux_login_table set last_login_timestamp =";
strcat(up_buff, last_login_timestamp);
strcat(up_buff, " set failuretime = ");
strcat(up_buff, failuretime);
strcat(up_buff, " where rolname = ");
strcat(up_buff, options.username);
strcat(up_buff, ";");

char se_buf[256] = "select rolname from ux_login_table where rolname = '";
if(options.username != NULL)
{
	strcat(se_buf, options.username);
}
else
{
	strcat(se_buf, "uxdb");
}
strcat(se_buf, "';");

char in_buf[256] = "insert into ux_login_table values('";
if(options.username != NULL)
{
	strcat(in_buf, options.username);
}
else
{
	strcat(in_buf, "uxdb");
}
strcat(in_buf, "','");
if(NULL != last_login_timestamp)
{
	strcat(in_buf, last_login_timestamp);
}
else
{
	strcat(in_buf, "NULL");
}
strcat(in_buf, "','");
if(failuretime != NULL)
{
	strcat(in_buf, failuretime);
}
else
{
	strcat(in_buf, "NULL");
}
strcat(in_buf, "');");


char up_buff[256] = "update ux_login_table set last_login_timestamp = '";
if(NULL != last_login_timestamp)
{
	strcat(up_buff, last_login_timestamp);
}
else
{
	strcat(up_buff, "NULL");
}
strcat(up_buff, "', failuretime = '");
if(failuretime != NULL)
{
	strcat(up_buff, failuretime);
}
else
{
	strcat(up_buff, "NULL");
}
strcat(up_buff, "' where rolname = '");
if(options.username != NULL)
{
	strcat(up_buff, options.username);
}
else
{
	strcat(up_buff, "uxdb");
}
strcat(up_buff, "';");

/* 赋予uxop权限 */

\c - uxdb
grant uxdb to username;

grant all on ux_login_table to u1;
\c - username

char grant_buff[NUM] = "grant uxdb to ";
strcat(grant_buff, options.username);

login那个：
当前登录用户、 当前用户登录失败次数、失败时间戳、自上次成功登录以来密码认证失败的次数、当前登录ip、当前登录时间、上次登录ip、上次登录时间

保密四期研发支持进度：
web/admin：
1、备份恢复目前基本确认页面，剩余各功能的后端编写以及功能联调，预计下周一之前可以完成---宋丽娜；
2、横工具栏中帮助下两项：版权信息描述和关于uxdb中相关内容需要优化：完成代码未合入--宋丽娜；
3、uxdbAdmin查询页面，超时失效之后继续功能不起作用：进度60%(预计时间存在风险)，其他问题详见admin问题汇总表格，总计预估工时3天---林龙涛；

db:
1、昨天提出汉化问题（已解决）；
2、将login文件信息加入表中（预计今天完成）；
3、审计导致benchmark时数据库卡死（审计设计缺陷，处理难度大，暂不处理）；

项目风险：
1、admin备份恢复功能开发完成预计下周一之前完成；
2、admin相关需修改问题需要3天时间处理（预计时间存在风险）。



1、
syscache.c:516
/* {LoginTableRelationId,
		LoginTableIndexId,
		1,
		{
			Anum_ux_login_table_rolname,
			0,
			0,
			0
		},
		16
	},*/ /* wangqiadd */

indexing.h:393
//DECLARE_UNIQUE_INDEX(ux_login_table_index, 4003, on ux_login_table using btree(rolname name_ops));
//#define LoginTableIndexId    4003

catalog.c:287
relationId == LoginTableIndexId)

uxdb-2.0/src/include/utils/syscache.h:69
LOGINTABLE

版本信息：
11：
Linux localhost.localdomain 4.19.113-1.nfs.16.x86_64 #1 SMP Tue Jun 23 16:20:45 CST 2020 x86_64 x86_64 x86_64 GNU/Linux

Linux version 4.19.113-1.nfs.16.x86_64 (mockbuild@localhost.localdomain) (gcc version 8.3.1 20190507 (Red Hat 8.3.1-4) (GCC)) #1 SMP Tue Jun 23 16:20:45 CST 2020

144：
Linux localhost.localdomain 4.19.113-3.nfs.x86_64 #1 SMP Wed Jun 10 17:58:43 CST 2020 x86_64 x86_64 x86_64 GNU/Linux

Linux version 4.19.113-3.nfs.x86_64 (mockbuild@localhost.localdomain) (gcc version 8.3.1 20190507 (Red Hat 8.3.1-4) (GCC)) #1 SMP Wed Jun 10 17:58:43 CST 2020

Linux version 4.19.113-3.nfs.x86_64 (mockbuild@localhost.localdomain) (gcc version 8.3.1 20190507 (Red Hat 8.3.1-4) (GCC)) #1 SMP Wed Jun 10 17:58:43 CST 2020

Datum ux_login_table_update(UX_FUNCTION_ARGS)
{
    HeapTuple oldattTuple;
	Datum		values[Natts_ux_login_table];
	Relation	ux_audit_database_desc;
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);
	bool nulls[Natts_ux_login_table];
	HeapTuple tup;
	Relation	ux_login_table_desc;
	values[Anum_ux_login_table_rolname-1]=NameGetDatum(rolname);
	values[Anum_ux_login_table_last_login_timestamp-1]=NameGetDatum(last_login_timestamp);
	values[Anum_ux_login_table_failuretime-1]=NameGetDatum(last_failuretime);

    oldattTuple = SearchSysCache1(LOGINTABLE,NameGetDatum(rolname));
    if (!HeapTupleIsValid(oldattTuple))
	{
		ux_login_table_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
		tup = heap_form_tuple(RelationGetDescr(ux_login_table_desc), values, nulls);
		CatalogTupleInsert(ux_login_table_desc, tup);
		heap_freetuple(tup);
		heap_close(ux_login_table_desc, RowExclusiveLock);
		UX_RETURN_BOOL(true);
	}
	ux_audit_database_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
	CatalogTupleDelete(ux_audit_database_desc,  &oldattTuple->t_self);
	heap_close(ux_audit_database_desc, RowExclusiveLock);

    /* Free oldattTuple */
	ReleaseSysCache(oldattTuple);

    UX_RETURN_BOOL(true);
}


/* insret wangqi add */
Datum ux_login_table_insert(UX_FUNCTION_ARGS)
{
	Datum		values[Natts_ux_login_table];
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);
	bool nulls[Natts_ux_login_table];

	values[Anum_ux_login_table_rolname-1]=NameGetDatum(rolname);
	values[Anum_ux_login_table_last_login_timestamp-1]=NameGetDatum(last_login_timestamp);
	values[Anum_ux_login_table_failuretime-1]=NameGetDatum(last_failuretime);

	//if rolename don't in table ,insert it

		Relation	ux_login_table_desc;
		HeapTuple tup;
		ux_login_table_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
		tup = heap_form_tuple(RelationGetDescr(ux_login_table_desc), values, nulls);
		CatalogTupleInsert(ux_login_table_desc, tup);
		heap_freetuple(tup);
		heap_close(ux_login_table_desc, RowExclusiveLock);
		UX_RETURN_BOOL(true);
}

/* wangqi add update */

Datum ux_login_table_update(UX_FUNCTION_ARGS)
{
    HeapTuple oldattTuple;
	Relation	ux_audit_database_desc;
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);


    oldattTuple = SearchSysCache1(LOGINTABLE,NameGetDatum(rolname));
    if (!HeapTupleIsValid(oldattTuple))
	{
		UX_RETURN_BOOL(false);
	}
	/* if rolename databasename, delete it */
	ux_audit_database_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
	CatalogTupleDelete(ux_audit_database_desc,  &oldattTuple->t_self);
	heap_close(ux_audit_database_desc, RowExclusiveLock);

    /* Free oldattTuple */
	ReleaseSysCache(oldattTuple);

    UX_RETURN_BOOL(true);
}

Datum ux_login_table_update(UX_FUNCTION_ARGS)
{
    HeapTuple oldattTuple;
	Relation	ux_audit_database_desc;
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);


    oldattTuple = SearchSysCache1(LOGINTABLE,NameGetDatum(rolname));
    if (!HeapTupleIsValid(oldattTuple))
	{
		UX_RETURN_BOOL(false);
	}
	/* if rolename databasename, delete it */
	ux_audit_database_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
	CatalogTupleUpdate(ux_audit_database_desc,  &oldattTuple->t_self, oldattTuple);
	heap_close(ux_audit_database_desc, RowExclusiveLock);

    /* Free oldattTuple */
	ReleaseSysCache(oldattTuple);

    UX_RETURN_BOOL(true);
}

Datum ux_login_table_update(UX_FUNCTION_ARGS)
{
	Relation	ux_login_table_desc;
	HeapTuple newtuple;
	HeapTuple oldattTuple;
	Datum		values[Natts_ux_login_table];
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);
	bool nulls[Natts_ux_login_table];
	bool replaces[Natts_ux_login_table];
	replaces[Natts_ux_login_table - 1] = true;
	replaces[Natts_ux_login_table - 2] = true;
	replaces[Natts_ux_login_table - 3] = true;

	oldattTuple = SearchSysCache1(LOGINTABLE,NameGetDatum(rolname));
    if (!HeapTupleIsValid(oldattTuple))
	{
		UX_RETURN_BOOL(false);
	}
	ux_login_table_desc = heap_open(LoginTableRelationId, RowExclusiveLock);
	newtuple = heap_modify_tuple(oldattTuple, RelationGetDescr(ux_login_table_desc),
										 values, nulls, replaces);
	CatalogTupleUpdate(ux_login_table_desc, &newtuple->t_self, newtuple);
	heap_freetuple(newtuple);

	heap_close(ux_login_table_desc, RowExclusiveLock);
	ReleaseSysCache(oldattTuple);
	UX_RETURN_BOOL(true);
}

/* 系统函数 */

char se_buf[256] = "select rolname from ux_login_table where rolname = '";
if(options.username != NULL)
{
	strcat(in_buf, options.username);
}
else
{
	strcat(in_buf, "uxdb");
}
strcat(se_buf, "';");

char in_buf[256] = "select ux_login_table_insert('";
if(options.username != NULL)
{
	strcat(in_buf, options.username);
}
else
{
	strcat(in_buf, "uxdb");
}
strcat(in_buf, "','");
if(NULL != last_login_timestamp)
{
	strcat(in_buf, last_login_timestamp);
}
else
{
	strcat(in_buf, "NULL");
}
strcat(in_buf, "','");
if(failuretime != NULL)
{
	strcat(in_buf, failuretime);
}
else
{
	strcat(in_buf, "NULL");
}
strcat(in_buf, "');");

char up_buf[256] = "select ux_login_table_delete('";
if(options.username != NULL)
{
	strcat(up_buf, options.username);
}
else
{
	strcat(up_buf, "uxdb");
}
strcat(up_buf, "','");
if(NULL != last_login_timestamp)
{
	strcat(up_buf, last_login_timestamp);
}
else
{
	strcat(up_buf, "NULL");
}
strcat(up_buf, "','");
if(failuretime != NULL)
{
	strcat(up_buf, failuretime);
}
else
{
	strcat(up_buf, "NULL");
}
strcat(up_buf, "');");


2021-04-14

清理审计日志：
68821
104195：
https://cd.uxsino.com:10943/db/uxdb-ng/merge_requests/2911/diffs#4f2683b0d369507f3bb53bbb7581f10ca43dc110
76068

audit_log_keep_start_time这个参数现象我给你说下，
比如设置1，你删除的是前一天零点之前的日志，
像今天15号，那么删除的就是14号0点之前的数据（重启生效，默认0不生效）


2021-04-21

1、用什么链接数据库
2、.net链接是干什么


添加QuartzDataSync


目前计划：
pg+postgres_adaptor

最新问题：
 1、.NET链接 sqlserver 和 pg的差异

换成sqlserver，无报错。
<add name="uxdbEntities1" connectionString="Data Source=.;Initial Catalog=TicketManager.Standard(xbys);User ID=sa;Password=1qaz!QAZ;Connection Timeout=50" providerName="System.Data.SqlClient" />


/*pg*/
<add name="uxdbEntities1" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=Nuxsql;provider connection string=&quot;Host=192.71.0.138;Database=uxdb;Username=uxdb;Password=1qaz!QAZ&quot;" providerName="System.Data.EntityClient" />


问题单：105978
http://cd.uxsino.com:19503/issues/105978

分析：.net连接问题
验证数据源为pg，.NET 通过 EF（EntityFramework）链接pg正常，
验证数据库uxdb，打开插件postgres_adaptor链接uxdb正常，关闭postgres_adaptor插件，链接报错，
故第一种修改方案：可通过添加插件postgres_adaptor解决链接问题；
第二种：通过修改连接字符串方式：
目前需分析app.config配置文件作用， 尝试.net链接原始sqlserve，connectionStrings不起作用


使用pg数据源，打开postgres_adaptor插件

我的问题：
1、原sqlserver字串是什么
2、咱们修改后的字串是什么（替换了Nuxsql）

目前知道的信息：

1、用sqlserver数据库，链接正常

2、修改config配置文件，替换sqlserver字串为nuxsql，报链接报错

实施步骤：

1、查看现场测试方式，了解EF链接方式
2、复现现场问题
3、查看pg与sqlserver字串区别

知识点介绍：
1、EF
EF的简单介绍，EF是一种通过映射操作实现数据交互的ORM框架技术

C#EF的简单使用：
https://www.cnblogs.com/bridgew/p/12709063.html

2、C#链接sqlserver数据库
https://blog.csdn.net/github_39533414/article/details/87949142
ADO.NET连接SQLServer数据库
https://blog.csdn.net/qq_36482772/article/details/70992047
C#使用ADO.NET连接本地sqlserver数据库流程
https://www.cnblogs.com/zgk666/p/13808936.html

3、找不到库：
https://blog.csdn.net/weixin_43617448/article/details/106130236

4、读取 appconfig文件配置数据库连接的方法
1）、https://blog.csdn.net/weixin_33713503/article/details/91495542?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-9&spm=1001.2101.3001.4242
2）、
https://blog.csdn.net/qq15577969/article/details/90040345?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-11.control&dist_request_id=&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-11.control



操作系统代码】-【CPU 代码】
打包名：
uxdb-sec-ky10-aarch64-v2.1.002.p2.rpm
uxdb-sec-ky10-mips-v2.1.002.p2.rpm
uxdb-sec-nfs-x86_64-v2.1.002.p2.rpm

昨天通过c#代码链接sqlserver数据库成功，
通过app.config链接sqlserver会报一些依赖的库等报错，正在解决（目前不清楚现场具体操作过程，只了解到修改app.config后链接会报错，现在通过
https://www.cnblogs.com/dfcq/p/12966747.html
这种方式验证字串问题）

C#打印：

using System;

namespace ConsoleApp3
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}


sqlserver配置信息：
sqlservice信息：
10.1.131.31
用户名 sa
密码 :1qaz!QAZ
port 1433
数据库：master

远端uxdb数据库：
ip：
10.1.106.37
数据库名：uxdb
用户名：uxdb
密码：1qaz2wsx

报错内容：
1、c# 未能找到类型或命名空间名“Form”


####################链接完成###############

1、c#链接sqlserver数据库代码：

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Configuration; //连接配置
using System.Data.SqlClient;//数据库类

namespace KeyGen
{
    class Program
    {
        /* public Form1()
        {
            InitializeComponent();
        } */
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            Form1_Load();
        }

        private static void Form1_Load()
        {
            //获取配置文件中的连接字符串
            string myschool = ConfigurationManager.ConnectionStrings["DBConnect"].ConnectionString;
            //建立数据库连接
            SqlConnection conn = new SqlConnection(myschool);
            try
            {
                //开启连接
                conn.Open();
                Console.WriteLine("数据库连接成功!");
                Console.ReadLine();
            }
            catch (Exception)
            {
                Console.WriteLine("数据库连接失败!");
            }
            finally
            {
                //关闭连接
                Console.WriteLine("数据库连接完成！！！！！！！！！！！！！！！！！！！!");
                Console.ReadLine();
                conn.Close();
            }
        }
    }

}


2、C#链接postgresql
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Configuration; //连接配置
using System.Data.SqlClient;//数据库类sqlserver
using System.Data.EntityClient;//pg
using QuartzDataSync.Entity;

namespace KeyGen
{
    class Program
    {
        /* public Form1()
        {
            InitializeComponent();
        } */
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
            Form1_Load();
        }

        private static void Form1_Load()
        {
            //获取配置文件中的连接字符串
            //string myschool = ConfigurationManager.ConnectionStrings["uxdbEntities"].ConnectionString;
            string myschool = System.Configuration.ConfigurationManager.ConnectionStrings["uxdbEntities"].ToString();
            MessageBox.Show(myschool);
            //建立数据库连接
            SqlConnection conn = new SqlConnection(myschool);
            try
            {
                //开启连接
                conn.Open();
                Console.WriteLine("数据库连接成功!");
                Console.ReadLine();
            }
            catch (Exception)
            {
                Console.WriteLine("数据库连接失败!");

            }
            finally
            {
                //关闭连接
                Console.WriteLine("数据库连接完成！！！！！！！！！！！！！！！！！！！!");
                Console.ReadLine();
                conn.Close();
            }
        }
    }

}

C#链接pg
https://www.cnblogs.com/qiuzhongyang/p/3874095.html
c#代码
https://www.it610.com/article/1281244350075912192.htm

app.config字串配置：

<add name="DBConnect" connectionString="Data Source=10.1.131.31,1433;Database=master;User ID=sa;Password=1qaz!QAZ"/>

<add name="DBConnect" connectionString="Data Source=10.1.106.37,5432;Database=uxdb;User ID=uxdb;Password=1qaz2wsx"/>

创建实例：
pg生成的字串：
<add name="uxdbEntities" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=Npgsql;provider connection string=&quot;Host=192.71.0.138;Database=uxdb;Username=uxdb;Password=123456;Persist Security Info=True&quot;" providerName="System.Data.EntityClient" />

sqlserver生成的字串：
<connectionStrings>
	<add name="DBConnect" connectionString="Data Source=10.1.131.31,1433;Database=master;User ID=sa;Password=1qaz!QAZ"/>
</connectionStrings>


现场实例字串：
换成sqlserver，无报错。
<add name="uxdbEntities1" connectionString="Data Source=.;Initial Catalog=TicketManager.Standard(xbys);User ID=sa;Password=1qaz!QAZ;Connection Timeout=50" providerName="System.Data.SqlClient" />

/*pg*/
<add name="uxdbEntities1" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=Nuxsql;provider connection string=&quot;Host=192.71.0.138;Database=uxdb;Username=uxdb;Password=1qaz!QAZ&quot;" providerName="System.Data.EntityClient" />


2021-04-25
电子五所：
代码分支： support/#106134

如果是手动加的话， 宏用
#ifdef USE_CDPS
#endif

验证节点：
本节点之前正常
add some file for compile

<connectionStrings><add name="uxdbEntities" connectionString="metadata=res://*/Model1.csdl|res://*/Model1.ssdl|res://*/Model1.msl;provider=Npgsql;provider connection string=&quot;Host=10.1.106.37;Database=uxdb;Username=uxdb;Password=1qaz2wsx;Persist Security Info=True&quot;" providerName="System.Data.EntityClient" /></connectionStrings></configuration>

2021-04-26
长沙gfkd项目
1、类型转换问题
varchar到bytea的隐式转换：

测试sql：
create table test(a bytea);
insert into test values('111');
insert into test values('111'::varchar);

oracle用户大小写问题：

用户名读取大小写不敏感, 存储按照大写存储


数据库登录方式：

ftp://uxsino@192.30.1.2/centos_new.zip   之前张庆年传的
dm：

启动达梦：
./dbserver ini文件

dm登录：
进入bin目录，执行./disql
用户名：sysdba
密码：123456789(或者默认)



oracle:
启动数据库：
https://www.linuxidc.com/Linux/2014-04/100590.htm
sqlplus "/as sysdba"

oracle 安装：

https://blog.csdn.net/ywd1992/article/details/92830401

一、oracle登录及用户创建：
1、打开监听  lsnrctl start
2、打开sqlplus程序  sqlplus /nolog

3、在sqlplus连接数据库 connect /as sysdba
4、启动oracle 数据库 startup

5、创建用户
create user ora_user9 identified by 123456;

授权
grant create session,connect,resource to ora_user9;
grant resource to ora_user9;
grant unlimited tablespace to ora_user9;

6、连接数据库conn
conn ora_user1;

二、进行隐士转换：
select to_char(cast('abcdhjhhh' as varchar(100))) from dual;

三、显示时分秒设置：//设置后需要重启oracle数据库
alter system set nls_date_format= 'yyyy-mm-dd hh24:mi:ss' scope=spfile;


四、oracle下常用的系统表和系统视图
https://blog.51cto.com/jim123/1947872



密码有效时长问题：

设置有效时长参数：
1、超级用户设置有效时长（超级用户）
alter system set role_password_lifetime TO 30;
select ux_reload_conf();

2、修改用户有效时间（uxop）
alter user u1 valid until '2021-05-20 18:11:58';

数据库报错：
the number of days before a password expires should be less than or equal to %d.

密码输错报错：
password authentication failed for user \"%s\" , wrong input \"%d\" times

2021-04-30

1、检查权限
ux_class_aclmask
添加系统表：
ux_audit_infringement

AUDITINFRINGEMENT


添加注释：
/* Begin add by wangqi for #107103 at 2021.04.30 */
/* End add by wangqi for #107103 at 2021.04.30 */

修改lock_choose
bool lock_choose(void)
{
	MemoryContext oldcontext;
	int curr_number = -1;
	ListCell	*lc;
	//  if ( auditfgCxt )
	//  {
	// 	 auditfgCxt = AllocSetContextCreate(TopMemoryContext,
	// 				"audit context",
	// 			  	 ALLOCSET_DEFAULT_SIZES);
	//  }
	//oldcontext = MemoryContextSwitchTo(MessageContext);

	TimestampTz	min_timestamp ;
	TimestampTz	*curptr = NULL;
	TimestampTz currtime = 0;
	TimestampTz *oldtime[10] = { 0 };
	int oldnum = 0;
	curptr = polloc(sizeof(TimestampTz));
	currtime = GetCurrentTimestamp();
	*curptr = currtime;
	int64 		acl_valid_msecs = (int64)acl_fail_interval_time * SECS_PER_MINUTE * INT64CONST(1000) * INT64CONST(1000);
	min_timestamp = currtime - acl_valid_msecs;

	acl_fail_time_list = lappend_int_new(acl_fail_time_list, (void *)curptr);

	foreach(lc, acl_fail_time_list)
	{
		TimestampTz lctime= *(TimestampTz *)lc->data.ptr_value;
		if(min_timestamp -  lctime > 0)
		{
			oldtime[oldnum] = (TimestampTz *)lc->data.ptr_value;
			oldnum++;
		}

	}
	for (int i = 0; i < oldnum; i++)
	{
		acl_fail_time_list = list_delete(acl_fail_time_list, oldtime[i]);
	}

	curr_number = list_length(acl_fail_time_list);
	if(curr_number < acl_fail_lock_number)
	{
		return true;
	}
	else
	{
		return false;
	}

	//MemoryContextSwitchTo(oldcontext);
}


保密四期支持：
目前1个问题：
1、潜在侵害分析：
今天需求新增要求，需要具体到对表做策略；
现行临时方案：
增加结构体（记录表oid、失败时间戳）；
解决malloc问题，增加kill信号退出当前idle；（已修改）

存在风险：1、潜在侵害分析问题（计划在5月7号完成）


国防科大支持：
106884：

---查询表注释


select relname as table_name,cast(obj_description(relfilenode,'ux_class') as varchar) as comments, relkind as table_type from ux_class c  where relkind = 'r' and relname='TB';


---查询列注释

SELECT
a.attname as "字段名",
col_description(a.attrelid,a.attnum) as "注释",
c.relname
FROM
ux_class as c,
ux_attribute as a
WHERE  a.attrelid = c.oid
and a.attnum>0 and c.relkind='r' and c.relname ='TB';




dm实现功能语句：

1、表结构
owner  table_name   table_type   comments(注释)
select * from USER_TAB_COMMENTS;

select * from SYS_CATALOG.USER_COL_COMMENTS ;
select * from SYS_CATALOG.USER_TAB_COMMENTS ;

2、查询列注释信息

owner  table_name   column_name     comments
select * from USER_COL_COMMENTS where table_name = tb;

TEST=# \d+ SYS_CATALOG.USER_TAB_COMMENTS ;
                      View "SYS_CATALOG.USER_TAB_COMMENTS"
   Column   |             Type             | Modifiers | Storage  | Description
------------+------------------------------+-----------+----------+-------------
 TABLE_NAME | CHARACTER VARYING(63 byte)   |           | extended |
 TABLE_TYPE | CHARACTER VARYING(11 byte)   |           | extended |
 COMMENTS   | CHARACTER VARYING(4000 char) |           | extended |
View definition:
 SELECT C.RELNAME::CHARACTER VARYING(63 byte) AS TABLE_NAME,
        CASE C.RELKIND
            WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::CHARACTER VARYING(11 byte) AS TABLE_TYPE,
    D.DESCRIPTION::CHARACTER VARYING(4000 char) AS COMMENTS
   FROM SYS_CLASS C,
    SYS_DESCRIPTION D,
    SYS_USER AU
  WHERE C.OID = D.OBJOID AND D.CLASSOID = 1259::OID AND D.OBJSUBID = 0 AND C.RELOWNER = AU.USESYSID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AU.USENAME = "CURRENT_USER"()::CHARACTER VARYING(63 byte)::NAME;

\d+: extra argument ";" ignored


TEST=# \d+ SYS_CATALOG.USER_COL_COMMENTS ;
                      View "SYS_CATALOG.USER_COL_COMMENTS"
   Column    |             Type             | Modifiers | Storage  | Description
-------------+------------------------------+-----------+----------+-------------
 OWNER       | CHARACTER VARYING(63 byte)   |           | extended |
 TABLE_NAME  | CHARACTER VARYING(63 byte)   |           | extended |
 COLUMN_NAME | CHARACTER VARYING(63 byte)   |           | extended |
 COMMENTS    | CHARACTER VARYING(4000 char) |           | extended |
View definition:
 SELECT A.USENAME::CHARACTER VARYING(63 byte) AS OWNER,
    C.RELNAME::CHARACTER VARYING(63 byte) AS TABLE_NAME,
    AT.ATTNAME::CHARACTER VARYING(63 byte) AS COLUMN_NAME,
    D.DESCRIPTION::CHARACTER VARYING(4000 char) AS COMMENTS
   FROM SYS_USER A,
    SYS_CLASS C,
    SYS_ATTRIBUTE AT
     LEFT JOIN SYS_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJOID = AT.ATTRELID AND AT.ATTNUM = D.OBJSUBID
  WHERE AT.ATTRELID = C.OID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AT.ATTNUM > 0 AND AT.ATTISDROPPED = false AND C.RELOWNER = A.USESYSID AND A.USENAME = "CURRENT_USER"()::CHARACTER VARYING(63 byte)::NAME;

\d+: extra argument ";" ignored

pg实现：
将视图添加到
system_views.sql

1、查询表注释

select relname as table_name,cast(obj_description(relfilenode,'ux_class') as varchar) as comments, relkind as table_type from ux_class c  where relkind = 'r' and relname='TB';

SELECT
A.USENAME::varchar as OWNER，
C.RELNAME::varchar AS TABLE_NAME,
	   CASE C.RELKIND
			WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::CHARACTER VARYING(11 byte) AS TABLE_TYPE,
		cast(obj_description(relfilenode,'ux_class') as varchar) as COMMENTS
	from ux_user A,
		ux_class C where A.usename = "CURRENT_USER"()::varchar::NAME;










/*******************************************
已经验证成功：
*******************************************/
select
A.USENAME as OWNER,
C.RELNAME as TABLE_NAME,
CASE C.RELKIND
			WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::varchar AS TABLE_TYPE,
cast(obj_description(relfilenode,'ux_class') as varchar) as COMMENTS
from
ux_class C,
ux_user A
where relname='TB' and A.usename = "CURRENT_USER"()::varchar::NAME;


人大金仓：
1、人大金仓与uxdb关系
uxdb缩写ux，人大金仓缩写sys；



create view USER_TAB_COMMENTS AS SELECT
	AU.USENAME as OWNER,
	C.RELNAME::varchar AS TABLE_NAME,
        CASE C.RELKIND
            WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::varchar AS TABLE_TYPE,
    D.DESCRIPTION::varchar AS COMMENTS
   FROM UX_CLASS C,
    UX_DESCRIPTION D,
    UX_USER AU
  WHERE C.OID = D.OBJOID AND D.CLASSOID = 1259::OID AND D.OBJSUBID = 0 AND C.RELOWNER = AU.USESYSID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AU.USENAME = "CURRENT_USER"()::varchar::NAME;


2、查询列注释信息

SELECT
A.USENAME as OWNER,
C.RELNAME as TABLE_NAME,
D.attname as COLUMN_NAME,
col_description(D.attrelid,D.attnum) as COMMENTS
FROM
ux_user A,
ux_class as C,
ux_attribute as D
WHERE  D.attrelid = C.oid
and D.attnum>0 and C.relkind='r' and C.relname ='TB' and A.usename = "CURRENT_USER"()::varchar::NAME;



create view USER_COL_COMMENTS AS SELECT A.USENAME::varchar AS OWNER,
    C.RELNAME::varchar AS TABLE_NAME,
    AT.ATTNAME::varchar AS COLUMN_NAME,
    D.DESCRIPTION::varchar AS COMMENTS
   FROM UX_USER A,
    UX_CLASS C,
    UX_ATTRIBUTE AT
     LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJOID = AT.ATTRELID AND AT.ATTNUM = D.OBJSUBID
  WHERE AT.ATTRELID = C.OID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AT.ATTNUM > 0 AND AT.ATTISDROPPED = false AND C.RELOWNER = A.USESYSID AND A.USENAME = "CURRENT_USER"()::varchar::NAME;

objsubid 对于一个表字段的注释，它是字段号，对应于pg_attribute.attnum。对于其它对象类型，它是零。
relowner（所有者）都是用其对应的oid显示





问题：

uxdb的UX_DESCRIPTION中没有CLASSOID=1259，
OBJOID中不存在1259 oid，

1、人大金仓获取所有表结构以及注释，
通过筛选ux_class所属对象的oid在ux_description中，将表名、表类型、注释、列名添加到USER_TAB_COMMENTS、USER_COL_COMMENTS视图中，
但咱数据库uxdb没有ux_description所属对象的oid的注释信息，导致查询结果为空，目前需分析人大金仓ux_description的结构信息

2、人大金仓与达梦获取表结构没有字段owner;

pg_description介绍：
1、pg_description有四个字段
OBJOID：
CLASSOID：		系统目录oid（如：ux_class）
OBJSUBID：
DESCRIPTION：

/*******************************************
已经验证成功：
*******************************************/

添加表注释：



添加列注释：

1、
create view USER_COL_COMMENTS AS SELECT A.USENAME::CHARACTER VARYING(63) AS OWNER,
    C.RELNAME::CHARACTER VARYING(63) AS TABLE_NAME,
    AT.ATTNAME::CHARACTER VARYING(63) AS COLUMN_NAME,
    D.DESCRIPTION::CHARACTER VARYING(4000) AS COMMENTS
   FROM UX_USER A,
    UX_CLASS C,
    UX_ATTRIBUTE AT
     LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJOID = AT.ATTRELID AND AT.ATTNUM = D.OBJSUBID
  WHERE AT.ATTRELID = C.OID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AT.ATTNUM > 0 AND AT.ATTISDROPPED = false AND C.RELOWNER = A.USESYSID AND A.USENAME = "CURRENT_USER"()::CHARACTER VARYING(63)::NAME;

2、
create view USER_COL_COMMENTS AS SELECT A.USENAME::varchar AS OWNER,
    C.RELNAME::varchar AS TABLE_NAME,
    AT.ATTNAME::varchar AS COLUMN_NAME,
    D.DESCRIPTION::varchar AS COMMENTS
   FROM UX_USER A,
    UX_CLASS C,
    UX_ATTRIBUTE AT
     LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJOID = AT.ATTRELID AND AT.ATTNUM = D.OBJSUBID
  WHERE AT.ATTRELID = C.OID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AT.ATTNUM > 0 AND AT.ATTISDROPPED = false AND C.RELOWNER = A.USESYSID AND A.USENAME = "CURRENT_USER"()::varchar::NAME;


添加表注释：
1、
create view USER_TAB_COMMENTS AS SELECT
	C.RELNAME::CHARACTER VARYING(63) AS TABLE_NAME,
        CASE C.RELKIND
            WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::CHARACTER VARYING(11) AS TABLE_TYPE,
    D.DESCRIPTION::CHARACTER VARYING(4000) AS COMMENTS
   FROM UX_USER AU,
	UX_CLASS C
	LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJSUBID = 0 AND D.OBJOID = C.OID
  WHERE  C.RELOWNER = AU.USESYSID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AU.USENAME = "CURRENT_USER"()::CHARACTER VARYING(63)::NAME;

2、
create view USER_TAB_COMMENTS AS SELECT
	AU.USENAME as OWNER,
	C.RELNAME::varchar AS TABLE_NAME,
        CASE C.RELKIND
            WHEN 'r'::"CHAR" THEN 'TABLE'::TEXT
            WHEN 'v'::"CHAR" THEN 'VIEW'::TEXT
            ELSE 'TABLE'::TEXT
        END::varchar AS TABLE_TYPE,
    D.DESCRIPTION::varchar AS COMMENTS
   FROM UX_USER AU,
	UX_CLASS C
	LEFT JOIN UX_DESCRIPTION D ON D.CLASSOID = 1259::OID AND D.OBJSUBID = 0 AND D.OBJOID = C.OID
  WHERE  C.RELOWNER = AU.USESYSID AND (C.RELKIND = ANY (ARRAY['r'::"CHAR", 'v'::"CHAR"])) AND AU.USENAME = "CURRENT_USER"()::varchar::NAME;

注意事项：
1、达梦注释为空也会添加到视图USER_TAB_COMMENTS中，

gfkd:
uxdb-std-kylin-aarch64-v2.1.0.3.029.p2.tar.gz


2021-05-10
begin语法改造
1、
begin select 1 from dual;end;

2、
https://www.yiibai.com/manual/postgresql/sql-begin.html

3、语法改造
	j=strlen(query_string);
	for( i=j;i>=5;i--)
	{
		query_string[i+1] = query_string[i];
	}
	query_string[5] = ';';


if (!strncasecmp(sql, "BEGIN", 5))
			{
				memset(dest, 0, MAX_SQL_LEN);
				strcat(dest, "do #_UX_# ");
				strcat(dest, sql);
				strcat(dest, " #_UX_#;");
				strcpy(sql, dest);
				printf("********sql = %s**************\n", sql);
			}

3、匿名块

do $$ begin delete from TB;commit;end;$$

oci.c:OCIStmtExecute

begin语句改造

修改方案：
方案一：在exec_simple_query直接修改sql语句；

  if(!strncasecmp(query_string,"BEGIN ",6))
  {
    strcpy(temp, "do $$ ");
    strcat(temp, sql);
    strcat(temp, " $$;");
    strcpy(query_string, temp);
  }



方案二：
修改OCI语法：
OCI 输入sql语法格式：
begin;begin + sql + end;
将sql语法改造为匿名块语法传到后端（目前分析sql在oci prepare阶段未做拼接，目前不清楚sql拼接代码位置）；


do $$   $$;



2021-05-12

1、begin空格问题

2、
可以在
inputmessage去改

3、
#0  UXAPI_Execute (hstmt=hstmt@entry=0x6293e0, flag=flag@entry=1) at execute.c:939
#1  0x00007ffff6d459f0 in SQLExecute (StatementHandle=0x6293e0) at odbcapi.c:390


4、oci转换
statement.c:
SC_execute

begin语法优化：

static
char *ux_strrpc(char *str, char *oldstr, char *newstr)
{
	char bstr[MAX_SQL_LEN]; //转换缓冲区
	memset(bstr, 0, sizeof(bstr));

	for (int i = 0; i < strlen(str); i++)
	{
		if (!strncmp(str + i, oldstr, strlen(oldstr)))
		{ //查找目标字符串
			strcat(bstr, newstr);
			i += strlen(oldstr) - 1;
		}
		else
		{
			strncat(bstr, str + i, 1); //保存一字节进缓冲区
		}
	}

	strcpy(str, bstr);
	return str;
}


char *ux_strrpc1(char *str, char *oldstr, char *newstr)
{
    char *p1,*p2;
    char *src;
    p1 = strstr(str, oldstr);
    if (p1 == NULL)
     return;  /* do nothing */

    p2 = strstr(p1 + 6, oldstr);
    if (p2 == NULL)
     return;  /* do nothing */
    for (int i=0;i<6;i++)
    {
        *(p1++) = *(p2++) = *(newstr++);
    }
}

改造后：

strcasestr

static
char *ux_strrpc(char *str, char *oldstr, char *newstr)
{
    char *old_p;
	char *new_p;
    char *src;
	int len = strlen(oldstr);

	for(int i = 0; i < strlen(str); i+len)
	{
		old_p = NULL;
		new_p = newstr;
		/* 查找字串str中是否有固定字串oldstr并替换 */
		old_p = strstr(str, oldstr);
		if (old_p == NULL)
			return;  /* do nothing */

		for (int j=0;j<len;j++)
		{
			*(old_p++) = *(new_p++);
		}
	}
}

		for(int i = 0;i< strlen(string); i++)
        {
                string[i] = tolower(string[i]);

        }


最新改造：

void ux_strrpc(char *str, char *oldstr, char *newstr)
{
	char *p = str;
	int len = strlen(oldstr);

	/* 查找字串str中是否有固定字串oldstr并替换 */
	if(NULL != str)
	{
		for (int i = 0; i < strlen(str); i++)
		{
			if (!strncasecmp(p + i, oldstr, strlen(oldstr)))
			{ //查找目标字符串
				for (int j=0;j<len;j++)
					*(p++) = *(newstr++);
			}
		}
	}
}

tatic
char *ux_strrpc(char *str, char *oldstr, char *newstr)
{
	char *p = str; //转换缓冲区

	for (int i = 0; i < strlen(str); i++)
	{
		if (!strncasecmp(p + i, oldstr, strlen(oldstr)))
		{ //查找目标字符串
			for (int j=0;j<len;j++)
			*(p++) = *(newstr++);
		}
	}

}


2021-05-14

1、
CREATE TABLE CONSUMER_DN (
	DOMAIN_NAME					VARCHAR2(159),
	RDN_NAME					VARCHAR2(40),
	VERSION						NUMBER(10),
	CONSUMER_DOMAIN_NAME		VARCHAR2(159),
	SHADOW_FAILURE_TYPE			NUMBER(1),
	VALID_BEGINTIME				TIMESTAMP,
	VALID_ENDTIME				TIMESTAMP,
	SHADOW_BEGINTIME			TIMESTAMP,
	SHADOW_ENDTIME				TIMESTAMP,
	TABLE_NO					NUMBER(2),
	LASTUPDATETIME				TIMESTAMP,
	RECORD_UPDATETIME			TIMESTAMP		DEFAULT SYSDATE);

SQLT_AVC
SQLT_FLT
SQLT_TIMESTAMP


insert into CONSUMER_DN values('a','b',1,'c',2,'2016-05-20','2016-05-20','2016-05-20','2016-05-20',3,'2016-05-20');

2、storage语法支持

void ux_stroage(char *str, char *oldstr, char *newstr)
{
	char *p = str;
	int len = strlen(newstr);

	if(len != strlen(newstr) || len == 0)
		return;  /* do nothing */

	if(NULL == str)
		return;  /* do nothing */
	for (int i = 0; i < strlen(str); i++)
	{
		if (strncasecmp(p + i, oldstr, strlen(oldstr)) == 0)
		{ /* 查找目标字符串 */
			p = p+i;

			for(int j=0;j<len+1;j++)
				*(p++) = *(newstr++);

			return; /* 我们只替换一次 */
		}
	}
}

create table test111 (a name ) storage ( on main, cluetr);

create table test111 (a name ) tablespace main;


char
if(!strncasecmp(sql, "storage", 7))
{


}
for(int j = i + 1; j < strlen(str); j++)
	if(strncasecmp(p +j ,"(",1) == 0)
	{
			p = p+i;

			for(int j=0;j<len+1;j++)
				*(p++) = *(newstr++);
	}


2021-05-18
流复制
1、

主机：192.71.0.138
备机：192.71.0.140

流复制介绍：
https://blog.csdn.net/weixin_39540651/article/details/106122610




























2021-05-18

#!/bin/bash
read -p "please input the time you want count " i
a=$i
for ((b=0;b<$a;b++))
do
uxsql -U uxdb -d uxdb -c "select * from t1 limit 1"
<<EOF
localhost:5432:uxdb:uxdb:1qaz!QAZ
EOF
done
sql脚本
#!/bin/bash

for ((i=0;i<10;))
do
uxsql -U uxdb -d uxdb -c "insert into tb values(1);"
sleep 3
done

wal日志报错信息：
terminating walreceiver process due to administrator command

unexpected pageaddr 1/CC000000 in log segment 000000400000000200000012, offset 0


FATAL:  could not receive data from WAL stream: server closed the connection unexpectedly
                This probably means the server terminated abnormally
                before or while processing the request.

unexpected pageaddr %X/%X in log segment %s, offset %u

invalid magic number %04X in log segment %s, offset %u

确定哪个段文件
 unexpected pageaddr 0/BE01E000 in log segment 0000000100000000000000BE, offset 114688
hdr->xlp_pageaddr >> 32 = 0
hdr->xlp_pageaddr = BE01E000
fname = 0000000100000000000000BE
offset = 114688


offset = recptr % 16M
segno = recptr / 16M

recaddr = segno *16M + offset



wal_level = minimal
archive_mode = on  //备库上已注释掉
#根据实际业务需求配置
archive_command =’ cp %p  /host/postgres/pgarchive/%f’   //备库上已注释掉
#根据实际业务需求配置
max_wal_senders = 5
#根据实际业务需求配置
wal_keep_segments = 50000
hot_standby = on
wal_log_hints = on


5790701d8c695342f79983e1a4529907ecbe9a93

ca88c439c57e1bba725d888448a3e63706831900


xlog日志机制：
https://doc.docsou.com/b30046f8470aab0e97bdbe99fc48147e74fe71353.html

块的头部：
wal日志以8k为一个文件块，16M为一个文件。

块头
XLogPageHeaderData



重庆传晟研发支持进度：
https://www.cnblogs.com/ilifeilong/p/7002687.html
根据现场反馈，主库跑了25GB数据，非必要不想动主库；
目前分析进度：分析流复制原理，流复制通过不断传输应用WAL record实现，
读取流程:startup ->uxmaster(standby模式需要通知uxmaster启动一个walreceiver进程)->walreceiver->读取xlog(WAL record)
目前报错是在xlog record地址校验报错，由于数据报错需压测重现，目前通过打印日志分析流复制地址偏移具体报错位置，具体位置待分析
项目紧急情况：待反馈


区域化研发支持进度：

.net问题，要链接咱uxdb数据库，需要修改链接函数，由于该函数在客户源码中，
客户那边研发较忙，目前无法提供源码，具体适配时间待定



项目紧急情况：待反馈
wal日志学习：
1、流复制
https://www.cnblogs.com/yickel/p/11161706.html

2、预写日志代码详解日志：
http://mysql.taobao.org/monthly/2017/03/02/

主备总体结构
https://www.cnblogs.com/ilifeilong/p/7002687.html


https://blog.csdn.net/iteye_4537/article/details/82394998

预写日志代码详解日志：
http://mysql.taobao.org/monthly/2017/03/02/

XLogBackgroundFlush将xlog日志开始位置和结束位置传递给XLogWrite函数进行写日志操作。

PG主备流复制的核心部分由walsender，walreceiver和startup三个进程组成。
walsender进程是用来发送WAL日志记录的，执行顺序如下：
PostgresMain()->exec_replication_command()->StartReplication()->WalSndLoop()->XLogSendPhysical()
walreceiver进程是用来接收WAL日志记录的，执行顺序如下：
sigusr1_handler()->StartWalReceiver()->AuxiliaryProcessMain()->WalReceiverMain()->walrcv_receive()
startup进程是用来apply日志的，执行顺序如下：
PostmasterMain()->StartupDataBase()->AuxiliaryProcessMain()->StartupProcessMain()->StartupXLOG()

重庆传晟研发支持进度：

通过打印xlog record地址，在读取wal日志时wal日志页多偏移8192字节，通过解读备机wal日志，
根据报错偏移位置获取wal日志对应偏移量与具体偏移值不相等，解读主机存在同样问题，故排除流复制问题，
通过验证单机模式下，同样存在该问题，故该问题在写xlog日志导致，通过查看xlog写日志逻辑，加密写入wal日志的时候，
openLogOff偏移计算不正确，修改后解读wal日志正常



2021-05-31

create table test(id1 int, id2 int ,id3 int, id4 int, id5 int);
insert into test values(1,1,1,1,1);
insert into test values(2,2,2,2,2);
merge into test d using (select  id1,id2,id3 from test) s on (d.id1 = 1 and s.id1 = d.id1)
when matched then update set d.id3 = 999, d.id4 =999 when not matched then insert (id1,id2,id3,id4,id5)  values(9,9,9,9,9);


using搜出来的结果逐条与on条件匹配，根据连接条件，对目标表进行查询，
连接条件匹配上进行update，否则insert，目前功能只

目标和源关系之间

2021-06-04

vacuum机制

#109226问题复现，问题定位在语法分析时，type类型未分配内存导致；

vacuum机制了解，分析查看Lazy_vacuum_rel函数功能

参加内存管理培训讨论

2021-06-07

OdirectWrite
if(buf非按512字节对齐)
else（buf地址按512字节对齐）

buf：
1、判断buf是否按512字节对齐

2、AlignedCountSize  按字节对齐（如：count小于512，AlignedCountSize = 512）

3、

main.c:

./s fw ./t1 2 2 2 2
fw:
./t1:  打开的文件
2：多少个512
2：文件内容
2：buf偏移多少
2：指针偏移多少

2021-06-08
ux_control
1、ux_control介绍
https://zhuanlan.zhihu.com/p/359402697

2、ux_control文件代码
https://blog.csdn.net/xichenguan/article/details/109339556

ux_control的结构体：ControlFileData

查看当前检查点状态信息
select *from ux_control_checkpoint();

借助工具查看ux_control中的数据
./ux_controldata -D master

WriteControlFile			//创建ux_control文件

	memset(buffer, 0, PG_CONTROL_FILE_SIZE);
	memcpy(buffer, ControlFile, sizeof(ControlFileData));

__O_DIRECT:字节对齐参数

posix_memalign：
int posix_memalign (void **memptr,
                    size_t alignment,
                    size_t size);

申请size大小字节的内存，memptr地址是alignment的倍数

initdb源码分析：
https://www.cnblogs.com/gaojian/p/3173776.html





1 odirect封装模块加入db代码,使用ux_control文件的odirect读写进行测试。
2 编写odirect封装模块文档(10%)。
3 参加研发内存管理培训



super_rac.auto.conf



ux_hba.conf
ux_ident.conf

2021-06-11

1、fputs
定义：
int fputs(const char *s, FILE *stream);

pg初始化写入配置文件数据通过fputs函数行数据写入，与write实现差异较大，
fputs传字符串到一个文件流中，也就是在缓冲区进行读写操作，与write实现差异较大，

fputs传字符串到一个文件流中，数据在缓冲区进行读写操作，pg初始化写入配置文件数据通过行数据写入，

fopen学习：
https://blog.csdn.net/weixin_39770592/article/details/117206063

fputs细节：
https://blog.csdn.net/weixin_30677073/article/details/96883311





initdb初始化写入配置文件数据通过fputs函数行数据写入，故不能单独封装fputs，
在fputs写入数据后，修改为512对齐，目前修改针对写入数据后对齐，本地demo验证通过




        int offset = fputs(s, fp);
        offset = ftell(fp);
        fseek(fp, offset, SEEK_SET);
        int offset2 = fputs(s1, fp);
        offset2 = ftell(fp);
共享存储问题单：
 #109187
代码分支：
feature/v2.1.0.6.01r/#109187

#110114：表文件读写接入direct io
 pg_logdir_ls()、pg_ls_dir()、pg_file_rename()、ux_file_write()、 pg_read_file()、pg_length_file()

问题单：
#110114：6.15完成
mdwrite/mdread/mdopen


#110118：6.18日完成
在线恢复：
在线恢复文件:recovery_set.c
入口：
ScanWalConstructRecoverySet




全局控制文件/本实例控制文件的读写操作和文件初始化时的字节对齐

1、全局控制文件和本实例控制文件初始化位置
控制文件初始化：
函数：
WriteControlFile
2、全局控制文件读写
xlog.c: 9418  ReadNeedRecoveryList（已修改）
UpdateGlobalControlFile（已修改）
ReadControlFileByPath（已修改）
UpdateControlFileByPath（已修改）


3、实例控制文件读写（本地控制文件）
xlog.c: OpControlFileByInstID（已修改）
ReadControlFileByPath（已修改）

wal日志相关接口：

XLogFileOpen

写wal日志：
XLogWrite

读wal日志：
在线恢复：
ReadCheckpointRecord

wal日志读取接口：
https://www.ofweek.com/ai/2021-05/ART-201713-11000-30499302.html
StartupXLOG		//启动恢复函数，该函数从ux_control文件中读取checkpoint记录，然后从checkpoint记录的redo点开始进行恢复


读取接口：
XLogPageRead

control文件：
1、ReadControlFileDataByPath

wal日志写日志通过函数XLogWrite，
wal日志读取流程：
StartupXLOG	//启动恢复函数，该函数从ux_control文件中读取checkpoint记录，然后从checkpoint记录的redo点开始进行恢复
	ReadRecord		//循环读取wal记录
		XLogReadRecord
			ReadPageInternal
				state->read_page	//回调指针调用XLogPageRead函数读取wal日志信息


dopne/dwrite/dread代码
1、open：UX_DIRECTIO
2、read：
read(fd, ControlFile, sizeof(ControlFileData)) != sizeof(ControlFileData)
OdirectRead(fd, ControlFile, sizeof(ControlFileData)) != sizeof(ControlFileData)

3、write
write(fd, ControlFile, sizeof(ControlFileData)) != sizeof(ControlFileData)
OdirectWrite(fd, ControlFile, sizeof(ControlFileData)) != sizeof(ControlFileData)

4、close
OdirectCloseFile

4、添加宏
#if UXDB_RAC_ODIRECT1
#else
#endif

wal日志修改函数：
XLogWritePages
XLogFileInit
XLogFileOpen
XLogPageRead

在线恢复：
总接口
ExcuteOnlineRecovery

在线恢复相关控制文件接口，
ReadControlFileByPath
ReadControlFileDataByPath
ReadControlFileTo
目前代码中已经修改，
修改wal日志direct接口，
主要修改XLogWrite写日志函数、XLogPageRead读日志接口，
修改验证通过，代码已提交


1. 梳理了control文件要改的几个地方：
controldata_utils.c :44   get_controlfile
xlog.c: 9418  ReadNeedRecoveryList
UpdateControlFileByPath  更新全局control文件
OpControlFileByInstID 更新实例control文件 (先不管)
uxmaster.c:2463  fp = AllocateFile(path, UX_BINARY_R);

2、
1 uxmaster.c中使用AllocateFile函数调用fopen进行了打开，直接修改fopen改动较大，添加AllocateFileOdirect函数实现替换。
2 uxmaster.c中使用regular_copy_file_odirect函数进行文件拷贝时，修改其中接口为Odirect。
  问题：
  修改regular_copy_file_odirect函数测试发现启动实例时提示uxsinodb.conf文件有错误标识符，分析得知拷贝函数拷贝了ux_control、uxsinodb.conf、uxsinodb.auto.conf三个文件，因conf文件为普通文本文件，且文件大小未512对齐，所以OdirectWrite写入时进行了对齐，文件末尾增加了一些空字符(assicci的0)导致错误，ux_control文件本身就是二进制文件所以未报错。
  目前处理是加了判断，只有拷贝ux_control文件时才调用odirect接口，其他文件拷贝走原流程。
明天进一步分析解决方法。


问题单110148：
服务器：
192.30.0.246,
192.30.0.249

用户/密码：uxdb/uxdb_rac123456

InitiatorName=iqn.1994-05.com.redhat:75a2cffb76c

mkpart sdd4 300GB 400GB


2021-6-21

共享存储任务：
svn://192.30.1.2/svn/uxdb/30.项目/01.SRAC/03.SRACv2.1.0.6/02.管理域/01 项目计划

1、离线恢复：StartupXLOGMultiInst
9653-11497行

读取控制文件：
ReadControlFile
traverseControlFiles
OpControlFileByInstID



底层控制文件：
ReadControlFileByPath
ReadNeedRecoveryList
UpdateControlFileByPath
UpdateControlFile

任务：
Clog文件启动时的拷贝方式 后续需要调整为网络传输文件字节流的方式

clog日志管理器

1个字节可存储4个事物的CLOG记录，所以一个页面（8KB）可记录2的15次方；
由于一个日志段由32个页面组成，故一个clog日志记录2的20次方个事物；

事物ID为32比特，因此事物数有2的32次方个。


2021-06-22

initdb.c:1505
super_rac.auto.conf
19503

110801
查看带宽命令：
https://blog.51cto.com/u_13718210/2418661


linux:

查看磁盘读写性能/io
sudo fio -filename=/var/test.file -direct=1 -iodepth 1 -thread -rw=randrw -rwmixread=70 -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=100 -group_reporting -name=mytest1

查看带宽：
首先安装工具：
yum install epel-release
yum install libpcap nethogs

通过 nethogs 查看

python测试带宽
https://www.cnblogs.com/setout/p/10315082.html

磁盘转速命令：
sginfo -g /dev/sdf

测试网络带宽：
ethtool em2

1、super_rac.auto.conf 集群配置参数信息记录文件的读写操作和文件初始化时的字节对齐，分析fgets函数替换方案，由于该问题优先级低，暂不处理
2、分析共享磁盘读写io性能问题， 通过sar命令查看 CPU 、内存、磁盘、网络等性能


uxbench性能为什么变低？

查看磁盘IO性能：
https://www.cnblogs.com/mauricewei/p/10502539.html

iops(每秒执行的IO次数)、
bw（带宽，每秒的吞吐量）

request the lock mode(12) timeout from instance 2 for block 5444 of relation base/13231/16389

读写磁盘：
tps: 每秒向磁盘设备请求数据的次数，包括读、写请求，为rtps与wtps的和。
rtps: 每秒向磁盘设备的读请求次数

wtps: 每秒向磁盘设备的写请求次数

bread: 每秒从磁盘读的bytes数量

bwrtn: 每秒向磁盘写的bytes数量

共享存储问题单 109913：


测试写性能命令：
本地：
direct | sync：
time dd if=/dev/zero of=test.file bs=10M count=2 oflag=direct oflag=sync
非direct
time dd if=/dev/zero of=test.file bs=10M count=2

共享盘：
direct | sync：
time dd if=/dev/zero of=test.file bs=10M count=2 oflag=direct oflag=sync
非direct
time dd if=/dev/zero of=test.file bs=10M count=2

测试读性能命令：
本地：
direct | sync：
dd if=test.file if=/dev/null  iflag=direct oflag=sync
非direct：
dd if=test.file if=/dev/null

共享盘：
direct | sync：
dd if=test.file if=/dev/null  iflag=direct oflag=sync
非direct：
dd if=test.file if=/dev/null

fio：

fio -filename=test.file -direct=1 -iodepth 1 -thread -rw=read -ioengine=psync -bs=16k -size=2G -numjobs=10 -runtime=60 -group_reporting -name=test_r




旧盘（109）
异步
顺序读：
READ: bw=1066MiB/s (1117MB/s), 1066MiB/s-1066MiB/s (1117MB/s-1117MB/s)    , io=30.0GiB (32.2GB), run=28830-28830msec		IOPS=68.2k

顺序写：
WRITE: bw=60.9MiB/s (63.9MB/s), 60.9MiB/s-60.9MiB/s (63.9MB/s-63.9MB/s), io=3654MiB (3832MB), run=60004-60004msec			IOPS=3897


随机读：
READ: bw=1015MiB/s (1064MB/s), 1015MiB/s-1015MiB/s (1064MB/s-1064MB/s), io=30.0GiB (32.2GB), run=30271-30271msec			IOPS=64.9k

随机写：
WRITE: bw=60.0MiB/s (63.9MB/s), 60.0MiB/s-60.0MiB/s (63.9MB/s-63.9MB/s), io=3670MiB (3848MB), run=60198-60198msec			IOPS=3901

混合读写：
READ: bw=22.9MiB/s (24.0MB/s), 22.9MiB/s-22.9MiB/s (24.0MB/s-24.0MB/s), io=2293MiB (2405MB), run=100002-100002msec			IOPS=1467
  WRITE: bw=9.84MiB/s (10.3MB/s), 9.84MiB/s-9.84MiB/s (10.3MB/s-10.3MB/s), io=984MiB (1032MB), run=100002-100002msec		IOPS=629

模式：同步
顺序读：
READ: bw=1057MiB/s (1108MB/s), 1057MiB/s-1057MiB/s (1108MB/s-1108MB/s), io=30.0GiB (32.2GB), run=29073-29073msec		IOPS=67.6k

顺序写：
WRITE: bw=87.8MiB/s (92.1MB/s), 87.8MiB/s-87.8MiB/s (92.1MB/s-92.1MB/s), io=5268MiB (5524MB), run=60006-60006msec		IOPS=5619

随机读：
READ: bw=252MiB/s (265MB/s), 252MiB/s-252MiB/s (265MB/s-265MB/s), io=14.8GiB (15.9GB), run=60006-60006msec			IOPS=16.2k

随机写：
WRITE: bw=109MiB/s (114MB/s), 109MiB/s-109MiB/s (114MB/s-114MB/s), io=6525MiB (6842MB), run=60018-60018msec			IOPS=6957

混合读写：
READ: bw=164MiB/s (172MB/s), 164MiB/s-164MiB/s (172MB/s-172MB/s), io=16.1GiB (17.2GB), run=100005-100005msec					IOPS=10.5k
WRITE: bw=70.5MiB/s (73.9MB/s), 70.5MiB/s-70.5MiB/s (73.9MB/s-73.9MB/s), io=7050MiB (7392MB), run=100005-100005msec				IOPS=4511


顺序读：
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=read -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

READ: bw=181MiB/s (189MB/s), 181MiB/s-181MiB/s (189MB/s-189MB/s), io=10.6GiB (11.4GB), run=60002-60002msec

顺序写：
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=write -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

WRITE: bw=132MiB/s (138MB/s), 132MiB/s-132MiB/s (138MB/s-138MB/s), io=7896MiB (8280MB), run=60003-60003msec

随机读：
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=randread -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

READ: bw=129MiB/s (135MB/s), 129MiB/s-129MiB/s (135MB/s-135MB/s), io=7753MiB (8129MB), run=60004-60004msec

随机写：
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=randwrite -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

混合读写
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=randrw -rwmixread=70 -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=100 -group_reporting -name=mytest1




新盘（107异步）
顺序读：
READ: bw=182MiB/s (191MB/s), 182MiB/s-182MiB/s (191MB/s-191MB/s), io=10.7GiB (11.5GB), run=60004-60004msec						IOPS=11.6k

顺序写：
WRITE: bw=380MiB/s (398MB/s), 380MiB/s-380MiB/s (398MB/s-398MB/s), io=22.3GiB (23.9GB), run=60001-60001msec						IOPS=24.3k


随机读：
READ: bw=76.1MiB/s (79.8MB/s), 76.1MiB/s-76.1MiB/s (79.8MB/s-79.8MB/s), io=4569MiB (4790MB), run=60006-60006msec				IOPS=4872

随机写：
WRITE: bw=44.1MiB/s (46.2MB/s), 44.1MiB/s-44.1MiB/s (46.2MB/s-46.2MB/s), io=2646MiB (2775MB), run=60007-60007msec				IOPS=2822

混合读写：
READ: bw=41.9MiB/s (43.9MB/s), 41.9MiB/s-41.9MiB/s (43.9MB/s-43.9MB/s), io=4191MiB (4395MB), run=100005-100005msec				IOPS=2682
  WRITE: bw=18.0MiB/s (18.9MB/s), 18.0MiB/s-18.0MiB/s (18.9MB/s-18.9MB/s), io=1800MiB (1888MB), run=100005-100005msec			IOPS=1152
  
  


新盘（107同步）
顺序读：
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=read -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

READ: bw=181MiB/s (189MB/s), 181MiB/s-181MiB/s (189MB/s-189MB/s), io=10.6GiB (11.4GB), run=60002-60002msec		IOPS=11.6k

顺序写：
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=write -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

WRITE: bw=132MiB/s (138MB/s), 132MiB/s-132MiB/s (138MB/s-138MB/s), io=7896MiB (8280MB), run=60003-60003msec		IOPS=8422

随机读：
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=randread -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

READ: bw=129MiB/s (135MB/s), 129MiB/s-129MiB/s (135MB/s-135MB/s), io=7753MiB (8129MB), run=60004-60004msec		IOPS=8268

随机写：
fio -filename=/dev/sdc7 -direct=1 -iodepth 1 -thread -rw=randwrite -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=60 -group_reporting -name=mytest

WRITE: bw=21.7MiB/s (22.8MB/s), 21.7MiB/s-21.7MiB/s (22.8MB/s-22.8MB/s), io=1613MiB (1691MB), run=74318-74318msec		IOPS=1388

混合读写
fio -filename=/dev/sdd7 -direct=1 -iodepth 1 -thread -rw=randrw -rwmixread=70 -ioengine=psync -bs=16k -size=1G -numjobs=30 -runtime=100 -group_reporting -name=mytest1

READ: bw=35.0MiB/s (37.7MB/s), 35.0MiB/s-35.0MiB/s (37.7MB/s-37.7MB/s), io=3597MiB (3772MB), run=100006-100006msec			IOPS=2302
 WRITE: bw=15.5MiB/s (16.2MB/s), 15.5MiB/s-15.5MiB/s (16.2MB/s-16.2MB/s), io=1547MiB (1622MB), run=100006-100006msec		IOPS=989

2021-06-24

1、查看磁盘转速
sginfo -g /dev/sdc

2、磁盘型号
华为oceanstor 5110 v5



永久生成core
#vim /etc/profile，然后进入编辑模式，在profile文件中加入
ulimit -c unlimited
保存退出，重启服务器，改文件就长久生效，或者#source /etc/profile，不重启服务器，使用source使文件马上生效。
指定生成文件的路径和名字；执行# vim /etc/sysctl.conf，进入编辑模式，加入下面两行
kernel.core_pattern=/home/uxdb/coreFile/core-%e-%p-%t
kernel.core_uses_pid=1

1：添加pid作为扩展名，生成的core文件名称为core.pid
0：不添加pid作为扩展名，生成的core文件名称为core

sudo sysctl -p /etc/sysctl.conf 使其生效



2021-07-06

高速缓存
1、访问表的模式、列属性、OID、统计信息等
2、模式在系统表中，所以首先访问系统表模式信息（故设立Cache，包含系统表元祖SysCache和表模式信息RelCache，RelCache中存放的是RelationData结构体，每一个RelationData表示一个表模式信息）
SysCache:（CatCache SysCache[64]）
1、SysCache 主要缓存系统表元祖，是一个数组，每个元素是一个CatCache数据结构（每个CatCache对应一个系统表），该结构体内使用Hash存储系统表元祖；
2、CatCache中有若干个查找关键字，用来查找系统表元祖；
3、CatCache通过其cc_next字段构成一个单向链表，其头部用全局变量CacheHdr记录；
4、SysCache.c已经将所有系统表CatCache信息存储在cacheinfo的静态数组中；
5、CatCache中的cc_bucket数组中的每个元素都表示一个Hash桶，

一、SysCache初始化
初始化在InitProgres函数中，初始化主要是填充CatCache的过程（将查找系统表元祖关键字信息写入数组中）；

1、初始化如下：
postgres进程初始化时，会调用InitCatalogCache函数对SysCache数组进行初始化，并建立由CacheHdr记录的CatCache链表。
初始化主要分为以下几步：
1）根据cacheinfo为SysCache数组分配空间；
2）初始化第一阶段
循环调用InitCatchche函数根据cacheinfo生成CatCache结构并放入SysCache数组对应位置。
InitCatchche首先确保CacheMemoryContext存在，然后切换到CacheMemoryContext中；
接下来检查CacheHdr是否存在，不存在则先建立CacheHdr；
然后根据cachedesc中要求的Hash桶数为即将建立的CatCache结构分配内存，并根据cachedesc结构中信息填充CatCache各个字段；

3）初始化第二阶段
RelationCacheInitializePhase2（负责RelCache的初始化）还将调用InitCatcachePhase2进行第二阶段初始化：
InitCatcachePhase2：将依次完善SysCache数组中的CatCache结构；
主要填充CatCache元祖描述符(cc_tupdesc)、系统表名(cc_relname)、查找关键字的相关字段（cc_hashfunc、cc_isname、cc_skey）；

SysCache数组初始化完成后，CatCache内是没有任何元祖的，随着系统运行时对系统表元祖的访问，CatCache中系统表元祖会逐渐增多；

2、CatCache中缓存元祖组织
1）CatCache中的cc_bucket数组中的每个元素都表示一个Hash桶，元祖键值映射到cc_bucket数组下标；
hash桶节点类型Dlelem类型，其dle_val字段指向CatCTup，dle_list用来记录缓存元祖头部；

3、在CatCache中查找元祖
CatCache中查找元祖有两种方式：精准匹配和部分匹配


RelCache

1、插入新打开的表
将RelationData值赋值给reldesc字段；

2、查找Hash表
通过函数hash_search查找，若找到将reldesc字段值赋给RELATION，否则RELATION等于NULL；

3、从Hash表中删除元素




ReadBuffer_common函数介绍：
1、条件

是否扩展：		isExtend
是否临时表：	isLocalBuf
是否已在缓冲池中：found

2、
BufferAlloc：获取共享缓冲区




rac：

问题单验证：
缺陷单验证注意事项：
1、格式
【当前流程】自测
【是否自验通过】Y/N
【自验报告】视频或截图
【转测版本号】v2.1.0.6.01r
【其他信息】如果没验证通过，需要写明错误现象，日志、截图等信息

本地搭建共享存储
1、扩展硬盘
https://jingyan.baidu.com/article/335530da65c0be59ca41c31f.html

2、

iqn.2021-07.com.racshared:server

iqn.2021-07.com.racshared:client1
iqn.2021-07.com.racshared:client2




/home/uxdb/uxdbinstall/dbsql/bin/ux_ctl stop -D /mnt/sd4/racdata -o "-c uxdb_rac=on -c instance_id=1"

/home/uxdb/uxdbinstall/dbsql/bin/ux_ctl stop -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=2"



2021-07-21

输出rac各进程id与对应共享内存段

PostmasterMain
https://www.docin.com/p-477394708.html


1. 设置进程ID
2. 初始化内存池
3. 设置路径、时间等变量
4. 初始化GUC选项，处理输入参数并载入hba和ident
5. 设置共享内存和信号量，初始化共享数据结构
6. 设置信号处理句柄
7. 启动守护进程：
   (1) syslogger：收集其他其他进程的日志输出，写入到文件
   (2) stats daemon：通过UDP获取各backend的运行时统计信息
   (3) autovacuum launcher：定期进行表空间的自动清理
8. 由参数forkboot启动一个backend
9. 绑定到TCP socket，监听连接请求

AuxiliaryProcessMain

记录PID变量：
StartupPID



辅助进程启动：
系统日志：
SysLogger_Start						//2078

其他辅助进程函数入口：
ServerLoop（在监听循环中执行）		//2258

master启动进程：
PostmasterMain			//1218-2268
	SubPostmasterMain

获取共享内存函数：
https://blog.csdn.net/iteye_4537/article/details/82374618?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control

https://www.jianshu.com/p/96d9f6be9913

https://blog.csdn.net/iteye_4537/article/details/82294291
CreateSharedMemoryAndSemaphores
	->UXSharedMemoryCreate
	->cirdSnapShmemInit
各进程相关函数：

reset_shared						//1972：分配共享内存
SysLogger_Start
uxdb      27714  27622  0 20:09 ?        00:00:00 uxdb: logger process

start_controller					//2107
uxdb      33969  33950  0 09:56 ?        00:00:00 uxdb: rac: clusterd-controller process
uxdb      33970  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-evtd process
uxdb      33971  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-nsrd process
uxdb      33972  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-dhbd process
uxdb      33973  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-nhbd process
uxdb      33974  33969  0 09:56 ?        00:00:00 uxdb: rac: clusterd-arbitrator process

start_lrmd						//2130
uxdb      34011  33950  0 09:57 ?        00:00:00 uxdb: rac: lrmd process

start_rac_process				//2141
uxdb      34022  33950  0 09:59 ?        00:00:00 uxdb: rac: message-listen process
uxdb      34023  33950  0 09:59 ?        00:00:00 uxdb: rac: message-send process
uxdb      34024  33950  0 09:59 ?        00:00:00 uxdb: rac: cache sync process
uxdb      34025  33950  0 09:59 ?        00:00:00 uxdb: rac: ges request process   migrating
uxdb      34026  33950  0 09:59 ?        00:00:00 uxdb: rac: ges reply process
uxdb      34027  33950  0 09:59 ?        00:00:00 uxdb: rac: gcs request process   migrating
uxdb      34028  33950  0 09:59 ?        00:00:00 uxdb: rac: gcs reply process
uxdb      34029  33950  0 09:59 ?        00:00:00 uxdb: rac: cluster node recovery process
uxdb      34030  33950  0 09:59 ?        00:00:00 uxdb: rac: cluster sync conf process
uxdb      34031  33950  0 09:59 ?        00:00:00 uxdb: rac: global xactid request services
uxdb      34032  33950  0 09:59 ?        00:00:00 uxdb: rac: pi manager process
ServerLoop
	-》signal_processor				//2988
uxdb      27908  27622  0 20:15 ?        00:00:00 uxdb: rac: global xactid reply services
uxdb      27909  27622  0 20:15 ?        00:00:00 uxdb: checkpointer process
uxdb      27910  27622  0 20:15 ?        00:00:00 uxdb: writer process
uxdb      27911  27622  0 20:15 ?        00:00:00 uxdb: wal writer process
uxdb      27912  27622  0 20:15 ?        00:00:00 uxdb: autovacuum launcher process
uxdb      27913  27622  0 20:15 ?        00:00:00 uxdb: global stats collector process
uxdb      27914  27622  0 20:15 ?        00:00:00 uxdb: stats collector process

ServerLoop 		//3136
uxdb      28015  27622  0 20:21 ?        00:00:00 uxdb: rac: global deadlock detect process

ServerLoop 		//3142
uxdb      28028  27622  0 20:22 ?        00:00:00 uxdb: rac: online recovery process

共享内存开始、结束
	ShmemBase = (void *) shmhdr;
	ShmemEnd = (char *) ShmemBase + shmhdr->totalsize;


ux_ctl解析配置文件：
http://blog.chinaunix.net/uid-30132132-id-4826450.html

https://www.pianshen.com/article/5402466843/
SelectConfigFiles
  ProcessConfigFile
    ProcessConfigFileInternal
      ParseConfigFile
        ParseConfigFp

申请共享内存函数：
ShmemInitStruct

全局变量：
ShmemSegHdr->freeoffset

总大小：
813105152

起始地址：
(gdb) p ShmemBase
$4 = (void *) 0x7f42b17ee000
(gdb) p ShmemEnd
$5 = (void *) 0x7f42e1f5e000

InitShmemAllocation					//freeoffset = 7040，	size = 5376，		ShmemBase = 0x7f42b17efb80

CreateLWLocks						//freeoffset = 12416，	size = 73348，		ShmemBase = 0x7f42b17f1080
primaryMirrorModeShmemInit			//freeoffset = 96000，	size = 5376，		ShmemBase = 0x7f42b1805700
XLOGShmemInit						//freeoffset = 101376，	size1=384			ShmemBase = 0x7f42b1806c00 && 0x7f42b1806d80
CLOGShmemInit
CommitTsShmemInit					//freeoffset = 475136，	size = 128，		ShmemBase = 0x7f42b1862000
SUBTRANSShmemInit					//freeoffset = 475264，	size = 267136，		ShmemBase = 0x7f42b1862080
MultiXactShmemInit					//freeoffset = 742400， size = 66944, 		ShmemBase = 0x7f42b18a3400
InitBufferPool
									1//freeoffset = 944768， size = 90112, 		ShmemBase = 0x7f42b18d4a80
									2//freeoffset = 1034880， size = 8388608, 		ShmemBase = 0x7f42b18eaa80
									3//freeoffset = 9423488， size = 32768, 		ShmemBase = 0x7f42b20eaa80
									4//freeoffset = 9456256， size = 20480, 		ShmemBase = 0x7f42b20f2a80
									5//freeoffset = 9476736， size = 2944, 		ShmemBase = 0x7f42b20f7a80
									6//freeoffset = 9545216， size = 128, 		ShmemBase = 0x7f42b2108600
InitLocks							1//freeoffset = 9545344， size = 2944, 		ShmemBase = 0x7f42b2108680
									2//freeoffset = 10756608， size = 2944, 		ShmemBase = 0x7f42b2230200
									3//freeoffset = 11976064， size = 4224, 		ShmemBase = 0x7f42b2359d80
InitAppendOnlyWriter				1//freeoffset = 11980288， size = 128, 		ShmemBase = 0x7f42b235ae00
									2//freeoffset = 11980416， size = 2944, 		ShmemBase = 0x7f42b235ae80
PersistentFileSysObj_ShmemInit							//freeoffset = 20437504， size = 128, 		ShmemBase = 0x7f42b2b6ba00
PersistentFilespace_ShmemInit							1//freeoffset = 20437632， size = 128, 		ShmemBase = 0x7f42b2b6ba80
														2//freeoffset = 20437760， size = 2944, 		ShmemBase = 0x7f42b2b6bb00
PersistentTablespace_ShmemInit							1//freeoffset = 20459520， size = 128, 		ShmemBase = 0x7f42b2b71000
														2//freeoffset = 20459648， size = 2944, 		ShmemBase = 0x7f42b2b71080
PersistentDatabase_ShmemInit							//freeoffset = 20465408， size = 16000, 		ShmemBase = 0x7f42b2b72700
PersistentRelation_ShmemInit							//freeoffset = 20481408， size = 128, 		ShmemBase = 0x7f42b2b76580
InitPredicateLocks										1//freeoffset = 20481536， size = 2944, 		ShmemBase = 0x7f42b2b76600
														2//freeoffset = 21266816， size = 2944, 		ShmemBase = 0x7f42b2c36180
														3//freeoffset = 23485696， size = 128, 		ShmemBase = 0x7f42b2e53d00
														4//freeoffset = 23808128， size = 2944, 		ShmemBase = 0x7f42b2ea2880
														5//freeoffset = 23911680， size = 128, 		ShmemBase = 0x7f42b2ebbd00
														6//freeoffset = 24420608， size = 128, 		ShmemBase = 0x7f42b2f38100
														7//freeoffset = 24420736， size = 133632, 		ShmemBase = 0x7f42b2f38180
														8//freeoffset = 24554368， size = 128, 		ShmemBase = 0x7f42b2f58b80

InitProcGlobal									//freeoffset = 24554496， size = 128, 		ShmemBase = 0x7f42b2f58c00
CreateSharedProcArray							1//freeoffset = 24735360， size = 896, 		ShmemBase = 0x7f42b2f84e80
												2//freeoffset = 24736256， size = 55168, 		ShmemBase = 0x7f42b2f85200
												3//freeoffset = 24791424， size = 13824, 		ShmemBase = 0x7f42b2f92980
CreateSharedBackendStatus							//freeoffset = 24805248， size = 72832, 		ShmemBase = 0x7f42b2f95f80
													//freeoffset = 24878080， size = 13568, 		ShmemBase = 0x7f42b2fa7c00
													//freeoffset = 24905216， size = 227328, 		ShmemBase = 0x7f42b2fae600
													//freeoffset = 25132544， size = 44416, 		ShmemBase = 0x7f42b2fe5e00
TwoPhaseShmemInit									//freeoffset = 25176960， size = 128, 		ShmemBase = 0x7f42b2ff0b80
BackgroundWorkerShmemInit							//freeoffset = 25177088， size = 3072, 		ShmemBase = 0x7f42b2ff0c00
CreateSharedInvalidationState							//freeoffset = 25180160， size = 72448, 		ShmemBase = 0x7f42b2ff1800
PMSignalShmemInit								//freeoffset = 25252608， size = 2304, 		ShmemBase = 0x7f42b3003300
ProcSignalShmemInit								//freeoffset = 25254912， size = 9856, 		ShmemBase = 0x7f42b3003c00
CheckpointerShmemInit							//freeoffset = 25264768， size = 20608, 		ShmemBase = 0x7f42b3006280
AutoVacuumShmemInit							//freeoffset = 25285376， size = 5376, 		ShmemBase = 0x7f42b300b300
ReplicationSlotsShmemInit							//freeoffset = 25290752， size = 2432, 		ShmemBase = 0x7f42b300c800
ReplicationOriginShmemInit							//freeoffset = 25293184， size = 640, 		ShmemBase = 0x7f42b300d180
WalSndShmemInit										//freeoffset = 25293824， size = 1152, 		ShmemBase = 0x7f42b300d400
WalRcvShmemInit										//freeoffset = 25294976， size = 1280, 		ShmemBase = 0x7f42b300d880
ApplyLauncherShmemInit								//freeoffset = 25296256， size = 512, 		ShmemBase = 0x7f42b300dd80
FileRepResync_ShmemInit								1//freeoffset = 25296768， size = 128, 		ShmemBase = 0x7f42b300df80
													2//freeoffset = 25296896， size = 2944, 		ShmemBase = 0x7f42b300e000
SnapMgrInit											//freeoffset = 25447296， size = 128, 		ShmemBase = 0x7f42b3032b80
BTreeShmemInit											//freeoffset = 25447424， size = 2560, 		ShmemBase = 0x7f42b3032c00
SyncScanShmemInit											//freeoffset = 25449984， size = 768, 		ShmemBase = 0x7f42b3033600
AsyncShmemInit											1//freeoffset = 25450752， size = 3456, 		ShmemBase = 0x7f42b3033900
														2//freeoffset = 25454208， size = 66944, 		ShmemBase = 0x7f42b3034680
workfile_mgr_cache_init								1//freeoffset = 25525248， size = 2944, 		ShmemBase = 0x7f42b3045c00
													2//freeoffset = 25986944， size = 9437440, 		ShmemBase = 0x7f42b30b6780
													3//freeoffset = 35424384， size = 2944, 		ShmemBase = 0x7f42b39b6880
													4//freeoffset = 35442560， size = 128, 		ShmemBase = 0x7f42b39baf80
BackendRandomShmemInit								//无内存
RacShmemInit											1//freeoffset = 35442688， size = 124160, 		ShmemBase = 0x7f42b39bb000
														2//freeoffset = 35566848， size = 45440, 		ShmemBase = 0x7f42b39d9500
														3//freeoffset = 35612288， size = 128, 		ShmemBase = 0x7f42b39e4680
														4//freeoffset = 35612416， size = 45440, 		ShmemBase = 0x7f42b39e4700
														5//freeoffset = 35657856， size = 128, 		ShmemBase = 0x7f42b39ef880
														6//freeoffset = 35657984， size = 45440, 		ShmemBase = 0x7f42b39ef900
														7//freeoffset = 35703424， size = 128, 		ShmemBase = 0x7f42b39faa80
														8//freeoffset = 35703552， size = 45440, 		ShmemBase = 0x7f42b39fab00
														9//freeoffset = 35748992， size = 128, 		ShmemBase = 0x7f42b3a05c80
														10//freeoffset = 35749120， size = 45440, 		ShmemBase = 0x7f42b3a05d00
														11//freeoffset = 35794560， size = 128, 		ShmemBase = 0x7f42b3a10e80
														12//freeoffset = 35794688， size = 45440, 		ShmemBase = 0x7f42b3a10f00
														13//freeoffset = 35840128， size = 128, 		ShmemBase = 0x7f42b3a1c080
														14//freeoffset = 35840256， size = 45440, 		ShmemBase = 0x7f42b3a1c100
														15//freeoffset = 35885696， size = 128, 		ShmemBase = 0x7f42b3a27280
														16//freeoffset = 35885824， size = 45440, 		ShmemBase = 0x7f42b3a27300
														17//freeoffset = 35931264， size = 128, 		ShmemBase = 0x7f42b3a32480
														18//freeoffset = 35931392， size = 45440, 		ShmemBase = 0x7f42b3a32500
														19//freeoffset = 35976832， size = 128, 		ShmemBase = 0x7f42b3a3d680
														20//freeoffset = 35976960， size = 45440, 		ShmemBase = 0x7f42b3a3d700
														21//freeoffset = 36022400， size = 128, 		ShmemBase = 0x7f42b3a48880
														22//freeoffset = 36022528， size = 45440, 		ShmemBase = 0x7f42b3a48900
														23//freeoffset = 36067968， size = 128, 		ShmemBase = 0x7f42b3a53a80
														24//freeoffset = 36068096， size = 45440, 		ShmemBase = 0x7f42b3a53b00
														25//freeoffset = 36113536， size = 128, 		ShmemBase = 0x7f42b3a5ec80
														26//freeoffset = 36113664， size = 45440, 		ShmemBase = 0x7f42b3a5ed00
														27//freeoffset = 36113664， size = 45440, 		ShmemBase = 0x7f42b3a5ed00
						InitVacWorkerResponseQueue				28//freeoffset = 760029056， size = 256, 		ShmemBase = 0x7f42decbff80
																29//freeoffset = 760029312， size = 143360, 		ShmemBase = 0x7f42decc0080
XidDispatcherInstNumShmemInit							//freeoffset = 793446144， size = 128, 		ShmemBase = 0x7f42e0c9e700
lrmdChashShmemInit										1//freeoffset = 793446272， size = 551168, 		ShmemBase = 0x7f42e0c9e780
														2//freeoffset = 793997440， size = 551168, 		ShmemBase = 0x7f42e0d25080
														3//freeoffset = 794548608， size = 128, 		ShmemBase = 0x7f42e0dab980
														4//freeoffset = 794548736， size = 128, 		ShmemBase = 0x7f42e0daba00
cirdSnapShmemInit										//freeoffset = 794548864， size = 3456, 		ShmemBase = 0x7f42e0daba80
evtdShmemInit											//freeoffset = 794552320， size = 512, 		ShmemBase = 0x7f42e0dac800
commShmemInit											//freeoffset = 794552832， size = 128, 		ShmemBase = 0x7f42e0daca00

申请空间大小
 UXSemaphoreShmemSize(numSemas);														//6976
 SpinlockSemaSize();																	//0
 hash_estimate_size(SHMEM_INDEX_SIZE, sizeof(ShmemIndexEnt));							//13112
 BufferShmemSize();																	//8598464
 LockShmemSize();																		//5341353
 PredicateLockShmemSize();																//4377564
 ProcGlobalShmemSize();																//180601
 XLOGShmemSize();																		//273336
 CLOGShmemSize();																		//66272
 CommitTsShmemSize();																	//33536
 SUBTRANSShmemSize();																	//267040
 TwoPhaseShmemSize();																	//16
 BackgroundWorkerShmemSize();															//2960
 MultiXactShmemSize();																	//202196
 LWLockShmemSize();																	//73348
 ProcArrayShmemSize();																	//69788
 BackendStatusShmemSize();																//372960
 SInvalShmemSize();																	//72344
 PMSignalShmemSize();																	//2272
 ProcSignalShmemSize();																//9768
 CheckpointerShmemSize();																//20520
 AutoVacuumShmemSize();																//5344
 ReplicationSlotsShmemSize();															//2400
 ReplicationOriginShmemSize();															//568
 WalSndShmemSize();																	//1040
 WalRcvShmemSize();																	//1192
 ApplyLauncherShmemSize();																//424
 SnapMgrShmemSize();																	//68
 BTreeShmemSize();																		//2556
 SyncScanShmemSize();																	//656
 AsyncShmemSize();																		//70280
 BackendRandomShmemSize();																//0
 PersistentFileSysObj_ShmemSize();														//8
 PersistentFilespace_ShmemSize();														//134952
 PersistentTablespace_ShmemSize();														//7016
 PersistentDatabase_ShmemSize();														//15952
 PersistentRelation_ShmemSize();														//48
 workfile_mgr_shmem_size();															//9935008
 primaryMirrorModeShmemSize();															//5280
 AppendOnlyWriterShmemSize();															//9443249
 FileRepResync_ShmemSize(); 															//199304
 RacShmemSize();																		//772087056
 sizeof(int); 																			//4
lrmdShmemSize();																		//1102352
 cirdSnapShmemSize();		 															//3456
evtdShmemSize();																		//512
commShmemSize();																		//8


初始化实际大小：
ShmemSegHdr->freeoffset = 56
UXReserveSemaphores(numSemas, port);							//6976			ShmemSegHdr->freeoffset=7032
InitShmemAllocation();											//5,384										12416
CreateLWLocks();												//73,472										85888
InitShmemIndex();												//10,112										96000
primaryMirrorModeShmemInit();									//5,376										101376
XLOGShmemInit();												//273,920										375296
CLOGShmemInit();												//66,304										441600
CommitTsShmemInit();											//33,664										475264
SUBTRANSShmemInit();											//267,136										742400
MultiXactShmemInit();											202,368										944768
InitBufferPool();												8,600,576										9545344
InitLocks();													2,434,944										11980288
InitAppendOnlyWriter();											8,457,216										20437504
PersistentFileSysObj_ShmemInit();									128									20437632
PersistentFilespace_ShmemInit();								21,888										20459520
PersistentTablespace_ShmemInit();								5,888										20465408
PersistentDatabase_ShmemInit();									16,000										20481408
PersistentRelation_ShmemInit();									128											20481536

InitPredicateLocks();											4,072,960									24554496
InitProcGlobal();												180,864										24735360
CreateSharedProcArray();										69,888										24805248
CreateSharedBackendStatus();									371,712										25176960
TwoPhaseShmemInit();											128											25177088
BackgroundWorkerShmemInit();									3,072										25180160
CreateSharedInvalidationState();								72,448										25252608
PMSignalShmemInit();											2,304										25254912
ProcSignalShmemInit();											9,856										25264768
CheckpointerShmemInit();										20,608										25285376
AutoVacuumShmemInit();											5,376										25290752
ReplicationSlotsShmemInit();									2,432										25293184
ReplicationOriginShmemInit();									640										25293824
WalSndShmemInit();												1,152										25294976
WalRcvShmemInit();												1,280										25296256
ApplyLauncherShmemInit();										512										25296768
FileRepResync_ShmemInit();										150,528										25447296
SnapMgrInit();													128										25447424
BTreeShmemInit();												2,560										25449984
SyncScanShmemInit();											768										25450752
AsyncShmemInit();												70,400										25521152
workfile_mgr_cache_init();										9,921,536										35442688
BackendRandomShmemInit();										0										35442688
RacShmemInit();													758,003,456										793446144

XidDispatcherInstNumShmemInit();								128										793446272
lrmdChashShmemInit();											1,102,592										794548864
cirdSnapShmemInit();											3,456										794552320
evtdShmemInit();												512										794552832
commShmemInit();												128										794552960


代码修改：
共享内存：

void
GetshmemSize(TupOutputState *tstate, char *name, int applysize, const char *initsize)
{
	Datum			values[3];
	bool			isnull[3] = {false, false, false};
	char        	value_text[256];

	values[0] = PointerGetDatum(cstring_to_text(name));
	memset(value_text, 0, sizeof(value_text));

	snprintf(value_text, sizeof(value_text) - 1, "%u", applysize);
	values[1] = PointerGetDatum(cstring_to_text(value_text));

	values[2] = PointerGetDatum(cstring_to_text(initsize));
	do_tup_output(tstate, values, isnull);
	pfree(DatumGetPointer(values[0]));
	pfree(DatumGetPointer(values[1]));
	pfree(DatumGetPointer(values[2]));

}

static void
ShowShmemSize(DestReceiver *dest)
{

	TupOutputState *tstate;
	TupleDesc	tupdesc;
	int			numSemas;
	int all_shmem_size[48] = {0};

	/* need a tuple descriptor representing three TEXT columns */
	tupdesc = CreateTemplateTupleDesc(3, false);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 1, "name",
							  TEXTOID, -1, 0);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 2, "applysize",
							  TEXTOID, -1, 0);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 3, "realsize",
							  TEXTOID, -1, 0);



	numSemas = ProcGlobalSemas();
	numSemas += SpinlockSemas();
	all_shmem_size[0] = UXSemaphoreShmemSize(numSemas);
	all_shmem_size[1] =  SpinlockSemaSize();
	all_shmem_size[2] =  hash_estimate_size(SHMEM_INDEX_SIZE, sizeof(ShmemIndexEnt));
	all_shmem_size[3] =  BufferShmemSize();
	all_shmem_size[4] =  LockShmemSize();
	all_shmem_size[5] =  PredicateLockShmemSize();
	all_shmem_size[6] =  ProcGlobalShmemSize();
	all_shmem_size[7] =  XLOGShmemSize();

	all_shmem_size[8] =  CLOGShmemSize();
	all_shmem_size[9] =  CommitTsShmemSize();
	all_shmem_size[10] =  SUBTRANSShmemSize();
	all_shmem_size[11] =  TwoPhaseShmemSize();
	all_shmem_size[12] =  BackgroundWorkerShmemSize();
	all_shmem_size[13] =  MultiXactShmemSize();
	all_shmem_size[14] =  LWLockShmemSize();
	all_shmem_size[15] =  ProcArrayShmemSize();
	all_shmem_size[16] =  BackendStatusShmemSize();
	all_shmem_size[17] =  SInvalShmemSize();
	all_shmem_size[18] =  PMSignalShmemSize();
	all_shmem_size[19] =  ProcSignalShmemSize();
	all_shmem_size[20] =  CheckpointerShmemSize();
	all_shmem_size[21] =  AutoVacuumShmemSize();
	all_shmem_size[22] =  ReplicationSlotsShmemSize();
	all_shmem_size[23] =  ReplicationOriginShmemSize();
	all_shmem_size[24] =  WalSndShmemSize();
	all_shmem_size[25] =  WalRcvShmemSize();
	all_shmem_size[26] =  ApplyLauncherShmemSize();
	all_shmem_size[27] =  SnapMgrShmemSize();
	all_shmem_size[28] =  BTreeShmemSize();
	all_shmem_size[29] =  SyncScanShmemSize();
	all_shmem_size[30] =  AsyncShmemSize();
	all_shmem_size[31] =  BackendRandomShmemSize();
	all_shmem_size[32] =  PersistentFileSysObj_ShmemSize();
	all_shmem_size[33] =  PersistentFilespace_ShmemSize();
	all_shmem_size[34] =  PersistentTablespace_ShmemSize();
	all_shmem_size[35] =  PersistentDatabase_ShmemSize();
	all_shmem_size[36] =  PersistentRelation_ShmemSize();
	all_shmem_size[37] =  workfile_mgr_shmem_size();
	all_shmem_size[38] =  primaryMirrorModeShmemSize();
	all_shmem_size[39] =  AppendOnlyWriterShmemSize();
	all_shmem_size[40] =  FileRepResync_ShmemSize();
	all_shmem_size[41] =  RacShmemSize();
	all_shmem_size[42] =  sizeof(int);
	all_shmem_size[43] =  lrmdShmemSize();
	all_shmem_size[44] =  cirdSnapShmemSize();
	all_shmem_size[45] =  evtdShmemSize();
	all_shmem_size[46] =  commShmemSize();
	/* prepare for projection of tuples */
	tstate = begin_tup_output_tupdesc(dest, tupdesc);



	/* assign to the values array */
	GetshmemSize(tstate, "UXSemaphoreShmemSize", all_shmem_size[0], "6976");
	GetshmemSize(tstate, "SpinlockSemaSize", all_shmem_size[1], "0");
	GetshmemSize(tstate, "hash_estimate_size", all_shmem_size[2], "10112");
	GetshmemSize(tstate, "BufferShmemSize", all_shmem_size[3], "8600576");
	GetshmemSize(tstate, "LockShmemSize", all_shmem_size[4], "2434944");
	GetshmemSize(tstate, "PredicateLockShmemSize", all_shmem_size[5], "4072960");
	GetshmemSize(tstate, "ProcGlobalShmemSize", all_shmem_size[6], "180864");
	GetshmemSize(tstate, "XLOGShmemSize", all_shmem_size[7], "273920");
	GetshmemSize(tstate, "CLOGShmemSize", all_shmem_size[8], "66304");
	GetshmemSize(tstate, "CommitTsShmemSize", all_shmem_size[9], "33664");
	GetshmemSize(tstate, "SUBTRANSShmemSize", all_shmem_size[10], "267136");
	GetshmemSize(tstate, "TwoPhaseShmemSize", all_shmem_size[11], "128");
	GetshmemSize(tstate, "BackgroundWorkerShmemSize", all_shmem_size[12], "3072");
	GetshmemSize(tstate, "MultiXactShmemSize", all_shmem_size[13], "202368");
	GetshmemSize(tstate, "LWLockShmemSize", all_shmem_size[14], "73472");
	GetshmemSize(tstate, "ProcArrayShmemSize", all_shmem_size[15], "69888");
	GetshmemSize(tstate, "BackendStatusShmemSize", all_shmem_size[16], "371712");
	GetshmemSize(tstate, "SInvalShmemSize", all_shmem_size[17], "72448");
	GetshmemSize(tstate, "PMSignalShmemSize", all_shmem_size[18], "2304");
	GetshmemSize(tstate, "ProcSignalShmemSize", all_shmem_size[19], "9856");
	GetshmemSize(tstate, "CheckpointerShmemSize", all_shmem_size[20], "20608");
	GetshmemSize(tstate, "AutoVacuumShmemSize", all_shmem_size[21], "5376");
	GetshmemSize(tstate, "ReplicationSlotsShmemSize", all_shmem_size[22], "2432");
	GetshmemSize(tstate, "ReplicationOriginShmemSize", all_shmem_size[23], "640");
	GetshmemSize(tstate, "WalSndShmemSize", all_shmem_size[24], "1152");
	GetshmemSize(tstate, "WalRcvShmemSize", all_shmem_size[25], "1280");
	GetshmemSize(tstate, "ApplyLauncherShmemSize", all_shmem_size[26], "512");
	GetshmemSize(tstate, "SnapMgrShmemSize", all_shmem_size[27], "128");
	GetshmemSize(tstate, "BTreeShmemSize", all_shmem_size[28], "2560");
	GetshmemSize(tstate, "SyncScanShmemSize", all_shmem_size[29], "768");
	GetshmemSize(tstate, "AsyncShmemSize", all_shmem_size[30], "70400");
	GetshmemSize(tstate, "BackendRandomShmemSize", all_shmem_size[31], "0");
	GetshmemSize(tstate, "PersistentFileSysObj_ShmemSize", all_shmem_size[32], "128");
	GetshmemSize(tstate, "PersistentFilespace_ShmemSize", all_shmem_size[33], "21888");
	GetshmemSize(tstate, "PersistentTablespace_ShmemSize", all_shmem_size[34], "5888");
	GetshmemSize(tstate, "PersistentDatabase_ShmemSize", all_shmem_size[35], "16000");
	GetshmemSize(tstate, "PersistentRelation_ShmemSize", all_shmem_size[36], "128");
	GetshmemSize(tstate, "workfile_mgr_shmem_size", all_shmem_size[37], "9921536");
	GetshmemSize(tstate, "primaryMirrorModeShmemSize", all_shmem_size[38], "5376");
	GetshmemSize(tstate, "AppendOnlyWriterShmemSize", all_shmem_size[39], "8457216");
	GetshmemSize(tstate, "FileRepResync_ShmemSize", all_shmem_size[40], "150528");
	GetshmemSize(tstate, "RacShmemSize", all_shmem_size[41], "758003456");
	GetshmemSize(tstate, "pXidDispatcherInstNum", all_shmem_size[42], "128");
	GetshmemSize(tstate, "lrmdShmemSize", all_shmem_size[43], "1102592");
	GetshmemSize(tstate, "cirdSnapShmemSize", all_shmem_size[44], "3456");
	GetshmemSize(tstate, "evtdShmemSize", all_shmem_size[45], "512");
	GetshmemSize(tstate, "commShmemSize", all_shmem_size[46], "128");


	end_tup_output(tstate);
}

内存大小写死：

void
GetshmemSize(TupOutputState *tstate, const char *name, const char *applysize, const char *initsize)
{
	Datum			values[3];
	bool			isnull[3] = {false, false, false};

	values[0] = PointerGetDatum(cstring_to_text(name));

	values[1] = PointerGetDatum(cstring_to_text(applysize));

	values[2] = PointerGetDatum(cstring_to_text(initsize));
	do_tup_output(tstate, values, isnull);
	pfree(DatumGetPointer(values[0]));
	pfree(DatumGetPointer(values[1]));
	pfree(DatumGetPointer(values[2]));

}

static void
ShowShmemSize(DestReceiver *dest)
{

	TupOutputState *tstate;
	TupleDesc	tupdesc;

	/* need a tuple descriptor representing three TEXT columns */
	tupdesc = CreateTemplateTupleDesc(3, false);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 1, "name",
							  TEXTOID, -1, 0);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 2, "applysize",
							  TEXTOID, -1, 0);
	TupleDescInitBuiltinEntry(tupdesc, (AttrNumber) 3, "realsize",
							  TEXTOID, -1, 0);

	/* prepare for projection of tuples */
	tstate = begin_tup_output_tupdesc(dest, tupdesc);



	/* assign to the values array */
	GetshmemSize(tstate, "UXSemaphoreShmemSize", "6976", "6976");
	GetshmemSize(tstate, "SpinlockSemaSize", "0", "0");
	GetshmemSize(tstate, "hash_estimate_size", "13112", "10112");
	GetshmemSize(tstate, "BufferShmemSize", "8598464", "8600576");
	GetshmemSize(tstate, "LockShmemSize", "5341353", "2434944");
	GetshmemSize(tstate, "PredicateLockShmemSize", "4377564", "4072960");
	GetshmemSize(tstate, "ProcGlobalShmemSize", "180601", "180864");
	GetshmemSize(tstate, "XLOGShmemSize", "273336", "273920");
	GetshmemSize(tstate, "CLOGShmemSize", "66272", "66304");
	GetshmemSize(tstate, "CommitTsShmemSize", "33536", "33664");
	GetshmemSize(tstate, "SUBTRANSShmemSize", "267040", "267136");
	GetshmemSize(tstate, "TwoPhaseShmemSize", "16", "128");
	GetshmemSize(tstate, "BackgroundWorkerShmemSize", "2960", "3072");
	GetshmemSize(tstate, "MultiXactShmemSize", "202196", "202368");
	GetshmemSize(tstate, "LWLockShmemSize", "73348", "73472");
	GetshmemSize(tstate, "ProcArrayShmemSize", "69788", "69888");
	GetshmemSize(tstate, "BackendStatusShmemSize", "372960", "371712");
	GetshmemSize(tstate, "SInvalShmemSize", "72344", "72448");
	GetshmemSize(tstate, "PMSignalShmemSize", "2272", "2304");
	GetshmemSize(tstate, "ProcSignalShmemSize", "9768", "9856");
	GetshmemSize(tstate, "CheckpointerShmemSize", "20520", "20608");
	GetshmemSize(tstate, "AutoVacuumShmemSize", "5344", "5376");
	GetshmemSize(tstate, "ReplicationSlotsShmemSize", "2400", "2432");
	GetshmemSize(tstate, "ReplicationOriginShmemSize", "568", "640");
	GetshmemSize(tstate, "WalSndShmemSize", "1040", "1152");
	GetshmemSize(tstate, "WalRcvShmemSize", "1192", "1280");
	GetshmemSize(tstate, "ApplyLauncherShmemSize", "424", "512");
	GetshmemSize(tstate, "SnapMgrShmemSize", "68", "128");
	GetshmemSize(tstate, "BTreeShmemSize", "2556", "2560");
	GetshmemSize(tstate, "SyncScanShmemSize", "656", "768");
	GetshmemSize(tstate, "AsyncShmemSize", "70280", "70400");
	GetshmemSize(tstate, "BackendRandomShmemSize", "0", "0");
	GetshmemSize(tstate, "PersistentFileSysObj_ShmemSize", "8", "128");
	GetshmemSize(tstate, "PersistentFilespace_ShmemSize", "134952", "21888");
	GetshmemSize(tstate, "PersistentTablespace_ShmemSize", "7016", "5888");
	GetshmemSize(tstate, "PersistentDatabase_ShmemSize", "15952", "16000");
	GetshmemSize(tstate, "PersistentRelation_ShmemSize", "48", "128");
	GetshmemSize(tstate, "workfile_mgr_shmem_size", "9935008", "9921536");
	GetshmemSize(tstate, "primaryMirrorModeShmemSize", "5280", "5376");
	GetshmemSize(tstate, "AppendOnlyWriterShmemSize", "9443249", "8457216");
	GetshmemSize(tstate, "FileRepResync_ShmemSize", "199304", "150528");
	GetshmemSize(tstate, "RacShmemSize", "772087056", "758003456");
	GetshmemSize(tstate, "pXidDispatcherInstNum", "4", "128");
	GetshmemSize(tstate, "lrmdShmemSize", "1102352", "1102592");
	GetshmemSize(tstate, "cirdSnapShmemSize", "3456", "3456");
	GetshmemSize(tstate, "evtdShmemSize", "512", "512");
	GetshmemSize(tstate, "commShmemSize", "8", "128");


	end_tup_output(tstate);
}
加log打印
ereport(LOG, (errmsg("successfully leave service_group_isready: group_id:%d wait_count:%d processed_count:%d success_count:%d fatal_count:%d failed_count:%d",
	    group_id, wait_count, processed_count, success_count, fatal_count, failed_count)));


gb18030代码移植：

91121

/* Begin add by QiWang for #116109 at 2021/08/11 reviewer:wangbocai*/
/* End add by QiWang for #116109 at 2021/08/11 reviewer:wangbocai*/
/* Begin modify by QiWang for #116109 at 2021/08/11 reviewer:wangbocai*/
/* End modify by QiWang for #116109 at 2021/08/11 reviewer:wangbocai*/

zh_CN.UTF-8
set client_encoding=GB18030;
set client_encoding=GBK;
set client_encoding=UTF8;

create table t1(sno integer, sname character(10),sage integer,ssex character(10));
create table t2(sno integer, sname character(10),sage integer,ssex character(10));

insert into t1 values('1005', '张三', 16, '男');
insert into t1 values('1005', '陈武', 16, '男');
insert into t1 values('1005', '李四', 16, '男');
insert into t1 values('1005', '王麻子', 16, '男');
insert into t2 values('1003', '李丽', 16, '女');
select * from t1;

select * from t1 where sname='李四';
select * from t1 order by sname;

export LANG=zh_CN.GB18030

select * from t1;
insert into t1 values('1005', '李丽', 18, '女');
select * from t1;

select * from t1 where sname like '李%';

select * from t1 INNER JOIN t2 ON t1.sname = t2.sname;
select * from t1 LEFT JOIN t2 ON t1.sname = t2.sname;
select * from t1 cross join t2;
select * from t1 RIGHT JOIN t2 ON t1.sname = t2.sname;


该功能主要获取共享申请大小，以及共享内存实际使用大小：
共享内存获取接口CreateSharedMemoryAndSemaphores，函数功能：
调用多个sizeof计算需要共享内存大小， 然后通过ShmemInitStruct申请实际共享内存，实际申请内存通过ShmemAlloc去申请，
具体通过ShmemSegHdr->freeoffset全局变量获取；
故该函数主要实现获取共享内存大小，以及申请内存;
修改方案：
添加关键字SHMEMSIZE，添加语法SHOW ALL SHMEMSIZE显示共享内存获取信息，也可以通过show shmem_size;
分别获取sizeof申请的内存字节大小到all_shmem_size数组，获取ShmemInitStruct实际共享内存到init_shmem_size数组中，
将数组信息填充到对应元祖中；

通过SHOW ALL SHMEMSIZE显示共享内存获取信息，也可以通过show shmem_size;获取

使用方法：
前提：启动数据库集群；
登录客户端，执行sql命令：
show shmem_size;

登录后会显示三列数据，分别是内存申请名称name、内存获取大小applysize，内存实际申请大小initsize；




initdb初始化：

初始化数据集簇包括创建数据目录（模板数据库template1和template0、默认用户数据库uxdb）、配置文件（uxsino.conf等）、控制文件（ux_control文件）；

1、以后用户创建数据库，template1数据库都会拷贝过来，template0和uxdb都是从template1拷贝的；
2、数据库对应文件目录：在PFDATA/base里都对应有一个子目录，目录名对应ux_database里的oid；
3、表和索引：表和索引也以oid命名文件放在数据库目录下，表、索引oid对应ux_class对应元祖的relfilenode属性中；
4、initdb使用：
1）、通过uxdb进入bootstrap模式创建数据集簇，并读取后端接口uxdb.bki文件创建模板数据库template1；
5、bki文件生成：
src/backend/catalog目录下的genbki.sh通过读取src/include/catalog目录下以.h结尾的系统表定义文件创建；
ux_*.h头文件中包含内容：
1）定义CATALOG宏；
2）通过宏DATA(x)和DESCR(x)来定义insert操作，用于定义系统表初始数据；


链接：
https://blog.csdn.net/weixin_34405354/article/details/86110204

1、getopt_long
该函数除了获取参数外，就是给全局变量optarg 赋值

2、effective_user = get_id();
获取此程序用户名称（防止用root运行）

3、setup_locale_encoding

设置服务器编码

4、initialize_data_directory
set_null_conf：成了一个 空的 postgresql.conf文件
test_config_settings：
是给出 max_connections 参数和 shared_buffers参数，带给postgres，让它执行，试探出最大允许的max_connections 和 shared_buffers参数。
setup_config：
确定各种参数，分别写入 postgresql.conf 、pg_hba.conf、pg_indent.conf 文件
bootstrap_template1：跑bki文件创建template1数据库

write_version_file：就是在base/1目录下，生成一个  PG_VERSION 文件
setup_auth：
setup_description：就是要把 share/postgres.description 文件的内容读入到 pg_description 和 pg_shdescription
setup_collation：其实质就是，向 pg_collation 表中插入数据
setup_conversion：传递参数：/home/pgsql/project/share/conversion_create.sql
setup_dictionary：dictionary_file 是：/home/pgsql/project/share/snowball_create.sql
setup_schema：
实质就是创建info_schema。
infor_schem_file是：/home/pgsql/project/share/information_schema.sql

load_pluxsql：
就是让postgres 执行 create extension plpgsql；

vacuum_db：
其目的很明确，就是 对 template1 数据库执行
ANALYZE;
VACUUM FULL;
VACUUM FREEZE;

create_tupleid_sequence：支持tupleid

make_template0：创建template0数据库
make_uxdb：创建uxdb数据库



















2021-08-04
初始化审计：
init_audit

rac版：
#0  _UX_init () at uxaudit.c:1824
#1  0x0000000000aab236 in internal_load_library (libname=0xa7bba78 "/home/uxdb/uxdbinstall/dbsql/lib/uxaudit.so") at dfmgr.c:281
#2  0x0000000000aaac98 in load_external_function (filename=0xa7c98d8 "$libdir/uxaudit",
    funcname=0xa7c9cd8 "uxaudit_ddl_command_end", signalNotFound=1 '\001', filehandle=0x7fff2ec29300) at dfmgr.c:105
#3  0x00000000005eb490 in fmgr_c_validator (fcinfo=0x7fff2ec29350) at ux_proc.c:819
#4  0x0000000000aae781 in OidFunctionCall1Coll (functionId=2247, collation=0, arg1=13243) at fmgr.c:1332
#5  0x00000000005eb12b in ProcedureCreate (procedureName=0xa7c48d8 "uxaudit_ddl_command_end", procNamespace=2200,
    replace=0 '\000', returnsSet=0 '\000', returnType=3838, proowner=10, languageObjectId=13, languageValidator=2247,
    prosrc=0xa7c8f00 "uxaudit_ddl_command_end", probin=0xa7c8ee0 "$libdir/uxaudit", isAgg=0 '\000', isWindowFunc=0 '\000',
    security_definer=0 '\000', isLeakProof=0 '\000', isStrict=0 '\000', volatility=118 'v', parallel=117 'u',
    parameterTypes=0xa7c98a8, allParameterTypes=0, parameterModes=0, parameterNames=0, parameterDefaults=0x0, trftypes=0,
    proconfig=0, procost=1, prorows=0) at ux_proc.c:722
#6  0x000000000069fb78 in CreateFunction (pstate=0xa7c4798, stmt=0xa7c04a0) at functioncmds.c:1083
#7  0x000000000093b1e3 in ProcessUtilitySlow (pstate=0xa7c4798, pstmt=0xa7c63a8,
    queryString=0xa7c5140 "/* uxaudit/uxaudit--1.2.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE FUNCTION uxaudit_ddl_command_end()\n\tRETURNS event_trigger\n\tLANGUAGE C\n\tAS '$libdir/u"...,
    context=PROCESS_UTILITY_QUERY, params=0x0, queryEnv=0x0, dest=0x8c90c20 <donothingDR>, completionTag=0x0) at utility.c:1682
#8  0x000000000093a28a in standard_ProcessUtility (pstmt=0xa7c63a8,
    queryString=0xa7c5140 "/* uxaudit/uxaudit--1.2.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE FUNCTION uxaudit_ddl_command_end()\n\tRETURNS event_trigger\n\tLANGUAGE C\n\tAS '$libdir/u"...,
    context=PROCESS_UTILITY_QUERY, params=0x0, queryEnv=0x0, dest=0x8c90c20 <donothingDR>, completionTag=0x0) at utility.c:1030
#9  0x000000000093924e in ProcessUtility (pstmt=0xa7c63a8,
    queryString=0xa7c5140 "/* uxaudit/uxaudit--1.2.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE FUNCTION uxaudit_ddl_command_end()\n\tRETURNS event_trigger\n\tLANGUAGE C\n\tAS '$libdir/u"...,
    context=PROCESS_UTILITY_QUERY, params=0x0, queryEnv=0x0, dest=0x8c90c20 <donothingDR>, completionTag=0x0) at utility.c:360
#10 0x0000000000694308 in execute_sql_string (
    sql=0xa7c5140 "/* uxaudit/uxaudit--1.2.sql */\n\n-- complain if script is sourced in psql, rather than via CREATE EXTENSION\n\n\nCREATE FUNCTION uxaudit_ddl_command_end()\n\tRETURNS event_trigger\n\tLANGUAGE C\n\tAS '$libdir/u"...,
    filename=0xa7bffb8 "/home/uxdb/uxdbinstall/dbsql/share/extension/uxaudit--1.2.sql") at extension.c:763
#11 0x00000000006947d8 in execute_extension_script (extensionOid=13242, control=0xa7c0608, from_version=0x0,
    version=0xa7c06d8 "1.2", requiredSchemas=0x0, schemaName=0xa7c05f0 "public", schemaOid=2200) at extension.c:924
#12 0x00000000006956f6 in CreateExtensionInternal (extensionName=0xa79c290 "uxaudit", schemaName=0xa7c05f0 "public",
    versionName=0xa7c06d8 "1.2", oldVersionName=0x0, cascade=0 '\000', parents=0x0, is_create=1 '\001') at extension.c:1529
#13 0x0000000000695eca in CreateExtension (pstate=0xa7bb778, stmt=0xa79c2a8) at extension.c:1718
#14 0x000000000093af33 in ProcessUtilitySlow (pstate=0xa7bb778, pstmt=0xa79c358,
    queryString=0xa79b888 "create extension uxaudit;\n", context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0,
    dest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "") at utility.c:1579
---Type <return> to continue, or q <return> to quit---
#15 0x000000000093a28a in standard_ProcessUtility (pstmt=0xa79c358, queryString=0xa79b888 "create extension uxaudit;\n",
    context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "")
    at utility.c:1030
#16 0x000000000093924e in ProcessUtility (pstmt=0xa79c358, queryString=0xa79b888 "create extension uxaudit;\n",
    context=PROCESS_UTILITY_TOPLEVEL, params=0x0, queryEnv=0x0, dest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "")
    at utility.c:360
#17 0x000000000093839c in PortalRunUtility (portal=0xa7b7758, pstmt=0xa79c358, isTopLevel=1 '\001', setHoldSnapshot=0 '\000',
    dest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "") at uxsqluery.c:1179
#18 0x0000000000938596 in PortalRunMulti (portal=0xa7b7758, isTopLevel=1 '\001', setHoldSnapshot=0 '\000',
    dest=0x8c90c60 <debugtupDR>, altdest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "") at uxsqluery.c:1325
#19 0x0000000000937ad0 in PortalRun (portal=0xa7b7758, count=9223372036854775807, isTopLevel=1 '\001', run_once=1 '\001',
    dest=0x8c90c60 <debugtupDR>, altdest=0x8c90c60 <debugtupDR>, completionTag=0x7fff2ec2ac50 "") at uxsqluery.c:799
#20 0x0000000000931243 in exec_simple_query (query_string=0xa79b888 "create extension uxaudit;\n") at uxdb.c:1156
#21 0x0000000000935dee in UxdbMain (argc=7, argv=0xa6d5990, dbname=0xa6f7ce0 "uxdb", username=0xa6db3e0 "uxdb") at uxdb.c:4351
#22 0x000000000077aa2d in main (argc=7, argv=0xa6d5990) at main.c:235



标准版：
#0  _UX_init () at uxaudit.c:1846
#1  0x0000000000a5db51 in internal_load_library (libname=0x10cae80 "/home/uxdb/uxdbinstall/dbsql/lib/uxaudit.so")
    at dfmgr.c:349
#2  0x0000000000a5d63d in load_file (filename=0x108c2f8 "uxaudit", restricted=false) at dfmgr.c:187
#3  0x0000000000a69f92 in load_libraries (libraries=0x10acbd0 "uxaudit", gucname=0xd110ed "shared_preload_libraries",
    restricted=false, pluginname=0x0) at miscinit.c:1680
#4  0x0000000000a6a057 in process_shared_preload_libraries (extensionName=0x0) at miscinit.c:1699
#5  0x00000000008ec8a0 in UxdbMain (argc=7, argv=0x108c000, dbname=0x10ad4a0 "uxdb", username=0x1091990 "uxdb")
    at uxdb.c:4172
#6  0x000000000076f770 in main (argc=7, argv=0x108c000) at main.c:292

shared_preload_libraries


PostmasterMain
	SysLogger_Start
	Log_destination

审计功能移植：
40909

alter system set log_destination = 'csvlog';

init_audit
uxdb_config_auto_file
uxsinodb.auto.conf
ux_data
sprintf(autodestfile, "%s/%s", ux_data, "ux_template/uxsinodb.auto.conf");
regular_copy_file
PostmasterMain

DataDir

2021-08-09

1、
%s. epoll_add. group_id:%d start_id:%d  cidx:%d pid:%d eventfd:%d service_state:%d
循环告警：
WARNING:  grd: lrm is frozen

ResetLoadlibrary



2021-08-13

./ux_ctl -D uxdb_rac -o "-c uxdb_rac=on -c instance_id=1 -p 5432"

1、32

15:43:51,678 [main] INFO   jTPCC : Term-00,    Term-00, Running Average tpmTOTAL: 3425115:48:52,036 [Thread-17] INFO   jTPCC : Term-00, e: 285MB / 1461MB                     15:48:52,037 [Thread-17] INFO   jTPCC : Term-00,
15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 153953.7
15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Measured tpmTOTAL = 342362.26         15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Session Start     = 2021-08-13 15:43:51
15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Session End       = 2021-08-13 15:48:52
15:48:52,037 [Thread-17] INFO   jTPCC : Term-00, Transaction Count = 1712632

2、128

2021-08-17

work_mem：越大排序速度越快
effective_cache_size：是postgresql能够使用的最大缓存
maintenance_work_mem：这里定义的内存只是在CREATE INDEX, VACUUM等时用到，一般设置512M







数据库初始化时间：
2021-08-18 06:41:53.478
2021-08-18 06:47:30.997
tpcc加载时间：
2021-08-19 10:10:49.668

tpcc执行时间：
09:45:17,458

tpcc任务：
B) DIO在共享存储的增长率 (102,101,105 使用万兆网卡)
    1. DIO单实例在共享存储与本地磁盘(SSD)上性能比对
        TPCC： 执行 五分钟  terminal 64,96
     收集cpu<用户， 系统> 与 存储的网络状况 与火焰图；统计数据块请求消息
  2. 两实例在共享存储上的tpcc
      TPCC： 执行 五分钟   terminal 64,96
       收集cpu<用户， 系统> 与 存储的网络状况 与火焰图；统计数据块请求消息
  3. 三实例在共享存储上的tpcc
       TPCC： 执行 五分钟  terminal 64,96
       收集cpu<用户， 系统> 与 存储的网络状况 与火焰图；统计数据块请求消息


create table bmsql_order_line (
  ol_w_id         integer   not null,
  ol_d_id         integer   not null,
  ol_o_id         integer   not null,
  ol_number       integer   not null,
  ol_i_id         integer   not null,
  ol_delivery_d   timestamp,
  ol_amount       decimal(6,2),
  ol_supply_w_id  integer,
  ol_quantity     integer,
  ol_dist_info    char(24)
);

foreignKeys.sql
alter table bmsql_order_line add constraint ol_order_fkey
    foreign key (ol_w_id, ol_d_id, ol_o_id)
    references bmsql_oorder (o_w_id, o_d_id, o_id);
alter table bmsql_order_line add constraint ol_stock_fkey
    foreign key (ol_supply_w_id, ol_i_id)
    references bmsql_stock (s_w_id, s_i_id);

./sql.common/indexCreates.sql
alter table bmsql_order_line add constraint bmsql_order_line_pkey
  primary key (ol_w_id, ol_d_id, ol_o_id, ol_number);
insert into bmsql_order_line values(1,1,1,1,1,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(2,2,2,2,2,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(3,3,3,3,3,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(4,4,4,4,4,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(5,5,5,5,5,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(6,6,6,6,6,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(7,7,7,7,7,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(8,8,8,8,8,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(9,9,9,9,9,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(10,10,10,10,10,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(11,11,11,11,11,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(12,12,12,12,12,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(13,13,13,13,13,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(14,14,14,14,14,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(15,15,15,15,15,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(16,16,16,16,16,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(17,17,17,17,17,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(18,18,18,18,18,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(19,19,19,19,19,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(20,20,20,20,20,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(21,21,21,21,21,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(22,22,22,22,22,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(23,23,23,23,23,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(24,24,24,24,24,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(25,25,25,25,25,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(26,26,26,26,26,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(27,27,27,27,27,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(28,28,28,28,28,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(29,29,29,29,29,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(30,30,30,30,30,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(31,31,31,31,31,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(32,32,32,32,32,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(33,33,33,33,33,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(34,34,34,34,34,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(35,35,35,35,35,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(36,36,36,36,36,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(37,37,37,37,37,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(38,38,38,38,38,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(39,39,39,39,39,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
insert into bmsql_order_line values(40,40,40,40,40,'2021-08-19 12:10:25-07',1001.01,1,1,'a');
select ux_relation_size('bmsql_order_line_pkey');
827392

问题单：116464


tpcc问题：

1、扩展块问题（查看索引是否扩展）
2、tpcc报错问题


表空间：
uxdb=# select ux_relation_size('bmsql_stock');
 ux_relation_size
------------------
       1073725440
(1 row)

索引大小：
uxdb=# select ux_relation_size('bmsql_stock_pkey');
 ux_relation_size
------------------
       1096269824
(1 row)


uxdb=# \dt+
                              List of relations
 Schema |       Name       | Type  | Owner | Storage |  Size   | Description
--------+------------------+-------+-------+---------+---------+-------------
 public | bmsql_config     | table | uxdb  | heap    | 1024 MB |
 public | bmsql_customer   | table | uxdb  | heap    | 2049 MB |
 public | bmsql_district   | table | uxdb  | heap    | 1024 MB |
 public | bmsql_history    | table | uxdb  | heap    | 1024 MB |
 public | bmsql_item       | table | uxdb  | heap    | 1024 MB |
 public | bmsql_new_order  | table | uxdb  | heap    | 1024 MB |
 public | bmsql_oorder     | table | uxdb  | heap    | 1024 MB |
 public | bmsql_order_line | table | uxdb  | heap    | 1024 MB |
 public | bmsql_stock      | table | uxdb  | heap    | 1188 MB |
 public | bmsql_warehouse  | table | uxdb  | heap    | 1024 MB |

bmsql_order_line 索引增加

uxdb=# select ux_relation_size('bmsql_config_pkey');
 ux_relation_size
------------------
       1073733632
(1 row)

uxdb=# select ux_relation_size('bmsql_customer_pkey');
 ux_relation_size
------------------
       1083211776
(1 row)

uxdb=# select ux_relation_size('bmsql_district_pkey');
 ux_relation_size
------------------
       1073741824
(1 row)

uxdb=# select ux_relation_size('bmsql_history_pkey');
 ux_relation_size
------------------
       1080500224
(1 row)

uxdb=#
uxdb=# select ux_relation_size('bmsql_item_pkey');
 ux_relation_size
------------------
       1075986432
(1 row)

uxdb=# select ux_relation_size('bmsql_new_order_pkey');
 ux_relation_size
------------------
       1076584448
(1 row)

uxdb=# select ux_relation_size('bmsql_oorder_pkey');
 ux_relation_size
------------------
       1083211776
(1 row)

uxdb=# select ux_relation_size('bmsql_order_line_pkey');
 ux_relation_size
------------------
       1168359424
(1 row)


uxdb=# select ux_relation_size('bmsql_stock_pkey');
 ux_relation_size
------------------
       1096269824
(1 row)

uxdb=# select ux_relation_size('bmsql_warehouse_pkey');
 ux_relation_size
------------------
       1073741824
(1 row)

tpcc报错：
FATAL: failed to re-find parent key in index "227236" for split pages 370/371


修复分区
https://forum.ubuntu.org.cn/viewtopic.php?t=382482
sudo e2fsck -b 32768 -y /dev/sda6


iqn.2021-08.com.uxsino:104server

索引
right sibling's left-link doesn't match: block 11698 links to 7588 instead of expected 4616 in index "bmsql_order_line_pkey"

共享存储tpcc报错：
1、        edge----> (instId %u, pid %d, xid %u)


2、

2021-08-24 10:28:31.514 CST [41311] WARNING:  clog msg resend: src_id:1, des_id:2, events:8, index:[2-9], xid:[618-623]
2021-08-24 10:28:43.518 CST [41311] WARNING:  clog msg resend: src_id:1, des_id:2, events:8, index:[3027-3034], xid:[6885-6908]
2021-08-24 10:28:55.523 CST [41311] WARNING:  clog msg resend: src_id:1, des_id:2, events:8, index:[5851-5858], xid:[12348-12356]
2021-08-24 10:29:07.529 CST [41311] WARNING:  clog msg resend: src_id:1, des_id:2, events:8, index:[6923-6930], xid:[14333-14350]
2021-08-24 10:29:18.010 CST [41321] LOG:  GDD-GlobalDeadLockDetect-detect: finish collect 1 instances reply msg packet. allInstanceDependsCount 37
2021-08-24 10:29:18.010 CST [41321] LOG:  GDD-ShowLDG: HAS CIRCLES, after delete, remain 1 vertexs on the circle.
2021-08-24 10:29:18.010 CST [41321] LOG:  GDD-ShowLDG: vexnum 1 arcnum 3
2021-08-24 10:29:18.010 CST [41321] LOG:  GDD-ShowLDG: vextex info:


3、unexpected EOF on client connection with an open transaction

4、bmsql_order_line_pkey

注释：
 mdextend file:


2021-08-25

偶先共享锁问题；

[Thread-58] ERROR  jTPCCTData : Unexpected SQLException in NEW_ORDER Usage:18:06:57,785 [Thread-58] ERROR  jTPCCTData : Batch entry 8 INSERT INTO bmsql_order_line (    ol_o_id, ol_d_id, ol_w_id, ol_number,     ol_i_id, ol_supply_w_id, ol_quantity,     ol_amount, ol_dist_info) VALUES (3021, 5, 6, 9, 49825, 6, 5, 206.4, 'XRlf2qVwQzUZEHOTlqvnBuAL') was aborted: ERROR: right sibling's left-link doesn't match: block 11594 links to 10361 instead of expected 6350 in index "bmsql_order_line_pkey"  Call getNextException to see other errors in the batch.
18:06:57,786 [Thread-58] ERROR  jTPCCTData : ERROR: right sibling's left-link doesn't match: block 11594 links to 10361 instead of expected 6350 in index "bmsql_order_line_pkey"
java.sql.BatchUpdateException: Batch entry 8 INSERT INTO bmsql_order_line (    ol_o_id, ol_d_id, ol_w_id, ol_number,     ol_i_id, ol_supply_w_id, ol_quantity,     ol_amount, ol_dist_info) VALUES (3021, 5, 6, 9, 49825, 6, 5, 206.4, 'XRlf2qVwQzUZEHOTlqvnBuAL') was aborted: ERROR: right sibling's left-link doesn't match: block 11594 links to 10361 instead of expected 6350 in index "bmsql_order_line_pkey"  Call getNextException to see other errors in the batch.
        at com.uxdb.jdbc.BatchResultHandler.handleError(BatchResultHandler.java:148)
        at com.uxdb.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2126)
        at com.uxdb.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:469)
        at com.uxdb.jdbc.PgStatement.executeBatch(PgStatement.java:791)
        at com.uxdb.jdbc.PgPreparedStatement.executeBatch(PgPreparedStatement.java:1547)
        at jTPCCTData.executeNewOrder(jTPCCTData.java:566)
        at jTPCCTData.execute(jTPCCTData.java:95)
        at jTPCCTerminal.executeTransactions(jTPCCTerminal.java:261)
        at jTPCCTerminal.run(jTPCCTerminal.java:88)
        at java.lang.Thread.run(Thread.java:748)
Caused by: com.uxdb.util.PSQLException: ERROR: right sibling's left-link doesn't match: block 11594 links to 10361 instead of expected 6350 in index "bmsql_order_line_pkey"
        at com.uxdb.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2412)
        at com.uxdb.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:2125)


首先查看 FSM 是否知道任何空闲页面。
*
* 我们不能毫无保留地相信 FSM 的报告；我们必须检查该页面是否仍然可用。 （例如，一个已经空闲的页面可能在上次 VACUUM 扫描它的时间和 VACUUM 进行 FSM 更新的时间之间被重新使用。）
*
* 事实上，情况比这更糟糕：我们甚至不能假设锁定报告页面是安全的。如果其他人锁定了它，或者更糟糕的是我们自己的调用者锁定了它，我们可能会死锁。 （自己的调用者场景实际上并非不可能。考虑在串行或时间戳列上的索引。几乎所有拆分都将在最右边的页面，因此 _bt_split 完全有可能在持有最近获取的页面上的锁的同时调用我们来自 FSM。与前一个拆分同时运行的 VACUUM 很可能将该页面放回 FSM。）
*
* 为了解决这个问题，我们只要求对报告页面进行条件锁定。如果我们失败了，那么其他人正在使用该页面，我们可以合理地假设它不是免费的。 （如果我们碰巧错了，最坏的后果是页面将丢失，直到下一次 VACUUM 才能使用，这没什么大问题。）

设置扩展块大小：
expand_block_number=262200


bmsql_config：11:41 - 11:45
bmsql_warehouse
bmsql_district
bmsql_customer
bmsql_history
bmsql_new_order
bmsql_oorder			11:56
bmsql_order_line
bmsql_stock
bmsql_warehouse




uxdb=# select * from pcm_request_statistics();
 instanceid | requests | resourcerequests | readrequests | writerequests | retryrequests | timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+---------------+---------+----------+-------------+----------
          1 |  4540122 |           288793 |      2136171 |       2115158 |             0 |       0 |  2328112 |     2076547 |   135463
          2 |  4640344 |           300063 |      1980443 |       2359838 |             0 |       0 |  2108604 |     2348700 |   183040


15:59:07,477 [main] INFO   jTPCTerm-00, Running Average tpmTOTAL: 88223.10    Current tpmTOTAL: 2918484    Me16:04:09,405 [Thread-69] INFO   jTPCC : Term-00, 1484MB                                                      16:04:09,418 [Thread-69] INFO   jTPCC : Term-00,                                                             16:04:09,420 [Thread-69] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 39687.43                        16:04:09,420 [Thread-69] INFO   jTPCC : Term-00, Measured tpmTOTAL = 88172.47                                16:04:09,421 [Thread-69] INFO   jTPCC : Term-00, Session Start     = 2021-08-26 15:59:09
16:04:09,421 [Thread-69] INFO   jTPCC : Term-00, Session End       = 2021-08-26 16:04:09
16:04:09,421 [Thread-69] INFO   jTPCC : Term-00, Transaction Count = 441192


tpcc  100仓数据：
uxdb=# \d+
                                 List of relations
 Schema |       Name        |   Type   | Owner | Storage |    Size    | Description
--------+-------------------+----------+-------+---------+------------+-------------
 public | bmsql_config      | table    | uxdb  | heap    | 8192 bytes |
 public | bmsql_customer    | table    | uxdb  | heap    | 1775 MB    |
 public | bmsql_district    | table    | uxdb  | heap    | 192 kB     |
 public | bmsql_hist_id_seq | sequence | uxdb  | heap    | 8192 bytes |
 public | bmsql_history     | table    | uxdb  | heap    | 253 MB     |
 public | bmsql_item        | table    | uxdb  | heap    | 10 MB      |
 public | bmsql_new_order   | table    | uxdb  | heap    | 38 MB      |
 public | bmsql_oorder      | table    | uxdb  | heap    | 190 MB     |
 public | bmsql_order_line  | table    | uxdb  | heap    | 2894 MB    |
 public | bmsql_stock       | table    | uxdb  | heap    | 3397 MB    |
 public | bmsql_warehouse   | table    | uxdb  | heap    | 112 kB     |
(11 rows)

https://www.cnblogs.com/wqcheng/p/6618068.html
/dev/sdg
/dev/sdf

pvcreate /dev/sdb //硬盘1
pvcreate /dev/sdc //硬盘2

vgcreate LVM /dev/sdb

vgextend LVM /dev/sdc

lvcreate -L5.0T -nDB_DATA LVM


SELECT
procpid,
start,
now() - start AS lap,
current_query
FROM
(SELECT
backendid,
ux_stat_get_backend_pid(S.backendid) AS procpid,
ux_stat_get_backend_activity_start(S.backendid) AS start,
ux_stat_get_backend_activity(S.backendid) AS current_query
FROM
(SELECT ux_stat_get_backend_idset() AS backendid) AS S
) AS S
WHERE
current_query <> '<IDLE>'
ORDER BY
lap DESC;


with
t_wait as
(
  select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted,
  a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,
  b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name
    from ux_locks a,ux_stat_activity b where a.pid=b.pid and not a.granted
),
t_run as
(
  select a.mode,a.locktype,a.database,a.relation,a.page,a.tuple,a.classid,a.granted,
  a.objid,a.objsubid,a.pid,a.virtualtransaction,a.virtualxid,a.transactionid,a.fastpath,
  b.state,b.query,b.xact_start,b.query_start,b.usename,b.datname,b.client_addr,b.client_port,b.application_name
    from ux_locks a,ux_stat_activity b where a.pid=b.pid and a.granted
),
t_overlap as
(
  select r.* from t_wait w join t_run r on
  (
    r.locktype is not distinct from w.locktype and
    r.database is not distinct from w.database and
    r.relation is not distinct from w.relation and
    r.page is not distinct from w.page and
    r.tuple is not distinct from w.tuple and
    r.virtualxid is not distinct from w.virtualxid and
    r.transactionid is not distinct from w.transactionid and
    r.classid is not distinct from w.classid and
    r.objid is not distinct from w.objid and
    r.objsubid is not distinct from w.objsubid and
    r.pid <> w.pid
  )
),
t_unionall as
(
  select r.* from t_overlap r
  union all
  select w.* from t_wait w
)
select locktype,datname,relation::regclass,page,tuple,virtualxid,transactionid::text,classid::regclass,objid,objsubid,
string_agg(
'Pid: '||case when pid is null then 'NULL' else pid::text end||chr(10)||
'Lock_Granted: '||case when granted is null then 'NULL' else granted::text end||' , Mode: '||case when mode is null then 'NULL' else mode::text end||' , FastPath: '||case when fastpath is null then 'NULL' else fastpath::text end||' , VirtualTransaction: '||case when virtualtransaction is null then 'NULL' else virtualtransaction::text end||' , Session_State: '||case when state is null then 'NULL' else state::text end||chr(10)||
'Username: '||case when usename is null then 'NULL' else usename::text end||' , Database: '||case when datname is null then 'NULL' else datname::text end||' , Client_Addr: '||case when client_addr is null then 'NULL' else client_addr::text end||' , Client_Port: '||case when client_port is null then 'NULL' else client_port::text end||' , Application_Name: '||case when application_name is null then 'NULL' else application_name::text end||chr(10)||
'Xact_Start: '||case when xact_start is null then 'NULL' else xact_start::text end||' , Query_Start: '||case when query_start is null then 'NULL' else query_start::text end||' , Xact_Elapse: '||case when (now()-xact_start) is null then 'NULL' else (now()-xact_start)::text end||' , Query_Elapse: '||case when (now()-query_start) is null then 'NULL' else (now()-query_start)::text end||chr(10)||
'SQL (Current SQL in Transaction): '||chr(10)||
case when query is null then 'NULL' else query::text end,
chr(10)||'--------'||chr(10)
order by
  (  case mode
    when 'INVALID' then 0
    when 'AccessShareLock' then 1
    when 'RowShareLock' then 2
    when 'RowExclusiveLock' then 3
    when 'ShareUpdateExclusiveLock' then 4
    when 'ShareLock' then 5
    when 'ShareRowExclusiveLock' then 6
    when 'ExclusiveLock' then 7
    when 'AccessExclusiveLock' then 8
    else 0
  end  ) desc,
  (case when granted then 0 else 1 end)
) as lock_conflict
from t_unionall
group by
locktype,datname,relation,page,tuple,virtualxid,transactionid::text,classid,objid,objsubid ;

合并硬盘：
/dev/sdg
/dev/sdf

pvcreate /dev/sdg
pvcreate /dev/sdf

vgcreate LVM /dev/sdg1
移除vg：
vgremove  LVM

vgextend LVM /dev/sdf

lvcreate -L186G -nDB_DATA LVM

479.0

958


lvcreate -l 47683  -n DB_DATA LVM


2021-09-01

bmsql_config
bmsql_item
bmsql_new_order
bmsql_warehouse

1GB
set expand_block_number=131070;
1000仓, (跑10分钟)
 public | bmsql_config      |
 public | bmsql_customer    | 30GB		3932100
 public | bmsql_district    | 2GB		262140
 public | bmsql_hist_id_seq |
 public | bmsql_history     | 4GB		524280
 public | bmsql_item        | 100MB		12800
 public | bmsql_new_order   | 1GB		131070
 public | bmsql_oorder      | 4GB		524280
 public | bmsql_order_line  | 50GB		6553500
 public | bmsql_stock       | 60GB		7864200
 public | bmsql_warehouse   | 1GB		131070



 20GB=2621400

1000仓, (跑20分钟)

 public | bmsql_config      |
 public | bmsql_customer    | 40GB		5242800
 public | bmsql_district    | 5GB		655350
 public | bmsql_hist_id_seq |
 public | bmsql_history     | 5GB		655350
 public | bmsql_item        | 100MB		12800
 public | bmsql_new_order   | 1.5GB		196605
 public | bmsql_oorder      | 4.5GB		589815
 public | bmsql_order_line  | 65GB		8519550
 public | bmsql_stock       | 100GB		13107000
 public | bmsql_warehouse   | 2.5GB		327675
 


 select expand_fsm_block(16384,3,0); | bmsql_config                                                   
 select expand_fsm_block(16389,3,0); | bmsql_warehouse                                                
 select expand_fsm_block(16392,3,0); | bmsql_district                                                 
 select expand_fsm_block(16395,3,0); | bmsql_customer                                                 
 select expand_fsm_block(16403,3,0); | bmsql_history
 select expand_fsm_block(16406,3,0); | bmsql_new_order
 select expand_fsm_block(16409,3,0); | bmsql_oorder
 select expand_fsm_block(16412,3,0); | bmsql_order_line
 select expand_fsm_block(16415,3,0); | bmsql_item
 select expand_fsm_block(16418,3,0); | bmsql_stock







ux_prewarm.sql,1000仓加载块大小

select expand_fsm_block(16389,8,512);
select expand_fsm_block(16392,8,512);			（6等分）		（4等份）
select expand_fsm_block(16395,8,2290688);		381781			572672			bmsql_customer
select expand_fsm_block(16403,8,324608);		54101			81152			bmsql_history
select expand_fsm_block(16406,8,49152);			8192			12288			bmsql_new_order	
select expand_fsm_block(16409,8,243200);		40533			60800			bmsql_oorder
select expand_fsm_block(16412,8,3703808);		617301			925952			bmsql_order_line
select expand_fsm_block(16415,8,1536);			256				384				bmsql_item
select expand_fsm_block(16418,8,4347904);		724650			1086976			bmsql_stock
select expand_fsm_block(16435,8,275456);		45,909			68864			bmsql_stock_pkey

1000仓总大小													总大小			加载后块开始大小		剩余大小   剩余6等分    剩余4等份
select ux_prewarm('bmsql_customer',0,381781);					5242800			2290689					2952112		492018			738028
select ux_prewarm('bmsql_history',0,54101);						655350			324609					330742		55123			82685
select ux_prewarm('bmsql_new_order',0,8192);					196605			49153					147453		24575			36863
select ux_prewarm('bmsql_oorder',0,40533);						589815			243201					346615		57769			86653
select ux_prewarm('bmsql_order_line',0,617301);					8519550			3703809					4815742		802623			1203935
select ux_prewarm('bmsql_item',0,256);							12800			1537					11264		1877			2816
select ux_prewarm('bmsql_stock',0,724650);						13107000		4347905					8759096		1459849			2189774
select ux_prewarm('bmsql_stock_pkey',0,45909);					8519550			275457					8244094		1374015			2061023

select expand_fsm_block(16435,8,275456);		45909
select ux_prewarm('bmsql_config_PKEY');			总块号		4等份		6等分			
select ux_prewarm('bmsql_customer_idx1');		2621400		655350			436900
select ux_prewarm('bmsql_customer_pkey');		2621400
select ux_prewarm('bmsql_district_pkey');		327675		81918			54612
select ux_prewarm('bmsql_item_pkey');			12800		3200			2133
select ux_prewarm('bmsql_new_order_pkey');		196605		49151			32767
select ux_prewarm('bmsql_oorder_idx1');			327675
select ux_prewarm('bmsql_oorder_pkey');			327675
select ux_prewarm('bmsql_order_line_pkey');		5242800		1310700			873800
select ux_prewarm('bmsql_warehouse_pkey');		327675

bmsql_warehouse									327675					54612						
bmsql_district									655350					109225			


四等份
节点1：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',0,81918);
select ux_prewarm('bmsql_district','buffer','main',0,163837);

select ux_prewarm('bmsql_customer','buffer','main',0,572672);
select ux_prewarm('bmsql_history','buffer','main',0,81152);
select ux_prewarm('bmsql_new_order','buffer','main',0,12288);
select ux_prewarm('bmsql_oorder','buffer','main',0,60800);
select ux_prewarm('bmsql_order_line','buffer','main',0,925952);
select ux_prewarm('bmsql_item','buffer','main',0,384);
select ux_prewarm('bmsql_stock','buffer','main',0,1086976);
select ux_prewarm('bmsql_stock_pkey','buffer','main',0,68864);

select ux_prewarm('bmsql_customer','buffer','main',2290689,3028717);
select ux_prewarm('bmsql_history','buffer','main',324609,407294);
select ux_prewarm('bmsql_new_order','buffer','main',49153,86016);
select ux_prewarm('bmsql_oorder','buffer','main',243201,329854);
select ux_prewarm('bmsql_order_line','buffer','main',3703809,4907744);
select ux_prewarm('bmsql_item','buffer','main',1537,4353);
select ux_prewarm('bmsql_stock','buffer','main',4347905,6537679);
select ux_prewarm('bmsql_stock_pkey','buffer','main',275457,2336480);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',0,655350);
select ux_prewarm('bmsql_customer_pkey','buffer','main',0,655350);
select ux_prewarm('bmsql_district_pkey','buffer','main',0,81918);
select ux_prewarm('bmsql_item_pkey','buffer','main',0,3200);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',0,49151);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',0,81918);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',0,81918);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',0,1310700);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',0,81918);

checkpoint;

节点2：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',81919,163836);
select ux_prewarm('bmsql_district','buffer','main',163838,327674);

select ux_prewarm('bmsql_customer','buffer','main',572673,1145344);
select ux_prewarm('bmsql_history','buffer','main',81153, 162304);
select ux_prewarm('bmsql_new_order','buffer','main',12289, 24576);
select ux_prewarm('bmsql_oorder','buffer','main',60801,121600);
select ux_prewarm('bmsql_order_line','buffer','main',925953,1851904);
select ux_prewarm('bmsql_item','buffer','main',385,768);
select ux_prewarm('bmsql_stock','buffer','main',1086977, 2173952);
select ux_prewarm('bmsql_stock_pkey','buffer','main',68865,137728);

select ux_prewarm('bmsql_customer','buffer','main',3028718,3766745);
select ux_prewarm('bmsql_history','buffer','main',407295, 489979);
select ux_prewarm('bmsql_new_order','buffer','main',86017, 122879);
select ux_prewarm('bmsql_oorder','buffer','main',329855,416507);
select ux_prewarm('bmsql_order_line','buffer','main',4907745,6111679);
select ux_prewarm('bmsql_item','buffer','main',4354,7169);
select ux_prewarm('bmsql_stock','buffer','main',6537680, 8727453);
select ux_prewarm('bmsql_stock_pkey','buffer','main',2336481,4397503);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',655351,1310700);
select ux_prewarm('bmsql_customer_pkey','buffer','main',655351,1310700);
select ux_prewarm('bmsql_district_pkey','buffer','main',81919,163836);
select ux_prewarm('bmsql_item_pkey','buffer','main',3201,6400);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',49152,98302);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',81919,163836);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',81919,163836);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',1310701,2621400);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',81919,163836);
checkpoint;
节点3：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',163837,245754);
select ux_prewarm('bmsql_district','buffer','main',327675,491511);

select ux_prewarm('bmsql_customer','buffer','main',1145345,1718016);
select ux_prewarm('bmsql_history','buffer','main',162305, 243456);
select ux_prewarm('bmsql_new_order','buffer','main',24577,36864);
select ux_prewarm('bmsql_oorder','buffer','main',121601,182400);
select ux_prewarm('bmsql_order_line','buffer','main',1851905,2777856);
select ux_prewarm('bmsql_item','buffer','main',769,1152);
select ux_prewarm('bmsql_stock','buffer','main',2173953,3260928);
select ux_prewarm('bmsql_stock_pkey','buffer','main',137729,206592);

select ux_prewarm('bmsql_customer','buffer','main',3766746,4504773);
select ux_prewarm('bmsql_history','buffer','main',489980, 572664);
select ux_prewarm('bmsql_new_order','buffer','main',122880,159742);
select ux_prewarm('bmsql_oorder','buffer','main',416508,503160);
select ux_prewarm('bmsql_order_line','buffer','main',6111680,7315614);
select ux_prewarm('bmsql_item','buffer','main',7170,9985);
select ux_prewarm('bmsql_stock','buffer','main',8727454,10917227);
select ux_prewarm('bmsql_stock_pkey','buffer','main',4397504,6458526);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',1310701,1966050);
select ux_prewarm('bmsql_customer_pkey','buffer','main',1310701,1966050);
select ux_prewarm('bmsql_district_pkey','buffer','main',163837,245754);
select ux_prewarm('bmsql_item_pkey','buffer','main',6401,9600);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',98303,147453);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',163837,245754);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',163837,245754);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',2621401,3932100);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',163837,245754);
checkpoint;
节点4：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',245755,327674);
select ux_prewarm('bmsql_district','buffer','main',491512,655349);

select ux_prewarm('bmsql_customer','buffer','main',1718017, 2290688);
select ux_prewarm('bmsql_history','buffer','main', 243457, 324608);
select ux_prewarm('bmsql_new_order','buffer','main',36865, 49152);
select ux_prewarm('bmsql_oorder','buffer','main',182401,243200);
select ux_prewarm('bmsql_order_line','buffer','main',2777857, 3703808);
select ux_prewarm('bmsql_item','buffer','main',1153,1536);
select ux_prewarm('bmsql_stock','buffer','main',3260929, 4347904);
select ux_prewarm('bmsql_stock_pkey','buffer','main',206593,275456);

select ux_prewarm('bmsql_customer','buffer','main',3766744, 5242799);
select ux_prewarm('bmsql_history','buffer','main', 572665, 655349);
select ux_prewarm('bmsql_new_order','buffer','main',159743, 196604);
select ux_prewarm('bmsql_oorder','buffer','main',503161,589814);
select ux_prewarm('bmsql_order_line','buffer','main',7315615, 8519549);
select ux_prewarm('bmsql_item','buffer','main',9986,12799);
select ux_prewarm('bmsql_stock','buffer','main',10917228, 13106999);
select ux_prewarm('bmsql_stock_pkey','buffer','main',6458527,8519549);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',1966051,2621399);
select ux_prewarm('bmsql_customer_pkey','buffer','main',1966051,2621399);
select ux_prewarm('bmsql_district_pkey','buffer','main',245755,327674);
select ux_prewarm('bmsql_item_pkey','buffer','main',9601,12799);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',147454,196604);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',245755,327674);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',245755,327674);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',3932101,5242799);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',245755,327674);
checkpoint;

select ux_prewarm('bmsql_config_PKEY');			总块号		4等份		6等分			
select ux_prewarm('bmsql_customer_idx1');		2621400		655350			436900
select ux_prewarm('bmsql_customer_pkey');		2621400
select ux_prewarm('bmsql_district_pkey');		327675		81918			54612
select ux_prewarm('bmsql_item_pkey');			12800		3200			2133
select ux_prewarm('bmsql_new_order_pkey');		196605		49151			32767
select ux_prewarm('bmsql_oorder_idx1');			327675
select ux_prewarm('bmsql_oorder_pkey');			327675
select ux_prewarm('bmsql_order_line_pkey');		5242800		1310700			873800
select ux_prewarm('bmsql_warehouse_pkey');		327675

1000仓总大小													总大小			加载后块开始大小		剩余大小   剩余6等分    剩余4等份
select ux_prewarm('bmsql_customer',0,381781);					5242800			2290689					2952112		492018			738028
select ux_prewarm('bmsql_history',0,54101);						655350			324609					330742		55123			82685
select ux_prewarm('bmsql_new_order',0,8192);					196605			49153					147453		24575			36863
select ux_prewarm('bmsql_oorder',0,40533);						589815			243201					346615		57769			86653
select ux_prewarm('bmsql_order_line',0,617301);					8519550			3703809					4815742		802623			1203935
select ux_prewarm('bmsql_item',0,256);							12800			1537					11264		1877			2816
select ux_prewarm('bmsql_stock',0,724650);						13107000		4347905					8759096		1459849			2189774
select ux_prewarm('bmsql_stock_pkey',0,45909);					8519550			275457					8244094		1374015			2061023






















六等份
节点1：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',0,54612);
select ux_prewarm('bmsql_district','buffer','main',0,109225);

select ux_prewarm('bmsql_customer','buffer','main',0,381781);
select ux_prewarm('bmsql_history','buffer','main',0,54101);
select ux_prewarm('bmsql_new_order','buffer','main',0,8192);
select ux_prewarm('bmsql_oorder','buffer','main',0,40533);
select ux_prewarm('bmsql_order_line','buffer','main',0,617301);
select ux_prewarm('bmsql_item','buffer','main',0,256);
select ux_prewarm('bmsql_stock','buffer','main',0,724650);
select ux_prewarm('bmsql_stock_pkey','buffer','main',0,45909);

select ux_prewarm('bmsql_customer','buffer','main',2290689,2782707);
select ux_prewarm('bmsql_history','buffer','main',324609,379732);
select ux_prewarm('bmsql_new_order','buffer','main',49153,73728);
select ux_prewarm('bmsql_oorder','buffer','main',243201,300970);
select ux_prewarm('bmsql_order_line','buffer','main',3703809,4506432);
select ux_prewarm('bmsql_item','buffer','main',1537,3414);
select ux_prewarm('bmsql_stock','buffer','main',4347905,5807754);
select ux_prewarm('bmsql_stock_pkey','buffer','main',275457,1649472);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',0,436900);
select ux_prewarm('bmsql_customer_pkey','buffer','main',0,436900);
select ux_prewarm('bmsql_district_pkey','buffer','main',0,54612);
select ux_prewarm('bmsql_item_pkey','buffer','main',0,2133);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',0,32767);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',0,54612);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',0,54612);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',0,873800);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',0,54612);

checkpoint;

节点2：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',54613,109224);
select ux_prewarm('bmsql_district','buffer','main',109226,218450);

select ux_prewarm('bmsql_customer','buffer','main',381782,763562);
select ux_prewarm('bmsql_history','buffer','main',54102, 108202);
select ux_prewarm('bmsql_new_order','buffer','main',8193, 16384);
select ux_prewarm('bmsql_oorder','buffer','main',40534,81066);
select ux_prewarm('bmsql_order_line','buffer','main',617302,1234602);
select ux_prewarm('bmsql_item','buffer','main',257,512);
select ux_prewarm('bmsql_stock','buffer','main',724651, 1449300);
select ux_prewarm('bmsql_stock_pkey','buffer','main',45910,91818);

select ux_prewarm('bmsql_customer','buffer','main',2782708,3274725);
select ux_prewarm('bmsql_history','buffer','main',379733, 434855);
select ux_prewarm('bmsql_new_order','buffer','main',73729, 98303);
select ux_prewarm('bmsql_oorder','buffer','main',300971,358739);
select ux_prewarm('bmsql_order_line','buffer','main',4506433,5309055);
select ux_prewarm('bmsql_item','buffer','main',3415,5291);
select ux_prewarm('bmsql_stock','buffer','main',5807755, 7267603);
select ux_prewarm('bmsql_stock_pkey','buffer','main',1649473,3023487);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',436901,873800);
select ux_prewarm('bmsql_customer_pkey','buffer','main',436901,873800);
select ux_prewarm('bmsql_district_pkey','buffer','main',54613,109224);
select ux_prewarm('bmsql_item_pkey','buffer','main',2134,4266);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',32768,65534);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',54613,109224);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',54613,109224);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',873801,1747600);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',54613,109224);
checkpoint;
节点3：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',109225,163836);
select ux_prewarm('bmsql_district','buffer','main',218451,327675);

select ux_prewarm('bmsql_customer','buffer','main',763563,1145343);
select ux_prewarm('bmsql_history','buffer','main',108203, 162303);
select ux_prewarm('bmsql_new_order','buffer','main',16385,24576);
select ux_prewarm('bmsql_oorder','buffer','main',81067,121599);
select ux_prewarm('bmsql_order_line','buffer','main',234603,1851903);
select ux_prewarm('bmsql_item','buffer','main',513,768);
select ux_prewarm('bmsql_stock','buffer','main',1449301,2173950);
select ux_prewarm('bmsql_stock_pkey','buffer','main',91818,137727);

select ux_prewarm('bmsql_customer','buffer','main',3274726,3766743);
select ux_prewarm('bmsql_history','buffer','main',434856, 489978);
select ux_prewarm('bmsql_new_order','buffer','main',98304,122878);
select ux_prewarm('bmsql_oorder','buffer','main',358740,416508);
select ux_prewarm('bmsql_order_line','buffer','main',5309056,6111678);
select ux_prewarm('bmsql_item','buffer','main',5292,7168);
select ux_prewarm('bmsql_stock','buffer','main',7267604,8727452);
select ux_prewarm('bmsql_stock_pkey','buffer','main',3023488,4397502);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',873801,1310700);
select ux_prewarm('bmsql_customer_pkey','buffer','main',873801,1310700);
select ux_prewarm('bmsql_district_pkey','buffer','main',109225,163836);
select ux_prewarm('bmsql_item_pkey','buffer','main',4267,6399);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',65535,98301);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',109225,163836);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',109225,163836);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',1747601,2621400);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',109225,163836);
checkpoint;
节点4：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',163837,218448);
select ux_prewarm('bmsql_district','buffer','main',327676,436900);

select ux_prewarm('bmsql_customer','buffer','main',1145344, 1527124);
select ux_prewarm('bmsql_history','buffer','main', 162304, 216404);
select ux_prewarm('bmsql_new_order','buffer','main',24577, 32768);
select ux_prewarm('bmsql_oorder','buffer','main',121600,162132);
select ux_prewarm('bmsql_order_line','buffer','main',1851904, 2469204);
select ux_prewarm('bmsql_item','buffer','main',769,1024);
select ux_prewarm('bmsql_stock','buffer','main',2173951, 2898600);
select ux_prewarm('bmsql_stock_pkey','buffer','main',137728,183636);

select ux_prewarm('bmsql_customer','buffer','main',3766744, 4258761);
select ux_prewarm('bmsql_history','buffer','main', 489979, 545101);
select ux_prewarm('bmsql_new_order','buffer','main',122879, 147453);
select ux_prewarm('bmsql_oorder','buffer','main',416509,474277);
select ux_prewarm('bmsql_order_line','buffer','main',6111679, 6914301);
select ux_prewarm('bmsql_item','buffer','main',7169,9045);
select ux_prewarm('bmsql_stock','buffer','main',8727453, 10187301);
select ux_prewarm('bmsql_stock_pkey','buffer','main',4397503,5771517);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',1310701,1747600);
select ux_prewarm('bmsql_customer_pkey','buffer','main',1310701,1747600);
select ux_prewarm('bmsql_district_pkey','buffer','main',163837,218448);
select ux_prewarm('bmsql_item_pkey','buffer','main',6400,8532);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',98302,131068);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',163837,218448);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',163837,218448);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',2621401,3495200);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',163837,218448);
checkpoint;
节点5：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',218449,273060);
select ux_prewarm('bmsql_district','buffer','main',436901,546125);

select ux_prewarm('bmsql_customer','buffer','main',4258762, 4750779);
select ux_prewarm('bmsql_history','buffer','main',216405, 270505);
select ux_prewarm('bmsql_new_order','buffer','main',32769, 40960);
select ux_prewarm('bmsql_oorder','buffer','main',162133, 202665);
select ux_prewarm('bmsql_order_line','buffer','main',2469205,3086505);
select ux_prewarm('bmsql_item','buffer','main',1025,1280);
select ux_prewarm('bmsql_stock','buffer','main',2898601,3623250);
select ux_prewarm('bmsql_stock_pkey','buffer','main',183637,229545);

select ux_prewarm('bmsql_customer','buffer','main',1527124, 1908905);
select ux_prewarm('bmsql_history','buffer','main',545102, 600224);
select ux_prewarm('bmsql_new_order','buffer','main',147454, 172028);
select ux_prewarm('bmsql_oorder','buffer','main',474278, 532046);
select ux_prewarm('bmsql_order_line','buffer','main',6914302,7716924);
select ux_prewarm('bmsql_item','buffer','main',9046,10922);
select ux_prewarm('bmsql_stock','buffer','main',10187302,11647150);
select ux_prewarm('bmsql_stock_pkey','buffer','main',5771518,7145532);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',1747601,2184500);
select ux_prewarm('bmsql_customer_pkey','buffer','main',1747601,2184500);
select ux_prewarm('bmsql_district_pkey','buffer','main',218449,273060);
select ux_prewarm('bmsql_item_pkey','buffer','main',8533,10665);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',131069,163835);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',218449,273060);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',218449,273060);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',3495201,4369000);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',218449,273060);
checkpoint;
节点6：
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_warehouse','buffer','main',273061, 327674);
select ux_prewarm('bmsql_district','buffer','main',546125, 655349);

select ux_prewarm('bmsql_customer','buffer','main',1908906,2290688);
select ux_prewarm('bmsql_history','buffer','main',270505, 324608);
select ux_prewarm('bmsql_new_order','buffer','main',40960, 49152);
select ux_prewarm('bmsql_oorder','buffer','main',202666, 243200);
select ux_prewarm('bmsql_order_line','buffer','main',3086506,3703808);
select ux_prewarm('bmsql_item','buffer','main',1280,1536);
select ux_prewarm('bmsql_stock','buffer','main',3623251,4347904);
select ux_prewarm('bmsql_stock_pkey','buffer','main',229546,275456);

select ux_prewarm('bmsql_customer','buffer','main',4750780,5242799);
select ux_prewarm('bmsql_history','buffer','main',600225, 655349);
select ux_prewarm('bmsql_new_order','buffer','main',172029, 196604);
select ux_prewarm('bmsql_oorder','buffer','main',532047, 589814);
select ux_prewarm('bmsql_order_line','buffer','main',7716925,8519549);
select ux_prewarm('bmsql_item','buffer','main',10923,12799);
select ux_prewarm('bmsql_stock','buffer','main',11647151,13106999);
select ux_prewarm('bmsql_stock_pkey','buffer','main',7145533,8519549);

select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1','buffer','main',2184501, 2621400);
select ux_prewarm('bmsql_customer_pkey','buffer','main',2184501, 2621400);
select ux_prewarm('bmsql_district_pkey','buffer','main',273061, 327675);
select ux_prewarm('bmsql_item_pkey','buffer','main',10666,12800);
select ux_prewarm('bmsql_new_order_pkey','buffer','main',163835,196605);
select ux_prewarm('bmsql_oorder_idx1','buffer','main',273061, 327675);
select ux_prewarm('bmsql_oorder_pkey','buffer','main',273061, 327675);
select ux_prewarm('bmsql_order_line_pkey','buffer','main',4369000,5242800);
select ux_prewarm('bmsql_warehouse_pkey','buffer','main',273061, 327675);
checkpoint;


1000仓总大小													总大小			加载后块开始大小		剩余大小   剩余6等分
select ux_prewarm('bmsql_customer',0,381781);					5242800			2290689					2952112		492018
select ux_prewarm('bmsql_history',0,54101);						655350			324609					330742		55123
select ux_prewarm('bmsql_new_order',0,8192);					196604			49153					147453		24575
select ux_prewarm('bmsql_oorder',0,40533);						589814			243201					346615		57769
select ux_prewarm('bmsql_order_line',0,617301);					8519549			3703809					4815742		802623
select ux_prewarm('bmsql_item',0,256);							12799			1537					11264		1877
select ux_prewarm('bmsql_stock',0,724650);						13106999		4347905					8759096		1459849
select ux_prewarm('bmsql_stock_pkey',0,45909);					8519549			275457					8244094		1374015

select ux_prewarm('bmsql_config_PKEY');			总块号		6等分
select ux_prewarm('bmsql_customer_idx1');		2621400		436900
select ux_prewarm('bmsql_customer_pkey');		2621400
select ux_prewarm('bmsql_district_pkey');		327675		54612
select ux_prewarm('bmsql_item_pkey');			12800		2133
select ux_prewarm('bmsql_new_order_pkey');		196605		32767
select ux_prewarm('bmsql_oorder_idx1');			327675
select ux_prewarm('bmsql_oorder_pkey');			327675
select ux_prewarm('bmsql_order_line_pkey');		5242800		873800
select ux_prewarm('bmsql_stock_pkey');			8519550		1419925
select ux_prewarm('bmsql_warehouse_pkey');		327675

1000仓，（跑30分钟）

  扩块时间    
单机单实例    15min左右
2机2实例    25min左右
3机3实例    35min左右
3机4实例    45min左右


 run/sql.common/tableCreates.sql

105（节点1）：
%Cpu(s): 34.7 us,  4.4 sy,  0.0 ni, 58.4 id,  1.5 wa,  0.0 hi,  1.1 si,  0.0 st

102：
%Cpu(s): 11.9 us, 26.8 sy,  0.0 ni, 59.4 id,  1.3 wa,  0.0 hi,  0.6 si,  0.0 st

Measured tpmC (NewOrders) = 145319.52
Measured tpmTOTAL = 323154.34
Session Start     = 2021-09-01 18:16:25
Session End       = 2021-09-01 18:26:25
Transaction Count = 3231871

uxdb=# select * from pcm_request_statistics();
 instanceid | requests | resourcerequests | readrequests | writerequests | retryrequests
| timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+---------------
+---------+----------+-------------+----------
          1 |  6561874 |          1333647 |      1805817 |       3422410 |             0
|       0 |  2180604 |     3251921 |  1129349
          2 |  5674684 |           920102 |      1868037 |       2886545 |             0
|       0 |  2275581 |     2691235 |   707868

ps -ef|grep "uxdb uxdb" | grep -v grep| wc -l

./sql.common/tableCreates.sql
./sql.common/indexCreates.sql
./sql.common/foreignKeys.sql
./sql.postgres/extraHistID.sql


共享存储rebase合并目前最优代码；
tpcc初始化1000仓报错，loadWorkers设置多并发存在死锁问题，暂不解决；

2021-09-06

select expand_fsm_block(16384);

 16395 | tb2
 16398 | tb2_pkey


fsm空闲空间查找：
heap_insert
	RelationGetBufferForTuple
		GetPageWithFreeSpace
			fsm_search
				fsm_search_avail


2切份：
	splitBlock = totalBlocks / 2 - 1;
	treesplitBlock = splitBlock / 2;
	for(nBlock = 0; nBlock < totalBlocks; nBlock ++)
	{
		if(1 == MyInstanceId && nBlock > splitBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 0);
		}
		else if (2 == MyInstanceId && nBlock > splitBlock && nBlock <= (splitBlock + treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
		else if (3 == MyInstanceId && nBlock > (splitBlock + treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
	}

	// if(1 == MyInstanceId)
	// {
	// 	UpdateFreeSpaceMap(rel, splitBlock+1, totalBlocks-1, 0);
	// }
	if(2 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock+1, splitBlock + treesplitBlock, 8152);
	}
	if(3 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock + treesplitBlock + 1, totalBlocks-1, 8152);
	}

splitBlock = （splitBlock/512 + 1）*512 - 1；




 14 select expand_fsm_block(16425);
 15 select expand_fsm_block(16427);
 16 select expand_fsm_block(16428);
 select expand_fsm_block(16430);
 select expand_fsm_block(16435)

create sequence bmsql_hist_id_seq;

ALTER SEQUENCE bmsql_hist_id_seq
CACHE 10000；

CREATE [ TEMPORARY | TEMP ] SEQUENCE name [ INCREMENT [ BY ] increment ]
    [ MINVALUE minvalue | NO MINVALUE ] [ MAXVALUE maxvalue | NO MAXVALUE ]
    [ START [ WITH ] start ] [ CACHE cache ] [ [ NO ] CYCLE ]
    [ OWNED BY { table.column | NONE }

alter table bmsql_history drop constraint bmsql_history_pkey;


alter table bmsql_history drop constraint h_customer_fkey;
alter table bmsql_history drop constraint "h_district_fkey";
alter table bmsql_customer drop constraint c_district_fkey;
alter table bmsql_district drop constraint bmsql_district_pkey;


2021-09-09

1、
 relfilenode |        relname
-------------+-----------------------
       16384 | bmsql_config
       16387 | bmsql_config_pkey
       16389 | bmsql_warehouse
       16392 | bmsql_district
       16395 | bmsql_customer
       16398 | ux_toast_16395
       16400 | ux_toast_16395_index
       16403 | bmsql_history
       16406 | bmsql_new_order
       16409 | bmsql_oorder
       16412 | bmsql_order_line
       16415 | bmsql_item
       16418 | bmsql_stock

       16421 | bmsql_warehouse_pkey
       16425 | bmsql_customer_pkey
       16427 | bmsql_customer_idx1
       16428 | bmsql_oorder_pkey
       16430 | bmsql_oorder_idx1
       16431 | bmsql_new_order_pkey
       16433 | bmsql_order_line_pkey
       16435 | bmsql_stock_pkey
       16437 | bmsql_item_pkey
       16495 | bmsql_hist_id_seq

修改事物锁：


10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 3128.77
10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Measured tpmTOTAL = 6932.53
10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Session Start     = 2021-09-09 09:55:52
10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Session End       = 2021-09-09 10:00:53
10:00:53,016 [Thread-8] INFO   jTPCC : Term-00, Transaction Count = 34673



4节点代码：
1432：

	totalBlocks = RelationGetNumberOfBlocks(rel);
	splitBlock = totalBlocks / 3 - 1;
	if(splitBlock > 512)
	{
		splitBlock = (splitBlock/512 + 1) * 512 - 1;
	}
	treesplitBlock = totalBlocks - splitBlock - 1;
	treesplitBlock = treesplitBlock / 3;
	if(treesplitBlock > 512)
	{
		treesplitBlock = (treesplitBlock/512 + 1) * 512;
	}

	for(nBlock = 0; nBlock < totalBlocks; nBlock ++)
	{
		if(1 == MyInstanceId && nBlock > splitBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 0);
		}
		else if (2 == MyInstanceId && nBlock > splitBlock && nBlock <= (splitBlock + treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
		else if (3 == MyInstanceId && nBlock > (splitBlock + treesplitBlock) && nBlock <= (splitBlock +  2 * treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
		else if (4 == MyInstanceId && nBlock > (splitBlock + 2 * treesplitBlock))
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
		}
	}

	// if(1 == MyInstanceId)
	// {
	// 	UpdateFreeSpaceMap(rel, splitBlock+1, totalBlocks-1, 0);
	// }
	if(2 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock+1, splitBlock + treesplitBlock, 8152);
	}
	if(3 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock + treesplitBlock + 1, splitBlock +  2 * treesplitBlock, 8152);
	}
	if(4 == MyInstanceId)
	{
		UpdateFreeSpaceMap(rel, splitBlock +  2 * treesplitBlock + 1, totalBlocks-1, 8152);
	}


select 'select expand_fsm_block(' || oid || ',3,0);' from ux_class where oid>=16384;

2021-09-12
3实例：
%Cpu(s): 34.6 us,  4.1 sy,  0.0 ni, 57.5 id,  2.8 wa,  0.0 hi,  1.0 si,  0.0 st
%Cpu(s): 33.7 us,  3.6 sy,  0.0 ni, 60.0 id,  1.4 wa,  0.0 hi,  1.3 si,  0.0 st
%Cpu(s): 25.6 us,  3.2 sy,  0.0 ni, 69.6 id,  1.0 wa,  0.0 hi,  0.6 si,  0.0 st

Term-00, Measured tpmC (NewOrders) = 160037.46
Term-00, Measured tpmTOTAL = 355540.79
Term-00, Session Start     = 2021-09-12 13:55:32
Term-00, Session End       = 2021-09-12 14:00:32
Term-00, Transaction Count = 1777940

instanceid | requests | resourcerequests | readrequests | writerequests | retryreques
ts | timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+------------
---+---------+----------+-------------+----------
          1 |  2534558 |           927789 |       621460 |        985309 |
 0 |       0 |   200771 |     1448349 |   885438
          2 |  1874238 |           644437 |       535416 |        694385 |
 0 |       0 |   205330 |     1058468 |   610440
          3 |  1616932 |           554403 |       455342 |        607187 |
 0 |       0 |   189698 |      906856 |   520378


select ux_freespace(16389, 64525);
select ux_freespace(16389, 96781);


%Cpu(s): 47.5 us,  4.3 sy,  0.0 ni, 44.5 id,  2.5 wa,  0.0 hi,  1.2 si,  0.0 st
%Cpu(s): 29.9 us,  3.8 sy,  0.0 ni, 64.0 id,  1.2 wa,  0.0 hi,  1.1 si,  0.0 st
%Cpu(s): 19.1 us,  2.3 sy,  0.0 ni, 76.7 id,  1.3 wa,  0.0 hi,  0.6 si,  0.0

Term-00, Measured tpmC (NewOrders) = 173692.5
Term-00, Measured tpmTOTAL = 385921.88
Term-00, Session Start     = 2021-09-12 16:27:33
Term-00, Session End       = 2021-09-12 16:32:33
Term-00, Transaction Count = 1929885

 instanceid | requests | resourcerequests | readrequests | writerequests | retryreques
ts | timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+------------
---+---------+----------+-------------+----------
          1 |  2968254 |          1064232 |       764180 |       1139842 |
 0 |       0 |   250344 |     1695279 |  1022631
          2 |  1812045 |           617215 |       521801 |        673029 |
 0 |       0 |   220517 |     1011693 |   579835
          3 |  1712883 |           590232 |       472366 |        650285 |
 0 |       0 |   220011 |      943783 |   549089

2实例：
%Cpu(s): 58.9 us,  4.4 sy,  0.0 ni, 33.0 id,  2.4 wa,  0.0 hi,  1.2 si,  0.0 st
%Cpu(s): 39.2 us,  3.6 sy,  0.0 ni, 54.9 id,  1.1 wa,  0.0 hi,  1.3 si,  0.0 st

17:03:26,759 [Thread-59] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 115596.89
17:03:26,760 [Thread-59] INFO   jTPCC : Term-00, Measured tpmTOTAL = 256940.08
17:03:26,760 [Thread-59] INFO   jTPCC : Term-00, Session Start     = 2021-09-12 16:58:26
17:03:26,760 [Thread-59] INFO   jTPCC : Term-00, Session End       = 2021-09-12 17:03:26
17:03:26,760 [Thread-59] INFO   jTPCC : Term-00, Transaction Count = 1284845

instanceid | requests | resourcerequests | readrequests | writerequests | retryreques
ts | timeout | getblock | buffervalid | readdisk
------------+----------+------------------+--------------+---------------+------------
---+---------+----------+-------------+----------
          1 |  3054367 |          1147262 |       744314 |       1162791 |
 0 |       0 |   122827 |     1805878 |  1125662
          2 |  1593832 |           548302 |       465161 |        580369 |
 0 |       0 |   144476 |      923921 |   525435
(2 rows)




select ux_freespace(16389, 64513);
select ux_freespace(16389, 96770);


2021-09-13

1、查看共享盘分区
ll /dev/disk/by-id

2、登录10.10.10.11服务器配置lun组；


2021-09-14

zhongyou优化后的代码：
Datum
expand_fsm_block(UX_FUNCTION_ARGS)
{
	Oid relOid = UX_GETARG_OID(0);  /* 表的oid */
	int insNum = UX_GETARG_INT32(1); /*实例总数*/
	int blkno = UX_GETARG_INT32(2);  /* 已用掉的块号，实例1无效，其他实例是等值，通过实例1查询select ux_freespace(oid) */
	Relation rel = NULL;
	BlockNumber totalBlocks;
	BlockNumber splitBlock;
	BlockNumber nBlock;
	BlockNumber startBlock,endBlock;
	uint32		alignNum = 512;
	char		result[128] = {0};

	if (!OidIsValid(relOid))
	{
		UX_RETURN_TEXT_P(cstring_to_text("Failed"));
	}

	if (insNum <= InvalidInstanceId || insNum > MAX_INSTANCE_COUNT)
	{
		UX_RETURN_TEXT_P(cstring_to_text("Failed"));
	}

	rel = relation_open(relOid,AccessExclusiveLock);
	if(rel == NULL)
	{
		UX_RETURN_TEXT_P(cstring_to_text("relation_open Failed"));
	}

	totalBlocks = RelationGetNumberOfBlocks(rel);
	/*
	 * 由于数据是在实例1上初始化的，所以分块的时候，要把实例1上用掉的数据块除外
	 * 其他实例，则通过参数传进来，入参的值是在实例1上通过select ux_freespace(oid)可以得出
	 */
	if(1 == MyInstanceId)
	{
		blkno = GetPageWithFreeSpace(rel,8152);
		blkno = (blkno / alignNum + 1) * alignNum;
		sprintf(result,"select expand_fsm_block(%d,%d,%d);",relOid,insNum,blkno);
	}
	else
	{
		sprintf(result,"expand success");
	}

	/*需要分配的总块*/
	 if(blkno > 0)
	 	totalBlocks = totalBlocks - blkno;
	/*开始计算分块*/
	splitBlock = totalBlocks / (insNum + 1);
	//tmpBlock = totalBlocks % (insNum + 1);
	/*
	 * 如果不够512，则采用均分原则
	 * 如果够512，则以512对齐分配，分完后，还有剩余，则分给实例1
	 */
	if(splitBlock >= alignNum)
	{
		/* 512对齐 */
		splitBlock = (splitBlock / alignNum) * alignNum;
	}
	/*开始块号*/
	startBlock = (MyInstanceId) * splitBlock + blkno;
	endBlock = (MyInstanceId+1) * splitBlock + blkno;

	if(1 == MyInstanceId)
	{
		nBlock = endBlock;
		/*
		 * 把剩余的留给实例1
		 * 如果剩余的块号大于512，是不是还需要再进行一次分配呢
		 *    如： 剩下1000，给1分 512 ，给2 分 488，(这种情况暂时没考虑)
		 */
		endBlock = (insNum + 1) * splitBlock + blkno - 1;
		/*清除不在1实例的块*/
		while(nBlock < endBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 0);
			nBlock ++;
		}
		/*UpdateFreeSpaceMap(rel, startBlock, nBlock, 0);*/
	}
	else
	{
		nBlock = startBlock;
		/*标记自己实例的块*/
		while(nBlock < endBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
			nBlock ++;
		}
		UpdateFreeSpaceMap(rel, startBlock, nBlock, 8152);
	}

	relation_close(rel,AccessExclusiveLock);
	UX_RETURN_TEXT_P(cstring_to_text(result));
}



longzhongyou：

Datum
expand_fsm_block(UX_FUNCTION_ARGS)
{
	Oid relOid = UX_GETARG_OID(0);  /* 表的oid */
	int insNum = UX_GETARG_INT32(1); /*实例总数*/
	int blkno = UX_GETARG_INT32(2);  /* 已用掉的块号，实例1无效，其他实例是等值，通过实例1查询select ux_freespace(oid) */
	Relation rel = NULL;
	BlockNumber totalBlocks;
	BlockNumber perBlockAlin;
	BlockNumber nBlock;
	BlockNumber startBlock,endBlock;
	uint32		alignNum = 512;
	uint32		perInsAlin = 0;
	uint32		leftAlinBlock = 0;
	char		result[128] = {0};
	int 		i = 0;
	int			startIndex = 0,endIndex = 0;

	if (!OidIsValid(relOid))
	{
		UX_RETURN_TEXT_P(cstring_to_text("Failed"));
	}

	if (insNum <= InvalidInstanceId || insNum > MAX_INSTANCE_COUNT)
	{
		UX_RETURN_TEXT_P(cstring_to_text("Failed"));
	}

	rel = relation_open(relOid,AccessExclusiveLock);
	if(rel == NULL)
	{
		UX_RETURN_TEXT_P(cstring_to_text("relation_open Failed"));
	}

	totalBlocks = RelationGetNumberOfBlocks(rel);
	/*
	 * 由于数据是在实例1上初始化的，所以分块的时候，要把实例1上用掉的数据块除外
	 * 其他实例，则通过参数传进来，入参的值是在实例1上通过select ux_freespace(oid)可以得出
	 */
	if(1 == MyInstanceId)
	{
		blkno = GetPageWithFreeSpace(rel,8152);
		blkno = (blkno / alignNum + 1) * alignNum; /* 实例1用掉的块号以512对齐 */
		sprintf(result,"select expand_fsm_block(%d,%d,%d);",relOid,insNum,blkno);
	}
	else
	{
		sprintf(result,"expand success");
	}

	/*需要分配的总块*/
	totalBlocks = totalBlocks - blkno;

	/*开始计算分块*/

	perBlockAlin = totalBlocks / alignNum;  /*总块够多少个512 */
	perInsAlin = perBlockAlin / insNum;     /* 每个实例能分多少个512块 */
	leftAlinBlock = perBlockAlin % insNum;  /* 剩多少个512块没有被分 */

	for(i = 1; i <= insNum; i ++)
	{
		int tmpIndex = 0;
		startIndex = endIndex;
		tmpIndex = (i <= leftAlinBlock) ? perInsAlin+1 : perInsAlin;
		endIndex  +=  tmpIndex;
		if(i == MyInstanceId)
		{
			break;
		}
	}

	/*开始块号*/
	startBlock = blkno + startIndex *  alignNum;
	endBlock = blkno + endIndex *  alignNum;

	if(1 == MyInstanceId)
	{

		 nBlock = endBlock;
		/*清除不在1实例的块*/
		while(nBlock < totalBlocks+blkno)
		{
			RecordPageWithFreeSpace(rel, nBlock, 0);
			nBlock ++;
		}
		/*UpdateFreeSpaceMap(rel, startBlock, nBlock, 0);*/
	}
	else
	{
		nBlock = startBlock;
		/*标记自己实例的块*/
		while(nBlock < endBlock)
		{
			RecordPageWithFreeSpace(rel, nBlock, 8152);
			nBlock ++;
		}
		UpdateFreeSpaceMap(rel, startBlock, nBlock, 8152);
	}

	relation_close(rel,AccessExclusiveLock);
	UX_RETURN_TEXT_P(cstring_to_text(result));
}


955:
if (!found && (forkNum != FSM_FORKNUM || res_tag.rnode.relNode >= 16421))
1230:
	if (!isLocalBuf && uxdb_rac && (forkNum != FSM_FORKNUM || res_tag.rnode.relNode >= 16421))


select expand_fsm_block(16389,3,15);
select expand_fsm_block(16392,3,156);
select expand_fsm_block(16395,3,2290763);
select expand_fsm_block(16403,3,324159);
select expand_fsm_block(16406,3,48649);
select expand_fsm_block(16409,3,243091);
select expand_fsm_block(16412,3,3703595);
select expand_fsm_block(16415,3,1302);
select expand_fsm_block(16418,3,4347495);

int avedbnum = numTerminals / dbNums;
conn = DriverManager.getConnection(dbfarms. get(i/avedbnum), dbProps);


uxdb流程规范整理：


2021-09-16

1、
V5代码
117154之后

conn = DriverManager.getConnection(dbfarms. get(i/avedbnum), dbProps);

i：客户端
wareHouseIds.get(i % wareHouseIds.size())  ：仓数
dbfarms.get(terminalWarehouseID % dbNums)  ：jdbc:uxdb://192.72.0.77:5432/uxdb


un.request_msg.masterid;


rebase feature/v2.1.0.6.03r/##118592_v2这个分支代码到目前最新共享存储分支；
修改for update为for share，tpcc测试正常；
分析tpcc warehouseid随机分配问题；


2021-09-16

1、对外项目
http://cd.uxsino.com:19503/projects/dev_uxdb/wiki/%E5%AF%B9%E5%A4%96%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E6%B5%81%E7%A8%8B

对于需要立项研发的项目，需要评估项目工期，确定参与人员；
在readmine建立任务单；


gcs.c:932
	epoch = request_msg->un.pcm_request.epoch;
	managerId = request_msg->header.dest_uuid;

	:2264
	managerId = reply_msg->un.pcm_authorized_reply.masterid;
	:4595
	auth_reply.un.pcm_authorized_reply.masterid = master_instance;
	:2528
	managerId = request_msg->un.pcm_release_forward_request.masterid;

2021-09-18



tpcc加载后台执行命令：
nohup sh runDatabaseBuild.sh props.pg> results.log&

tpcc执行命令：
nohup sh runBenchmark.sh props.pg> results.log&


修改扩展块时区分普通块和索引块报错


共享存储最新分支：
feature/v2.1.0.6.03r/#118614



###Kylin Linux Advanced Server 10 - os repo###

[ks10-adv-cdrom]
name = Kylin Linux Advanced Server 10 - cdrom
baseurl = file:///run/media/root/KYLIN10-SVR
gpgcheck = 0
enabled = 1




./storcli64  /c0  add  vd  r0 drives=252:0,252:1,252:4,252:5
共享存储操作：
1、加载完数据后，执行以下操作：
ALTER SEQUENCE bmsql_hist_id_seq
CACHE 10000;
alter table bmsql_history drop constraint bmsql_history_pkey;



%Cpu(s): 13.3 us,  2.4 sy,  0.0 ni, 83.1 id,  0.2 wa,  0.0 hi,  1.0 si,  0.0 st


段错误：

ulimit -a查看
ulimit -c unlimited设置生成不限制大小
echo "/home/uxdb/uxdbinstall/dbsql/bin/core-%e-%p-%t" > /proc/sys/kernel/core_pattern
echo "1" > /proc/sys/kernel/core_uses_pid
echo "1" > /proc/sys/fs/suid_dumpable （出于安全考虑，suid程序以及调用setuid()的程序缺省情况下不产生core dump）
使文件生效：source /etc/profile



/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.0-directio/src/include/ux_config_manual.h
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.0-directio/src/backend/storage/file/odirect.c




numactl --interleave=all  ./ux_ctl -D /mnt/sd9/racdata -o "-c uxdb_rac=on -c instance_id=1 -p 5432" start

c48
113：%Cpu(s):  9.7 us,  1.6 sy,  0.0 ni, 87.7 id,  0.2 wa,  0.0 hi,  0.8 si,  0.0 st
112：%Cpu(s):  0.8 us,  0.4 sy,  0.0 ni, 98.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st

11:37:45,098 [Thread-26] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 42788.63                11:37:45,098 [Thread-26] INFO   jTPCC : Term-00, Measured tpmTOTAL = 94917.98                        11:37:45,098 [Thread-26] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 11:27:45             11:37:45,099 [Thread-26] INFO   jTPCC : Term-00, Session End       = 2021-10-08 11:37:45             11:37:45,099 [Thread-26] INFO   jTPCC : Term-00, Transaction Count = 949269


113:%Cpu(s):  8.7 us,  1.6 sy,  0.0 ni, 88.8 id,  0.2 wa,  0.0 hi,  0.7 si,  0.0 st
112:%Cpu(s):  0.5 us,  0.2 sy,  0.0 ni, 97.7 id,  1.6 wa,  0.0 hi,  0.0 si,  0.0 st

13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 34848.45                13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Measured tpmTOTAL = 77576.71                        13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 13:06:21             13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Session End       = 2021-10-08 13:16:21             13:16:21,906 [Thread-17] INFO   jTPCC : Term-00, Transaction Count = 775845

修改swappiness：
sysctl -w vm.swappiness=60
sysctl -a|grep vm.swappiness
cat /proc/sys/vm/swappiness

shared_buffer = 32GB:
c48
%Cpu(s):  8.6 us,  2.0 sy,  0.0 ni, 86.3 id,  2.1 wa,  0.0 hi,  1.0 si,  0.0 st
%Cpu(s):  1.2 us,  0.4 sy,  0.0 ni, 97.1 id,  1.2 wa,  0.0 hi,  0.1 si,  0.0 st

16:41:12,629 [Thread-45] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 52919.4                 16:41:12,629 [Thread-45] INFO   jTPCC : Term-00, Measured tpmTOTAL = 117671.99
16:41:12,630 [Thread-45] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 16:36:12
16:41:12,630 [Thread-45] INFO   jTPCC : Term-00, Session End       = 2021-10-08 16:41:12
16:41:12,630 [Thread-45] INFO   jTPCC : Term-00, Transaction Count = 588459

c64
16:48:20,966 [Thread-35] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 68798.84                16:48:20,967 [Thread-35] INFO   jTPCC : Term-00, Measured tpmTOTAL = 152901.81
16:48:20,967 [Thread-35] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 16:43:20
16:48:20,967 [Thread-35] INFO   jTPCC : Term-00, Session End       = 2021-10-08 16:48:20
16:48:20,967 [Thread-35] INFO   jTPCC : Term-00, Transaction Count = 764661

c32

17:00:41,742 [Thread-29] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 92449.0                 17:00:41,742 [Thread-29] INFO   jTPCC : Term-00, Measured tpmTOTAL = 205011.71
17:00:41,742 [Thread-29] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 16:55:41
17:00:41,742 [Thread-29] INFO   jTPCC : Term-00, Session End       = 2021-10-08 17:00:41
17:00:41,743 [Thread-29] INFO   jTPCC : Term-00, Transaction Count = 1025266

c24
17:06:55,964 [Thread-17] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 69525.67                17:06:55,965 [Thread-17] INFO   jTPCC : Term-00, Measured tpmTOTAL = 154732.54
17:06:55,965 [Thread-17] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 17:01:55
17:06:55,965 [Thread-17] INFO   jTPCC : Term-00, Session End       = 2021-10-08 17:06:55
17:06:55,965 [Thread-17] INFO   jTPCC : Term-00, Transaction Count = 773899


shared_buffer = 64GB:
18:23:57,311 [Thread-31] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 73377.0                 18:23:57,312 [Thread-31] INFO   jTPCC : Term-00, Measured tpmTOTAL = 163038.03                       18:23:57,312 [Thread-31] INFO   jTPCC : Term-00, Session Start     = 2021-10-08 18:13:57             18:23:57,312 [Thread-31] INFO   jTPCC : Term-00, Session End       = 2021-10-08 18:23:57             18:23:57,312 [Thread-31] INFO   jTPCC : Term-00, Transaction Count = 1630537

c50（第一次10min）：
09:46:33,710 [Thread-32] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 110790.16
09:46:33,710 [Thread-32] INFO   jTPCC : Term-00, Measured tpmTOTAL = 246314.23
09:46:33,710 [Thread-32] INFO   jTPCC : Term-00, Session Start     = 2021-10-09 09:36:33
09:46:33,710 [Thread-32] INFO   jTPCC : Term-00, Session End       = 2021-10-09 09:46:33
09:46:33,711 [Thread-32] INFO   jTPCC : Term-00, Transaction Count = 2463400

第二次（5min）
c54
 09:52:56,024 [Thread-13] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 137230.01               09:52:56,025 [Thread-13] INFO   jTPCC : Term-00, Measured tpmTOTAL = 304868.55
09:52:56,025 [Thread-13] INFO   jTPCC : Term-00, Session Start     = 2021-10-09 09:47:55
09:52:56,025 [Thread-13] INFO   jTPCC : Term-00, Session End       = 2021-10-09 09:52:56
09:52:56,025 [Thread-13] INFO   jTPCC : Term-00, Transaction Count = 1524606


2021-10-11
绑定cpu测试结果：
c128：
10:27:52,974 [Thread-116] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 6421.06
10:27:52,974 [Thread-116] INFO   jTPCC : Term-00, Measured tpmTOTAL = 14326.84
10:27:52,974 [Thread-116] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:16:43
10:27:52,975 [Thread-116] INFO   jTPCC : Term-00, Session End       = 2021-10-11 10:27:52
10:27:52,975 [Thread-116] INFO   jTPCC : Term-00, Transaction Count = 159746

c72

10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 17892.85
10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Measured tpmTOTAL = 39764.57
10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:29:29
10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Session End       = 2021-10-11 10:39:30
10:39:30,005 [Thread-20] INFO   jTPCC : Term-00, Transaction Count = 398057

c48
10:51:03,923 [Thread-33] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 48245.75
10:51:03,923 [Thread-33] INFO   jTPCC : Term-00, Measured tpmTOTAL = 107182.84
10:51:03,923 [Thread-33] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:41:03
10:51:03,923 [Thread-33] INFO   jTPCC : Term-00, Session End       = 2021-10-11 10:51:03
10:51:03,924 [Thread-33] INFO   jTPCC : Term-00, Transaction Count = 1071915

c32
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 65333.1
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Measured tpmTOTAL = 145222.46
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:51:31
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Session End       = 2021-10-11 10:56:31
10:56:31,197 [Thread-4] INFO   jTPCC : Term-00, Transaction Count = 726288

c56：
11:03:07,920 [Thread-52] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 94963.5
11:03:07,921 [Thread-52] INFO   jTPCC : Term-00, Measured tpmTOTAL = 211123.95
11:03:07,921 [Thread-52] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 10:58:07
11:03:07,921 [Thread-52] INFO   jTPCC : Term-00, Session End       = 2021-10-11 11:03:07
11:03:07,921 [Thread-52] INFO   jTPCC : Term-00, Transaction Count = 1055851

c60：
11:08:52,956 [Thread-12] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 88086.51
11:08:52,957 [Thread-12] INFO   jTPCC : Term-00, Measured tpmTOTAL = 195708.01
11:08:52,957 [Thread-12] INFO   jTPCC : Term-00, Session Start     = 2021-10-11 11:03:52
11:08:52,957 [Thread-12] INFO   jTPCC : Term-00, Session End       = 2021-10-11 11:08:52
11:08:52,957 [Thread-12] INFO   jTPCC : Term-00, Transaction Count = 978800



绑定cpu

c72（2机4实例）：
Term-00, Measured tpmC (NewOrders) = 132680.72
Term-00, Measured tpmTOTAL = 294719.26
Term-00, Session Start     = 2021-10-11 16:00:40
Term-00, Session End       = 2021-10-11 16:10:40
Term-00, Transaction Count = 2947673




预热函数：
create extension ux_prewarm;
select ux_prewarm('bmsql_config');
select ux_prewarm('bmsql_customer');
select ux_prewarm('bmsql_district');
select ux_prewarm('bmsql_hist_id_seq');
select ux_prewarm('bmsql_history');
select ux_prewarm('bmsql_item');
select ux_prewarm('bmsql_new_order');
select ux_prewarm('bmsql_oorder');
select ux_prewarm('bmsql_order_line');
select ux_prewarm('bmsql_stock');
select ux_prewarm('bmsql_warehouse');
select ux_prewarm('bmsql_config_PKEY');
select ux_prewarm('bmsql_customer_idx1');
select ux_prewarm('bmsql_customer_pkey');
select ux_prewarm('bmsql_district_pkey');
select ux_prewarm('bmsql_item_pkey');
select ux_prewarm('bmsql_new_order_pkey');
select ux_prewarm('bmsql_oorder_idx1');
select ux_prewarm('bmsql_oorder_pkey');
select ux_prewarm('bmsql_order_line_pkey');
select ux_prewarm('bmsql_stock_pkey');
select ux_prewarm('bmsql_warehouse_pkey');
select ux_prewarm('NDX_OORDER_2');
checkpoint;


预热后：(目测76并发最高)
c72
 09:29:20,484 [Thread-35] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 129129.39
 09:29:20,485 [Thread-35] INFO   jTPCC : Term-00, Measured tpmTOTAL = 286882.55
 09:29:20,485 [Thread-35] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:19:20
 09:29:20,485 [Thread-35] INFO   jTPCC : Term-00, Session End       = 2021-10-12 09:29:20
09:29:20,485 [Thread-35] INFO   jTPCC : Term-00, Transaction Count = 2869078

c56
09:40:10,875 [Thread-50] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 143355.5
09:40:10,876 [Thread-50] INFO   jTPCC : Term-00, Measured tpmTOTAL = 318688.2
09:40:10,876 [Thread-50] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:30:10
09:40:10,876 [Thread-50] INFO   jTPCC : Term-00, Session End       = 2021-10-12 09:40:10
09:40:10,876 [Thread-50] INFO   jTPCC : Term-00, Transaction Count = 3187290

c52(5min)
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 121848.56
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Measured tpmTOTAL = 270618.88
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:44:22
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Session End       = 2021-10-12 09:49:23
09:49:23,057 [Thread-20] INFO   jTPCC : Term-00, Transaction Count = 1353558

c60：
09:55:43,447 [Thread-15] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 132443.69
09:55:43,447 [Thread-15] INFO   jTPCC : Term-00, Measured tpmTOTAL = 294487.85
09:55:43,448 [Thread-15] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:50:43
09:55:43,448 [Thread-15] INFO   jTPCC : Term-00, Session End       = 2021-10-12 09:55:43
09:55:43,448 [Thread-15] INFO   jTPCC : Term-00, Transaction Count = 1473042

c64
10:04:06,033 [Thread-12] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 132314.47
10:04:06,034 [Thread-12] INFO   jTPCC : Term-00, Measured tpmTOTAL = 294334.1
10:04:06,034 [Thread-12] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 09:59:05
10:04:06,034 [Thread-12] INFO   jTPCC : Term-00, Session End       = 2021-10-12 10:04:06
10:04:06,035 [Thread-12] INFO   jTPCC : Term-00, Transaction Count = 1472425

c68
10:11:04,414 [Thread-47] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 123513.75
10:11:04,415 [Thread-47] INFO   jTPCC : Term-00, Measured tpmTOTAL = 274236.62
10:11:04,415 [Thread-47] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 10:06:04
10:11:04,415 [Thread-47] INFO   jTPCC : Term-00, Session End       = 2021-10-12 10:11:04
10:11:04,415 [Thread-47] INFO   jTPCC : Term-00, Transaction Count = 1371982

c80
10:19:47,851 [Thread-27] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 118316.41
10:19:47,851 [Thread-27] INFO   jTPCC : Term-00, Measured tpmTOTAL = 263138.51
10:19:47,851 [Thread-27] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 10:14:47
10:19:47,851 [Thread-27] INFO   jTPCC : Term-00, Session End       = 2021-10-12 10:19:47
10:19:47,852 [Thread-27] INFO   jTPCC : Term-00, Transaction Count = 1317266



删除外键：

13:09:41,568 [Thread-37] INFO   jTPCC : Term-00,
13:09:41,568 [Thread-37] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 5434.9
13:09:41,569 [Thread-37] INFO   jTPCC : Term-00, Measured tpmTOTAL = 12102.05
13:09:41,569 [Thread-37] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 12:59:41
13:09:41,569 [Thread-37] INFO   jTPCC : Term-00, Session End       = 2021-10-12 13:09:41
13:09:41,569 [Thread-37] INFO   jTPCC : Term-00, Transaction Count = 121124


删除外键，绑定cpu（4节点4实例）
terminals=56
第一次10min：
Measured tpmC (NewOrders) = 7861.83
Measured tpmTOTAL = 17477.04
Session Start     = 2021-10-12 15:09:52
Session End       = 2021-10-12 15:19:52
Transaction Count = 174851

第二次10min：
Measured tpmC (NewOrders) = 28372.13
Measured tpmTOTAL = 63061.02
Session Start     = 2021-10-12 15:21:01
Session End       = 2021-10-12 15:31:01
Transaction Count = 630933


第三次10min：
113：%Cpu(s):  3.3 us,  1.0 sy,  0.0 ni, 86.6 id,  8.5 wa,  0.0 hi,  0.5 si,  0.0 st
112：%Cpu(s):  1.8 us,  0.8 sy,  0.0 ni, 96.6 id,  0.9 wa,  0.0 hi,  0.0 si,  0.0 st
111：%Cpu(s):  2.2 us,  0.7 sy,  0.0 ni, 94.7 id,  2.4 wa,  0.0 hi,  0.1 si,  0.0 st
110：%Cpu(s):  1.6 us,  0.5 sy,  0.0 ni, 93.6 id,  4.2 wa,  0.0 hi,  0.0 si,  0.0 st

Term-00, Measured tpmC (NewOrders) = 53409.85
Term-00, Measured tpmTOTAL = 118643.13
Term-00, Session Start     = 2021-10-12 15:31:15
Term-00, Session End       = 2021-10-12 15:41:15
Term-00, Transaction Count = 1186638

第四次10min：

113：%Cpu(s):  3.9 us,  1.2 sy,  0.0 ni, 86.5 id,  7.9 wa,  0.0 hi,  0.5 si,  0.0 st
112：%Cpu(s):  2.6 us,  0.6 sy,  0.0 ni, 95.1 id,  1.6 wa,  0.0 hi,  0.0 si,  0.0 st
111：%Cpu(s):  1.8 us,  0.5 sy,  0.0 ni, 95.6 id,  2.1 wa,  0.0 hi,  0.1 si,  0.0 st
110：%Cpu(s):  2.3 us,  0.6 sy,  0.0 ni, 94.1 id,  2.9 wa,  0.0 hi,  0.1 si,  0.0 st

Term-00, Measured tpmC (NewOrders) = 72902.37
Term-00, Measured tpmTOTAL = 162225.41
Term-00, Session Start     = 2021-10-12 15:44:23
Term-00, Session End       = 2021-10-12 15:54:24
Term-00, Transaction Count = 1622583


第五次10min：
实例1-实例4cpu：
%Cpu(s):  6.5 us,  1.6 sy,  0.0 ni, 85.4 id,  5.6 wa,  0.0 hi,  0.8 si,  0.0 st
%Cpu(s):  4.2 us,  0.7 sy,  0.0 ni, 92.7 id,  2.3 wa,  0.0 hi,  0.1 si,  0.0 st
%Cpu(s):  3.5 us,  0.7 sy,  0.0 ni, 94.1 id,  1.7 wa,  0.0 hi,  0.0 si,  0.0 st
%Cpu(s):  3.9 us,  0.7 sy,  0.0 ni, 92.3 id,  2.9 wa,  0.0 hi,  0.1 si,  0.0 st

Term-00, Measured tpmC (NewOrders) = 80680.11
Term-00, Measured tpmTOTAL = 179377.06
Term-00, Session Start     = 2021-10-12 15:54:50
Term-00, Session End       = 2021-10-12 16:04:50
Term-00, Transaction Count = 1794245


第六次10min：
%Cpu(s):  7.9 us,  1.6 sy,  0.0 ni, 85.6 id,  4.3 wa,  0.0 hi,  0.6 si,  0.0 st
%Cpu(s):  4.5 us,  0.7 sy,  0.0 ni, 91.8 id,  2.8 wa,  0.0 hi,  0.1 si,  0.0 st
%Cpu(s):  3.8 us,  0.7 sy,  0.0 ni, 93.1 id,  2.3 wa,  0.0 hi,  0.1 si,  0.0 st
%Cpu(s):  4.3 us,  0.7 sy,  0.0 ni, 92.4 id,  2.6 wa,  0.0 hi,  0.1 si,  0.0 st

16:15:59,619 [Thread-28] INFO   jTPCC : Term-00, Measured tpmC (NewOrders) = 86034.63
16:15:59,620 [Thread-28] INFO   jTPCC : Term-00, Measured tpmTOTAL = 191148.37
16:15:59,620 [Thread-28] INFO   jTPCC : Term-00, Session Start     = 2021-10-12 16:05:59
16:15:59,620 [Thread-28] INFO   jTPCC : Term-00, Session End       = 2021-10-12 16:15:59
16:15:59,621 [Thread-28] INFO   jTPCC : Term-00, Transaction Count = 1912053







dd命令测试磁盘读写速度：

dd if=/dev/zero of=/mnt/sd10/test bs=1M count=8192 oflag=direct


2021-10-14

benchmark：
时间9:36-10:26		//50min
加载31仓-143仓		//112仓

134/h

表：							加载						  执行						600min增加			
bmsql_customer					| 17GB						  | 24 GB   				| 7GB
bmsql_district					| 1248kb					  | 1525 MB             	| 1524MB
bmsql_history					| 2532MB                      | 3060 MB             	| 528MB
bmsql_item						| 10MB                        | 10 MB               	| 0MB
bmsql_new_order					| 380MB                       | 644 MB              	| 264MB
bmsql_oorder					| 1899MB                      | 2624 MB             	| 725MB
bmsql_order_line				| 28GB                        | 40 GB               	| 12GB
bmsql_stock						| 33GB                        | 54 GB               	| 21GB
bmsql_warehouse					| 120kb                       | 687 MB              	| 687MB

索引：							加载					  	  执行						600min增加
bmsql_customer_pkey	            | 902.47MB				  	  | 960.83MB            	| 58.36MB
bmsql_district_pkey	            | 256KB                       | 272KB               	| 16KB
bmsql_history_pkey	            | 644.4375MB                  | 772.79MB            	| 128.36MB
bmsql_item_pkey		            | 2224KB                      | 2224MB              	| 0MB
bmsql_new_order_pkey	        | 270.76MB                    | 629.33MB            	| 358.57MB
bmsql_oorder_pkey	            | 902.5MB                     | 1276.4MB            	| 373.9
bmsql_order_line_pkey           | 8.812GB                     | 12.65GB             	| 3.808GB
bmsql_stock_pkey		        | 2148MB                      | 2285.85MB           	| 137.85MB
bmsql_warehouse_pkey	        | 56KB                        | 56KB                	| 0





索引：
之前大小
select ux_relation_size('bmsql_customer_pkey');
 ux_relation_size
------------------
        946315264（902.47MB）
select ux_relation_size('bmsql_district_pkey');
 ux_relation_size
------------------
           262144（256KB）
select ux_relation_size('bmsql_history_pkey');
 ux_relation_size
------------------
        675741696（644.4375MB）
select ux_relation_size('bmsql_item_pkey');
 ux_relation_size
------------------
          2277376（2224KB）
select ux_relation_size('bmsql_new_order_pkey');
 ux_relation_size
------------------
        283910144（270.76MB）
select ux_relation_size('bmsql_oorder_pkey');
 ux_relation_size
------------------
        946315264（902.5MB）
select ux_relation_size('bmsql_order_line_pkey');
 ux_relation_size
------------------
       9462095872（8.812GB）
select ux_relation_size('bmsql_stock_pkey');
 ux_relation_size
------------------
       2252357632（2148MB）
select ux_relation_size('bmsql_warehouse_pkey');
 ux_relation_size
------------------
            57344（56KB）
执行后大小：
select ux_relation_size('bmsql_customer_pkey');
 ux_relation_size
------------------
       1007501312（960.83MB）
uxdb=# select ux_relation_size('bmsql_district_pkey');
 ux_relation_size
------------------
           278528（272KB）
uxdb=# select ux_relation_size('bmsql_history_pkey');
 ux_relation_size
------------------
        810328064（772.79MB）
uxdb=# select ux_relation_size('bmsql_item_pkey');
 ux_relation_size
------------------
          2277376（2224MB）
uxdb=# select ux_relation_size('bmsql_new_order_pkey');
 ux_relation_size
------------------
        659898368（629.33MB）
uxdb=# select ux_relation_size('bmsql_oorder_pkey');
 ux_relation_size
------------------
       1338392576（1276.4MB）
uxdb=# select ux_relation_size('bmsql_order_line_pkey');
 ux_relation_size
------------------
      13581352960（12.65GB）
uxdb=# select ux_relation_size('bmsql_stock_pkey');
 ux_relation_size
------------------
       2396889088（2285.85MB）
uxdb=# select ux_relation_size('bmsql_warehouse_pkey');
 ux_relation_size
------------------
            57344（56KB）


100仓tpcc数据：
ip：192.30.0.110

本地：
directio：
cpu：%Cpu(s): 34.3 us,  3.5 sy,  0.0 ni, 60.1 id,  0.8 wa,  0.0 hi,  1.4 si,  0.0

Term-00, Measured tpmC (NewOrders) = 62107.64          
Term-00, Measured tpmTOTAL = 138217.91                 
Term-00, Session Start     = 2021-10-16 19:37:27       
Term-00, Session End       = 2021-10-16 19:47:27       
Term-00, Transaction Count = 1382344

dev标准版：
cpu：%Cpu(s): 34.3 us,  3.0 sy,  0.0 ni, 61.4 id,  0.0 wa,  0.0 hi,  1.3 si,  0.0
Measured tpmC (NewOrders) = 61902.55          
Measured tpmTOTAL = 137745.6                  
Session Start     = 2021-10-16 20:01:56       
Session End       = 2021-10-16 20:11:56       
Transaction Count = 1377563

107共享盘（模式异步）：
directio：
cpu：%Cpu(s): 12.6 us,  2.7 sy,  0.0 ni, 82.9 id,  1.2 wa,  0.0 hi,  0.6 si,  0.0 st
Term-00, Measured tpmC (NewOrders) = 37984.01                                                                            
Term-00, Measured tpmTOTAL = 84301.27    
Term-00, Session Start     = 2021-10-16 20:47:49                                                                         
Term-00, Session End       = 2021-10-16 20:57:49
Term-00, Transaction Count = 843200

dev标准版：
第一次测试
cpu：%Cpu(s): 34.5 us,  5.6 sy,  0.0 ni, 57.6 id,  0.1 wa,  0.0 hi,  2.3 si,  0.0 st
Term-00, Measured tpmC (NewOrders) =    22389.61
Term-00, Measured tpmTOTAL = 49863.01   
Term-00, Session Start    = 2021-10-16 20:28:40                                                                     
Term-00, Session End       = 2021-10-16 20:38:40
Term-00, Transaction Count = 498738

dev第二次测试
CPU：%Cpu(s): 33.1 us,  5.0 sy,  0.0 ni, 59.9 id,  0.0 wa,  0.0 hi,  1.9 si,  0.0 st
Term-00, Measured tpmC (NewOrders) = 32453.51                                                                           
Term-00, Measured tpmTOTAL = 72075.9    
Term-00, Session Start     = 2021-10-16 21:02:26                                                                        
Term-00, Session End       = 2021-10-16 21:12:26
Term-00, Transaction Count = 720871



pg多并发执行：

uxsql -p 5433 -c “update t1 set info = ‘PG中的隔离级别遵守了sql标准567’;” > results.txt&
uxsql -c “update t1 set info = ‘PG中的隔离级别遵守了sql标准567’;” > 1.txt 2>&1 &


2021-10-18

pg并行查询相关配置参数
https://blog.csdn.net/louxia_xiaohei/article/details/100112557


date;/home/uxdb/uxdbinstall/dbsql/bin/uxsql -p 5432 -c "select ux_prewarm('bmsql_order_line');";date
Mon Oct 18 16:17:40 CST 2021
 ux_prewarm
------------
    8519550
(1 row)

Mon Oct 18 16:33:06 CST 2021

修改max_worker_processes=8
42649 uxdb      20   0 82.918g 0.014t 0.014t S  57.1  5.7   1:57.28 uxdb: uxdb uxdb+
Mon Oct 18 16:46:06 CST 2021
 ux_prewarm
------------
    8519550
(1 row)

Mon Oct 18 17:01:45 CST 2021




造数步骤
一、创建表 ./runSQL.sh props.ux sqlTableCreates
二、灌数据./runLoader.sh props.ux numWarehouses 100
三、创建索引、主键等相关 ./runSQL.sh props.ux sqlIndexCreates
四、创建序列等相关./runSQL.sh props.ux   sqlExtraCreates.pg

./runSQL.sh props.pg sqlTableCreates
./runLoader.sh props.pg numWarehouses 100

./runSQL.sh props.pg sqlIndexCreates
./runSQL.sh props.pg sqlExtraCreates.pg


./runBenchmark.sh props.pg


原生benchmark链接：
 conn=jdbc:uxdb://192.30.0.102:5432/uxdb?enableEnhance=false&initInstanceSize=1


参数：conn=jdbc:uxdb://192.30.0.102:5432/uxdb?enableEnhance=false&initInstanceSize=2&enableHA=false
					tpmTOTAL
1min				60519.91
5min				23072.07
9min				17160.99
10min				16283.08

conn=jdbc:uxdb://192.30.0.102:5432/uxdb?enableEnhance=false&initInstanceSize=1&enableHA=false

1仓，jdbc修改后：
						tpmTOTAL
1min					44731.72
2min					32929.45
3min					28874.02
5min					22693.49
8min					17958.88	
10min					16074.84

原生：
1min					53672.75
2min					45522.48
3min					38651.16
5min					31333.34
8min					25678.51	
10min					22740.15

100仓tpcc数据：

原生数据：
						tpmTOTAL
1min					369097.47
2min					397897.18
3min					406092.47
5min					407470.19
8min					400588.91	
10min					394040.07
tpmC (NewOrders) = 177447.04

启动haproxy后数据：
						tpmTOTAL
1min					369097.47
2min					397897.18
3min					406092.47
5min					407470.19
8min					400588.91	
10min					394040.07
tpmC (NewOrders) = 177447.04


最新jar包
						tpmTOTAL
1min					219326.77
2min					227187.80
3min					231040.16
5min					233341.84
8min					233554.90	
10min					233137.91
tpmC (NewOrders) = 104928.5





postgresql tpcc测试数据：

原生jar包
						tpmTOTAL
1min					980164.74
2min					981555.44
3min					969828.61
5min					940495.23
8min					899066.54	
10min					872706.7
tpmC (NewOrders) = 392633.01

最新jar包
						tpmTOTAL
1min					1130119.48
2min					1124095.63
3min					1104315.95
5min					1056927.76
8min					985092.86	
10min					952889.23
tpmC (NewOrders) = 428592.11



		


pg最优参数设置

/mnt/sd9/racdata/instances/1/uxsinodb.conf
未注释
max_connections = 600
shared_buffers = 20GB
listen_addresses = '*'
log_timezone = 'PRC'

已注释：
huge_pages = off
work_mem = 1GB
maintenance_work_mem = 2GB
dynamic_shared_memory_type = posix
bgwriter_delay = 20ms
bgwriter_lru_maxpages = 1000
bgwriter_lru_multiplier = 10.0
effective_io_concurrency = 2
wal_buffers = 1GB
checkpoint_timeout = 1d
max_wal_size = 100GB
checkpoint_completion_target = 0.8
effective_cache_size = 128GB
update_process_title = off
track_activities = off
log_statement = 'none'
max_wal_senders=0
logging_collector=off
krb_server_keyfile=’’


"/mnt/sd9/racdata/super_rac.conf"
未注释
datestyle = 'iso, mdy'
已注释：
wal_level = minimal
fsync = off
synchronous_commit = off
heartbeat_try_times = 60
rac_debuglog_mask=0
global_deadlock_check_period_seconds=120
lc_time = 'en_US.UTF-8'
lc_messages = 'en_US.UTF-8'
lc_monetary = 'en_US.UTF-8'
lc_numeric = 'en_US.UTF-8'
timezone = 'PRC'
wal_writer_delay = 20ms
full_page_writes = off
wal_sync_method = open_sync
commit_siblings = 16
autovacuum = off




feature/v2.1.0.6.03r/#109187


旧包：
					tpmc
1min				264814.58				
3min				260305.02
4min				254647.93	
5min				248893.94				
10min				232660.02

新包：
					tpmc
1min				238244.80				
3min				234256.98
4min				229846.17	
5min				226897.64				
10min				211063.57

旧包：
					tpm
1min				272814.26				
3min				283870.14	
5min				277479.28				
10min				264461.37

新包：
					tpm
1min				246881.26			
3min				238456.76	
5min				230389.40				
10min				218670.67




新编译：
					tpm
5min				269119.10				
10min				257554.69

旧包：
					tpm
5min				267890.30			
10min				257936.59

新包：
					tpm
5min				270530.46			
10min				257158.44

27号第一次包：
tpmTOTAL = 244424.42

RESOURCE_CODE_IF







共享存储最新修改：
/home/uxdb/uxdb-ng/uxdb-2.0-directio/src/backend/utils/rac/grd/nonpcm_bufmgr.c	//+2076
if (!uxdb_rac || resCode == RESOURCE_CODE_IF)

2021-11-02
1、postgres国内社区：
http://www.postgres.cn/v2/about




2021-11-11

1、windows转linux行尾符转换命令：
/bin/bash^M
sed -i "s/\r//" build.sh



2021-11-15

1、haproxy 负载均衡原理


2、pg连接池	pgbouncer
https://www.cnblogs.com/shuaixf/archive/2012/10/02/2710432.html

uxpool





8）SQLFetchScoll 
16）SQLGetStmtAttr


SQLGetDescField_1


./odbcTestPro --gtest_filter=ODBCTest.SQLGetDescField_1


haproxy


2021-11-17

haproxy调研

1、克隆代码：
git clone  https://gitee.com/mirrors/haproxy.git
2、切换到2.4版本
git reset --hard 6cbbecf09734aeb5fa8bb88f36f06a6f6d35e813


haproxy2.4编译安装：
make clean
make -j $(nproc) TARGET=linux-glibc USE_OPENSSL=1 USE_PCRE=1 USE_SYSTEMD=1
sudo make install


pgpool调研：

进程池代码分析：
https://www.cnblogs.com/gaojian/archive/2012/08/05/2623778.html

pgpool英文文档：
https://www.pgpool.net/mediawiki/index.php/Main_Page


2021-11-18

CI构建：

报告时间	构建成功率	构建次数	构建成功次数	失败环节	提交人	失败原因	是否修复			
2021/11/19	100%			1			1

RAC：
日志路径：/home/uxdb/.jenkins/workspace/unit_test/TestScript/log

The sum of running testcase is 1951
The sum of pass testcase is 0
The sum of fail testcase is 1951

错误"could not connect to server"个数：1648
错误"No such file or directory"个数：298
错误"SyntaxError: invalid syntax"个数：3
错误"IOError"个数：2
已统计错误总数：1951


sql:
/home/uxdb/.jenkins/workspace/unit_test/TestScript/CI_FailTestCaseLogCount/
/home/uxdb/.jenkins/workspace/unit_test/TestScript/CI_TestReportList/

错误"could not connect to server"个数：26
错误"error,the result is different to expect"个数：0
错误"parameter "(.*?)" cannot be changed now"个数：0
错误"parameter "(.*?)" cannot be changed without restarting the server"个数：1
错误"role "(.*?)" does not exist"个数：1
错误"the database system is in recovery mode"个数：0

报错信息查看：
/home/uxdb/.jenkins/jobs/unit_test/builds/169







单节点：
shared_buffers = 40GB
terminals=100

2021-11-19 21:59:03,878  INFO - Term-00, Measured tpmC (NewOrders) = 35346.2                
2021-11-19 21:59:03,878  INFO - Term-00, Measured tpmTOTAL = 78376.08                       
2021-11-19 21:59:03,879  INFO - Term-00, Session Start     = 2021-11-19 21:39:03            
2021-11-19 21:59:03,879  INFO - Term-00, Session End       = 2021-11-19 21:59:03            
2021-11-19 21:59:03,879  INFO - Term-00, Transaction Count = 1567893

shared_buffers = 40GB
terminals=200

2021-11-19 22:25:40,296  INFO - Term-00, Measured tpmC (NewOrders) = 43473.78               
2021-11-19 22:25:40,296  INFO - Term-00, Measured tpmTOTAL = 96471.82                       
2021-11-19 22:25:40,296  INFO - Term-00, Session Start     = 2021-11-19 22:05:38            
2021-11-19 22:25:40,296  INFO - Term-00, Session End       = 2021-11-19 22:25:40            
2021-11-19 22:25:40,297  INFO - Term-00, Transaction Count = 1932148 

shared_buffers = 40GB
terminals=300
2021-11-19 23:32:52,984  INFO - Term-00,                                                    
2021-11-19 23:32:52,984  INFO - Term-00, Measured tpmC (NewOrders) = 45008.05               
2021-11-19 23:32:52,984  INFO - Term-00, Measured tpmTOTAL = 99954.93                       
2021-11-19 23:32:52,984  INFO - Term-00, Session Start     = 2021-11-19 23:12:52            
2021-11-19 23:32:52,985  INFO - Term-00, Session End       = 2021-11-19 23:32:52            
2021-11-19 23:32:52,985  INFO - Term-00, Transaction Count = 1999779 

shared_buffers = 40GB
terminals=400

2021-11-19 23:57:13,174  INFO - Term-00, Measured tpmC (NewOrders) = 43640.23
2021-11-19 23:57:13,174  INFO - Term-00, Measured tpmTOTAL = 97058.93
2021-11-19 23:57:13,174  INFO - Term-00, Session Start     = 2021-11-19 23:37:12
2021-11-19 23:57:13,174  INFO - Term-00, Session End       = 2021-11-19 23:57:13
2021-11-19 23:57:13,174  INFO - Term-00, Transaction Count = 1942535


shared_buffers = 40GB
terminals=500

log4j:WARN Failure in post-close rollover action                                                                
2021-11-20 00:42:39,283  INFO - Term-00,                                                                        
2021-11-20 00:42:39,284  INFO - Term-00, Measured tpmC (NewOrders) = 43998.46                                   
2021-11-20 00:42:39,284  INFO - Term-00, Measured tpmTOTAL = 97737.16                                           
2021-11-20 00:42:39,284  INFO - Term-00, Session Start     = 2021-11-20 00:22:38                                
2021-11-20 00:42:39,285  INFO - Term-00, Session End       = 2021-11-20 00:42:39                                
2021-11-20 00:42:39,285  INFO - Term-00, Transaction Count = 1955990

shared_buffers = 40GB
terminals=600
2021-11-20 09:35:42,235  INFO - Term-00, Measured tpmC (NewOrders) = 41092.47                                   
2021-11-20 09:35:42,236  INFO - Term-00, Measured tpmTOTAL = 91487.12                                           
2021-11-20 09:35:42,236  INFO - Term-00, Session Start     = 2021-11-20 09:15:41                                
2021-11-20 09:35:42,236  INFO - Term-00, Session End       = 2021-11-20 09:35:42                                
2021-11-20 09:35:42,237  INFO - Term-00, Transaction Count = 1831152

shared_buffers = 40GB
terminals=700

2021-11-20 10:00:33,794  INFO - Term-00, Measured tpmC (NewOrders) = 41967.67                                   
2021-11-20 10:00:33,794  INFO - Term-00, Measured tpmTOTAL = 93189.35                                           
2021-11-20 10:00:33,794  INFO - Term-00, Session Start     = 2021-11-20 09:40:33                                
2021-11-20 10:00:33,809  INFO - Term-00, Session End       = 2021-11-20 10:00:33                                
2021-11-20 10:00:33,809  INFO - Term-00, Transaction Count = 1864822

shared_buffers = 40GB
terminals=800

2021-11-20 10:24:42,695  INFO - Term-00, Measured tpmC (NewOrders) = 41232.9                                    
2021-11-20 10:24:42,695  INFO - Term-00, Measured tpmTOTAL = 91807.64                                           
2021-11-20 10:24:42,695  INFO - Term-00, Session Start     = 2021-11-20 10:04:41                                
2021-11-20 10:24:42,696  INFO - Term-00, Session End       = 2021-11-20 10:24:42                                
2021-11-20 10:24:42,696  INFO - Term-00, Transaction Count = 1837194

shared_buffers = 40GB
terminals=1000

2021-11-20 10:47:54,311  INFO - Term-00, Measured tpmC (NewOrders) = 39151.38                                   
2021-11-20 10:47:54,311  INFO - Term-00, Measured tpmTOTAL = 86993.54                                           
2021-11-20 10:47:54,312  INFO - Term-00, Session Start     = 2021-11-20 10:27:52                                
2021-11-20 10:47:54,312  INFO - Term-00, Session End       = 2021-11-20 10:47:54                                
2021-11-20 10:47:54,312  INFO - Term-00, Transaction Count = 1742719




双节点

主备模式，然后开启负载均衡



性能监控：
nomn介绍：
https://www.cnblogs.com/kaymi/p/11281675.html


两节点：
主：
wal_level = replica
max_connections = 1024
shared_buffers=40GB
maintenance_work_mem=8GB
wal_buffers=1GB
effective_cache_size=64GB
bgwriter_delay = 100ms
bgwriter_lru_maxpages = 500
bgwriter_lru_multiplier = 5.0
effective_io_concurrency = 0
synchronous_commit = off
max_wal_size = 32GB
min_wal_size = 4GB
random_page_cost = 1.1
fsync = off
checkpoint_timeout = 30min


hot_standby = on
max_wal_senders = 3
wal_keep_segments = 64 
full_page_writes = on 
wal_log_hints = on




流复制修改配置文件：
ux_hba.conf
uxsinodb.conf

五分钟后下降

10仓
2021-11-21 10:11:24,096  INFO - Term-00, Measured tpmC (NewOrders) = 77366.12                                   
2021-11-21 10:11:24,096  INFO - Term-00, Measured tpmTOTAL = 171860.6                                           
2021-11-21 10:11:24,096  INFO - Term-00, Session Start     = 2021-11-21 09:51:23                                
2021-11-21 10:11:24,096  INFO - Term-00, Session End       = 2021-11-21 10:11:24                                
2021-11-21 10:11:24,096  INFO - Term-00, Transaction Count = 3439620









dstat -C 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31 -D /dev/mapper/vg_home-lv_home -g -m -n -ipc --top-io --top-cpu --top-mem --output dstat_10.csv 5

./uxpool  -n -D -f ../etc/uxpool.conf  > /home/uxdb/uxdbinstall/uxpool/log/uxpool.log 2>&1 &

num_init_children

配置异步模式：

未打开负载均衡：
tpmTOTAL = 9.3

打开负载均衡：


主机：%Cpu(s): 63.2 us, 25.8 sy,  0.0 ni,  1.1 id,  0.0 wa,  0.0 hi, 10.0 si,  0.0 st

备机：%Cpu(s):  5.3 us,  6.6 sy,  0.0 ni, 86.4 id,  0.8 wa,  0.0 hi,  1.0 si,  0.0 st







单节点：
不带uxpool：
warehouses=100
terminals=1000
runMins=10

%Cpu(s): 77.2 us, 13.9 sy,  0.0 ni,  4.4 id,  1.9 wa,  0.0 hi,  2.6 si,  0.0 st

2021-11-21 20:25:38,598  INFO - Term-00, Measured tpmC (NewOrders) = 73966.98               
2021-11-21 20:25:38,598  INFO - Term-00, Measured tpmTOTAL = 164746.74                      
2021-11-21 20:25:38,598  INFO - Term-00, Session Start     = 2021-11-21 20:15:36            
2021-11-21 20:25:38,598  INFO - Term-00, Session End       = 2021-11-21 20:25:38            
2021-11-21 20:25:38,598  INFO - Term-00, Transaction Count = 1654416

带uxpool：
warehouses=100
terminals=1000
runMins=10

2021-11-21 20:41:53,649  INFO - Term-00, Measured tpmC (NewOrders) = 47612.54               
2021-11-21 20:41:53,649  INFO - Term-00, Measured tpmTOTAL = 105716.62                      
2021-11-21 20:41:53,649  INFO - Term-00, Session Start     = 2021-11-21 20:31:53            
2021-11-21 20:41:53,649  INFO - Term-00, Session End       = 2021-11-21 20:41:53            
2021-11-21 20:41:53,649  INFO - Term-00, Transaction Count = 1058159


双节点：

关闭负载均衡 		//load_balance_mode = off

warehouses=100
terminals=1000
runMins=10

2021-11-21 20:59:39,396  INFO - Term-00, Measured tpmC (NewOrders) = 42353.53               
2021-11-21 20:59:39,397  INFO - Term-00, Measured tpmTOTAL = 94206.88                       
2021-11-21 20:59:39,397  INFO - Term-00, Session Start     = 2021-11-21 20:49:37            
2021-11-21 20:59:39,397  INFO - Term-00, Session End       = 2021-11-21 20:59:39            
2021-11-21 20:59:39,397  INFO - Term-00, Transaction Count = 945508



打开负载均衡 		//load_balance_mode = on
warehouses=100
terminals=1000
runMins=10

2021-11-21 21:17:08,772  INFO - Term-00, Measured tpmC (NewOrders) = 42978.08               
2021-11-21 21:17:08,772  INFO - Term-00, Measured tpmTOTAL = 95515.58                       
2021-11-21 21:17:08,772  INFO - Term-00, Session Start     = 2021-11-21 21:07:07            
2021-11-21 21:17:08,772  INFO - Term-00, Session End       = 2021-11-21 21:17:08            
2021-11-21 21:17:08,772  INFO - Term-00, Transaction Count = 957522



jdbc改造后：
warehouses=100
terminals=1000
runMins=10

2021-11-21 22:39:30,283  INFO - Term-00, Measured tpmC (NewOrders) = 100392.36
2021-11-21 22:39:30,283  INFO - Term-00, Measured tpmTOTAL = 222857.72
2021-11-21 22:39:30,283  INFO - Term-00, Session Start     = 2021-11-21 22:19:29
2021-11-21 22:39:30,283  INFO - Term-00, Session End       = 2021-11-21 22:39:30
2021-11-21 22:39:30,283  INFO - Term-00, Transaction Count = 4461191


jdbc改造后第二次：
warehouses=100
terminals=1000
runMins=10
2021-11-22 09:50:03,330  INFO - Term-00, Measured tpmC (NewOrders) = 103904.8               
2021-11-22 09:50:03,331  INFO - Term-00, Measured tpmTOTAL = 230541.38                      
2021-11-22 09:50:03,331  INFO - Term-00, Session Start     = 2021-11-22 09:40:02            
2021-11-22 09:50:03,331  INFO - Term-00, Session End       = 2021-11-22 09:50:03            
2021-11-22 09:50:03,331  INFO - Term-00, Transaction Count = 2308164


url=jdbc:uxdb://192.72.0.62:5432,192.72.0.63:5432/uxdb
enable=false

单节点：
数据库：debug版  
shared_buffers = 16GB
warehouses=100
terminals=1000
runMins=10

2021-11-22 13:59:28,254  INFO - Term-00, Measured tpmC (NewOrders) = 75519.81               
2021-11-22 13:59:28,254  INFO - Term-00, Measured tpmTOTAL = 168197.46                      
2021-11-22 13:59:28,254  INFO - Term-00, Session Start     = 2021-11-22 13:49:25            
2021-11-22 13:59:28,254  INFO - Term-00, Session End       = 2021-11-22 13:59:28            
2021-11-22 13:59:28,255  INFO - Term-00, Transaction Count = 1688724


主备节点：


2021-11-22 14:24:32,254  INFO - Term-00, Measured tpmC (NewOrders) = 111472.6               
2021-11-22 14:24:32,254  INFO - Term-00, Measured tpmTOTAL = 247833.92                      
2021-11-22 14:24:32,254  INFO - Term-00, Session Start     = 2021-11-22 14:14:31            
2021-11-22 14:24:32,254  INFO - Term-00, Session End       = 2021-11-22 14:24:32            
2021-11-22 14:24:32,254  INFO - Term-00, Transaction Count = 2481304

提升47.6%


单节点：
shared_buffers = 16GB
warehouses=100
terminals=1000
runMins=20

2021-11-22 14:56:51,454  INFO - Term-00, Measured tpmC (NewOrders) = 74103.67               
2021-11-22 14:56:51,454  INFO - Term-00, Measured tpmTOTAL = 164707.31                      
2021-11-22 14:56:51,455  INFO - Term-00, Session Start     = 2021-11-22 14:36:48            
2021-11-22 14:56:51,455  INFO - Term-00, Session End       = 2021-11-22 14:56:51            
2021-11-22 14:56:51,455  INFO - Term-00, Transaction Count = 3302570


主备节点：


2021-11-23 09:48:59,020  INFO - Term-00, Measured tpmC (NewOrders) = 110284.03                    
2021-11-23 09:48:59,020  INFO - Term-00, Measured tpmTOTAL = 244943.34                            
2021-11-23 09:48:59,020  INFO - Term-00, Session Start     = 2021-11-23 09:28:58                  
2021-11-23 09:48:59,020  INFO - Term-00, Session End       = 2021-11-23 09:48:59                  
2021-11-23 09:48:59,020  INFO - Term-00, Transaction Count = 4902087



jdbc添加配置文件后，验证 shared_buffers=16G，terminals = 100，tpcc性能数据，
验证
tpcc 10min，单节点 tpmc = 75519.81，主备节点模式下 tpmc = 111472.6，性能提升；47.6%
tpcc 20min，单节点 tpmc = 74103.67，主备节点模式下 tpmc = 110284.03，性能提升；48.8%

时间设置为20min后，tpcc报冲突报错后，tpcc链接断开，
原因是备库在wal流中获取更新数据时，而更新将正在运行的查询当前正在访问的数据无效，
在这种情况下报错；
解决方法：备机将参数max_standby_streaming_delay = 600s，login_idle_time = 3000；它允许备库特意增加延迟以允许查询完成。
由于备机只有一两个进程处于工作状态，数据库存在连接超时设置，超过5min数据库会断开链接，
将login_idle_time设置3000，目前测试错误未复现
















conn=jdbc:uxdb://192.72.0.62:5432,192.72.0.63:5432/uxdb?maxActive=200&initialSize=200




2021-1203
性能测试总结
1、通过火焰图查看哪个函数调用次数最频繁
火焰图分析：
1、宽度越宽，性能损耗越多

2、查看

 通知下大家，每个人需要写一个总结回顾，包括工作贡献，团队贡献，岗位符合度的回顾（岗位的理解，岗位产出，不足等），流程规范方面（规范的理解，用到那些规范，建议）；对自己规划及改进，以及建议等其它方面。

这个文档的用途：1、年终总结； 2、和每个员工要沟通，岗位理解，产出，不足，规划等。所以最后是对岗位，流程，工作产出，不足等多方面能总结回顾到

总结里面再加一些：可以从工作项目和公司日常两方面，各列几项认为做的好的和做的不好的事；
比如版本里面某件事认为比较好；公司日常，包括管理，活动，考勤，加班等等

这个文档格式不限，PPT，doc都可以。 不一定需要讲解，但是会每个人都沟通。

截止时间是周五中午前交给我。ps 实习生可以不写。


1、工作贡献、团队贡献、岗位的理解，岗位产出，不足等

2、流程规范方面（规范的理解，用到哪些规范，建议）

3、自我规划及改进，建议

1、团队贡献：
wal日
uxpool连接池培训

2、岗位符合度的回顾（岗位的理解，岗位产出，不足等）
主要进行需求分析、需求理解、功能设计、实现和测试


3、流程规范方面（规范的理解，用到那些规范，建议）
4、自我规划及改进



自我规划：




工作内容：
缺陷
1、tpcc稳定性测试
2、make check_32_ora不通过
总工时：1786
产品服务部：193h
1、2.1.0.4s迭代开发				11.4%
主要处理版本稳定性、wal日志、列加密、make check修复相关问题
8+4+1+3+11+9+20+56+8+11=131h	7.3%

2、安全版重构
分别在安全模式和安全兼容模式，验证bin工具、插件、高可用工具可用性；
20+8+26+8=62h					4.1%


对外支持：工时：546h			30%
1、信创支持：
在线升级和节点故障问题分析
2、28所项目支持
主要进行语法兼容开发
3、重庆粮食局支持
mysql默认配置时大小写问题
4、保密四期支持
主要处理initdb、uxaudit审计日志等相关问题
5、区域化项目支持：
分析ADO.NET连接uxdb数据库
6、GFKD数据库适配项目支持
用户密码加密大小写、初始化添加表注释问题
7、重庆传晟项目支持
流复制备机wal日志损坏问题



rac组：工时：1047h				58.6%
1、direct io接口开发
2、表文件、离线恢复相关wal日志接口等接口替换
3、各进程共享内存初始化大小开发
4、ASCII、GB18030、UTF8等多语言字符集移植
5、rac审计代码移植
6、表、索引扩展块相关代码修改
7、dio性能分析
8、查看pg消耗内存计算方法
9、fsm分块代码修改
10、dev、dio、nfs打包脚本修改
11、nci接口移植
12、haproxy改造计划，进行高可用预研



支持：
postgres_adaptor插件更新
信创支持：
验证在线升级和节点故障

28所项目支持：
语法相关支持

重庆粮食局：
兼容mysql默认大小写；

保密四期支持：
根据现场需求实现相关功能；

区域化项目支持：
ADO.NET连接SQLServer数据库

电子五所：


GFKD数据库适配：

重庆传晟：



1、完成oracle与uxdb merge功能差异整理
2、协助查看语法打开make check问题

1、整理安全功能的身份鉴别
2、uxmpp环境搭建

1、年度述职报告（完成100%）
2、处理问题单100331，报错为强仿数据参数

1、wal日志培训
2、解决问题单100331

1：2.1.0.4s安全版打包
2：安全版已解决缺陷功能验证

完成2.1.0.4s已解决问题单验证、
分析问题单100403mpp分片后数据迁移报错

100403mpp分片后数据迁移已定位清楚报错原因
分析mpp分片后，where in子句元组ctid描述符操作报错

2.1.0.4s打包已解决问题单验证

#101492：安全版make  check报错问题分析

101492：完成安全版make check分析，
目前测试用例brin 、gist、 spgist、 privileges已修改验证
101492：安全版make check测试用例修改（完成50%）

部门述职报告会议；
参加自访控制分享会议；
安全版make check报错修改

修改make check报错，提交make check修改用例
安全版make check部分代码提交mr
安全版审计代码检视
1、别名代码修改并提交MR
2、sysdate语法兼容修改，并提交MR

28所支持，完善sysdate代码

1、number类型兼容分析mr合入
2、安全版make check修改检视意见
3、storage语法兼容分析

1、#102306：storage语法功能调研
2、#102373：脚本调用uxsql时指定密码修改并提交mr

解决make check报错问题，目前剩余6个sql文件待解决

make check分析在非超级用户模式下，强转uxdb模式下的类型报错，
目前分析原因由于安全版命名空间链表导致

1、分析make check报错问题
2、兼容LINUX环境下 mysql 默认配置时大小写的行为
兼容mysql大小写行为，目前存在问题：
1、initdb初始化存在大小写不匹配问题
2、make check中有4种sql语句目前未转换

#102680：兼容LINUX环境下 mysql 默认配置时大小写的行为
整理重庆粮食大小写敏感文档，并上传至redmine
涉密版本需求支持
保密四期支持
将uxsinodb.login文件信息加入ux_login_table表中，且增加上次失败字段：
配置ADO.NET连接SQLServer数据库，链接成功，需分析web.config链接sqlserver数据库方式
#106134 ：CDPS代码合入支持。
2、支持国防科大项目
begin语句改造
销售四级安全功能规范文档编写
区域化项目支持




	
#129390:ux_cron、repmgr插件提示模式不存在，ux_cron extension插件未加载等问题		10h
#127403:【2114s】工具、插件、高可用工具验证											8h
#110025:软江项目uxpool问题															24h

42h
#127403:【2114s】工具、插件、高可用工具验证											8h
#110025:软江项目uxpool问题															24h


报错语句：
SELECT ts,           
CASE WHEN last_xact_replay_timestamp IS NULL             THEN 0::INT           ELSE             EXTRACT(epoch FROM (ux_catalog.clock_timestamp() - last_xact_replay_timestamp))::INT                    END AS replication_lag_time

FROM (  SELECT CURRENT_TIMESTAMP AS ts,         ux_catalog.ux_is_in_recovery() AS in_recovery,         ux_catalog.ux_last_xact_replay_timestamp() AS last_xact_replay_timestamp,         COALESCE(ux_catalog.ux_last_wal_receive_lsn(), '0/0'::UX_LSN) AS last_wal_receive_lsn,         COALESCE(ux_catalog.ux_last_wal_replay_lsn(),  '0/0'::UX_LSN) AS last_wal_replay_lsn,         
CASE WHEN ux_catalog.ux_is_in_recovery() IS FALSE           THEN FALSE           ELSE ux_catalog.ux_is_wal_replay_paused()         END AS wal_replay_paused,         
CASE WHEN ux_catalog.ux_is_in_recovery() IS FALSE           THEN -1           ELSE repmgr.get_upstream_last_seen()         END AS upstream_last_seen           ) q;

实际报错语句：
SELECT EXTRACT(epoch FROM (ux_catalog.clock_timestamp()))::INT from ux_catalog.ux_last_xact_replay_timestamp() AS last_xact_replay_timestamp;

报错（循环第三次）：
ParseFuncOrColumn		//305：正常应该fdresult == FUNCDETAIL_NORMAL
	func_get_detail		//1539：正常ncandidates应该等于1
		func_match_argtypes	//930： 第二次循环，条件为真
			can_coerce_type
		
(gdb) p inputTypeId
$9 = 705
(gdb) p targetTypeId
$10 = 25


305行：
正常应该：
fdresult == FUNCDETAIL_NORMAL


122             if (fn && fn->agg_filter != NULL)
(gdb)
133             if (list_length(fargs) > FUNC_MAX_ARGS)
(gdb)
153             nargs = 0;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
156                     Node       *arg = lfirst(l);
(gdb)
157                     Oid                     argtype = exprType(arg);
(gdb)
159                     nextl = lnext(l);
(gdb)
161                     if (argtype == VOIDOID && IsA(arg, Param) &&
(gdb)
168                     actual_arg_types[nargs++] = argtype;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
156                     Node       *arg = lfirst(l);
(gdb)
157                     Oid                     argtype = exprType(arg);
(gdb)
159                     nextl = lnext(l);
(gdb)
161                     if (argtype == VOIDOID && IsA(arg, Param) &&
(gdb)
168                     actual_arg_types[nargs++] = argtype;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
179             argnames = NIL;
(gdb)
180             foreach(l, fargs)
(gdb)
182                     Node       *arg = lfirst(l);
(gdb)
184                     if (IsA(arg, NamedArgExpr))
(gdb)
203                             if (argnames != NIL)
(gdb)
180             foreach(l, fargs)
(gdb)
182                     Node       *arg = lfirst(l);
(gdb)
184                     if (IsA(arg, NamedArgExpr))
(gdb)
203                             if (argnames != NIL)
(gdb)
180             foreach(l, fargs)
(gdb)
211             if (fargs)
(gdb)
213                     first_arg = linitial(fargs);
(gdb)
228                                                        list_length(funcname) == 1 &&
(gdb)
224             could_be_projection = (nargs == 1 && !proc_call &&
(gdb)
235             if (could_be_projection && is_column)
(gdb)
265             setup_parser_errposition_callback(&pcbstate, pstate, location);
(gdb)
272                                                                &declared_arg_types, &argdefaults);
(gdb)
269                                                                !func_variadic, true,
(gdb)
267             fdresult = func_get_detail(funcname, fargs, argnames, nargs,
(gdb)
274             cancel_parser_errposition_callback(&pcbstate);
(gdb)
281             if (proc_call &&
(gdb)
295             if (fdresult == FUNCDETAIL_PROCEDURE && !proc_call)
(gdb)
305             if (fdresult == FUNCDETAIL_NORMAL ||
(gdb)
306                     fdresult == FUNCDETAIL_PROCEDURE ||
(gdb)
355             if (fdresult == FUNCDETAIL_NORMAL || fdresult == FUNCDETAIL_PROCEDURE)
(gdb)
359             else if (fdresult == FUNCDETAIL_AGGREGATE)
(gdb)
514             else if (fdresult == FUNCDETAIL_WINDOWFUNC)
(gdb)
533             else if (fdresult == FUNCDETAIL_COERCION)
(gdb)
543             else if (fdresult == FUNCDETAIL_MULTIPLE)
(gdb)
581                     if (is_column)
(gdb)
587                     if (could_be_projection)
(gdb)
601                     if (list_length(agg_order) > 1 && !agg_within_group)
(gdb)
614                     else if (proc_call)
(gdb)
624                             ereport(ERROR,



正常：

122             if (fn && fn->agg_filter != NULL)
(gdb)
133             if (list_length(fargs) > FUNC_MAX_ARGS)
(gdb)
153             nargs = 0;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
156                     Node       *arg = lfirst(l);
(gdb)
157                     Oid                     argtype = exprType(arg);
(gdb)
159                     nextl = lnext(l);
(gdb)
161                     if (argtype == VOIDOID && IsA(arg, Param) &&
(gdb)
168                     actual_arg_types[nargs++] = argtype;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
156                     Node       *arg = lfirst(l);
(gdb)
157                     Oid                     argtype = exprType(arg);
(gdb)
159                     nextl = lnext(l);
(gdb)
161                     if (argtype == VOIDOID && IsA(arg, Param) &&
(gdb)
168                     actual_arg_types[nargs++] = argtype;
(gdb)
154             for (l = list_head(fargs); l != NULL; l = nextl)
(gdb)
179             argnames = NIL;
(gdb)
180             foreach(l, fargs)
(gdb)
182                     Node       *arg = lfirst(l);
(gdb)
184                     if (IsA(arg, NamedArgExpr))
(gdb)
203                             if (argnames != NIL)
(gdb)
180             foreach(l, fargs)
(gdb)
182                     Node       *arg = lfirst(l);
(gdb)
184                     if (IsA(arg, NamedArgExpr))
(gdb)
203                             if (argnames != NIL)
(gdb)
180             foreach(l, fargs)
(gdb)
211             if (fargs)
(gdb)
213                     first_arg = linitial(fargs);
(gdb)
228                                                        list_length(funcname) == 1 &&
(gdb)
224             could_be_projection = (nargs == 1 && !proc_call &&
(gdb)
235             if (could_be_projection && is_column)
(gdb)
265             setup_parser_errposition_callback(&pcbstate, pstate, location);
(gdb)
272                                                                &declared_arg_types, &argdefaults);
(gdb)
269                                                                !func_variadic, true,
(gdb)
267             fdresult = func_get_detail(funcname, fargs, argnames, nargs,
(gdb)
274             cancel_parser_errposition_callback(&pcbstate);
(gdb)
281             if (proc_call &&
(gdb)
295             if (fdresult == FUNCDETAIL_PROCEDURE && !proc_call)
(gdb)
305             if (fdresult == FUNCDETAIL_NORMAL ||
(gdb)
313                     if (agg_star)
(gdb)
320                     if (agg_distinct)
(gdb)
326                     if (agg_within_group)
(gdb)
332                     if (agg_order != NIL)
(gdb)
338                     if (agg_filter)
(gdb)
344                     if (over)
(gdb)
355             if (fdresult == FUNCDETAIL_NORMAL || fdresult == FUNCDETAIL_PROCEDURE)
(gdb)
641             nargsplusdefs = nargs;
(gdb)
642             foreach(l, argdefaults)
(gdb)
664             rettype = enforce_generic_type_consistency(actual_arg_types,
(gdb)
671             make_fn_arguments(pstate, fargs, actual_arg_types, declared_arg_types);
(gdb)
678             if (!OidIsValid(vatype))
(gdb)
681                     func_variadic = false;



2022-02-14


heap_open

Datum ux_login_table_insert(UX_FUNCTION_ARGS)
{
	Datum		values[Natts_ux_login_table];
	Name	rolname = UX_GETARG_NAME(0);
	Name	last_login_timestamp = UX_GETARG_NAME(1);
	Name	last_failuretime = UX_GETARG_NAME(2);
	bool nulls[Natts_ux_login_table];
	
		Name	queryid = "123456";
	Name	query = query_string;
	Name	total_time = "0214"
	Name	suggestions = "split(partition_suggest_data)";
	
	values[0]=NameGetDatum(rolname);
	values[1]=NameGetDatum(last_login_timestamp);
	values[2]=NameGetDatum(last_failuretime);
	values[3]=NameGetDatum(last_failuretime);
	
	//if rolename don't in table ,insert it
   
		Relation	ux_login_table_desc;
		HeapTuple tup;
		ux_login_table_desc = heap_open(PartitionSuggestRelationId, RowExclusiveLock);
		tup = heap_form_tuple(RelationGetDescr(ux_login_table_desc), values, nulls);
		CatalogTupleInsert(ux_login_table_desc, tup);
		heap_freetuple(tup);
		heap_close(ux_login_table_desc, RowExclusiveLock);
		UX_RETURN_BOOL(true);
}

	Datum		values[4];
	bool nulls[4];
	Name	queryid = "123456";
	Name	query = "query";
	Name	total_time = "0214";
	Name	suggestions = "split(partition_suggest_data)";

	values[0]=NameGetDatum(queryid);
	values[1]=NameGetDatum(query);
	values[2]=NameGetDatum(total_time);
	values[3]=NameGetDatum(suggestions);

	Relation	partition_suggest_desc;
	HeapTuple tup;
	if(IsUnderPostmaster && (strstr(query_string, "between") != NULL))
	{
		partition_suggest_desc = heap_open(RelationRelationId, RowExclusiveLock);
		tup = heap_form_tuple(RelationGetDescr(partition_suggest_desc), values, nulls);
		CatalogTupleInsert(partition_suggest_desc, tup);
		heap_freetuple(tup);
		heap_close(partition_suggest_desc, RowExclusiveLock);
	}

select reltuples from ux_class where relname = 'partition_suggest_data';


RelationRelationId


rel = heap_open(RelationRelationId, AccessShareLock);



	ScanKeyData key[1];
	classRel = heap_open(RelationRelationId, AccessShareLock);

	ScanKeyInit(&key[0],
				Anum_ux_class_relkind,
				BTEqualStrategyNumber, F_CHAREQ,
				CharGetDatum(RELKIND_RELATION));

	scan = heap_beginscan_catalog(classRel, 1, key);

	while ((tuple = heap_getnext(scan, ForwardScanDirection)) != NULL)
	{
		Oid			relid = HeapTupleGetOid(tuple);
		Form_ux_class relForm = (Form_ux_class) GETSTRUCT(tuple);

		if (is_publishable_class(relid, relForm))
			result = lappend_oid(result, relid);
	}

	heap_endscan(scan);
	heap_close(classRel, AccessShareLock);

Relation		rel_table;
char			*ux_class_relname = NULL;
rel_table =  heap_open(RelationRelationId, AccessShareLock);
scandesc = systable_beginscan(rel_table, ClassOidIndexId, true,
							   SnapshotSelf, 1, &skey);
while((tuple = systable_getnext(scandesc)) != NULL)
{
	value_datum[0] = heap_getattr(tuple, 1, rel_table, &isnull);
	ux_class_relname = text_to_cstring(DatumGetTextP(value_datum[0]));
	if(strcmp(ux_class_relname, "partition_suggest_data") == 0)
	{
		elog("partition_suggest_data = %s", ux_class_relname);
		break;
	}
}

	rel_table = heap_open(RelationRelationId, AccessShareLock);
	scandesc = systable_beginscan(rel_table, ClassOidIndexId, true,
							   SnapshotSelf, 1, &skey);

	tuple = systable_getnext(scandesc);



rel = heap_open(RelationRelationId, AccessShareLock);
	scan = heap_beginscan_catalog(rel, 1, key);




relScan = heap_beginscan_catalog(classRel, 0, NULL);
获取表oid：
get_relname_relid()

2022-02-21

oracle数据库sql参考：
https://docs.oracle.com/cd/B19306_01/server.102/b14200/statements_6010.htm

预研：
资源管理：
https://www.cnblogs.com/NamingException/p/10891976.html

资源限制：对 用户 或者 系统 进行一些资源限制，用以防止服务器资源紧张。
资源监控：查看数据库资源使用情况；
表空间资源限制：设置用户在表空间的限额；
客体重用：通过客体重用的功能，防止非法进程利用数据库客体的内存泄漏来攻击数据库；
基于任务优先级的CPU调度：根据任务的优先级设置CPU调度的优先级；

原始问题：
1、物理存储配置管理：
测试内容：应提供数据文件、日志文件、归档文件的物理存储位置设置和数据库空间大小分配、页大小分配等功能，是否提供了推荐配置参数。
测试方法：分别验证数据库文件、日志文件、归档文件的物理存储位置的设置功能以及数据库空间大小分配、页大小分配功能，并检查配置过程中是否提供了推荐配置参数。

2、用户使用资源控制：
用户内存使用空间限制(要真正的用户内存控制)

目前需求：

1、物理资源配置管理
物理资源配置管理
a.数据库空间大小可分配
b.页大小可分配
c.其他资源管理需参考其他数据库进一步调查

2、用户使用资源控制
用户使用资源控制
a.用户的内存使用空间
b.用户的磁盘使用空间






使用create profile命令创建一个profile，用它来实现对数据库资源的限制使用。如果把该profile分配给用户，则该用户所能使用的数据库资源都在该profile的限制之内。

一、资源限制

1、创建profile命令：

 CREATE PROFILE sec_profile LIMIT
     SESSIONS_PER_USER          UNLIMITED
     CPU_PER_SESSION            UNLIMITED
     CPU_PER_CALL               6000
     CONNECT_TIME               60
     LOGICAL_READS_PER_SESSION  DEFAULT
     LOGICAL_READS_PER_CALL     6000
     COMPOSITE_LIMIT            6000000
     PRIVATE_SGA                66K
     FAILED_LOGIN_ATTEMPTS      6
     PASSWORD_LIFE_TIME         60
     PASSWORD_REUSE_TIME        60
     PASSWORD_REUSE_MAX         5
     PASSWORD_LOCK_TIME         1/24
     PASSWORD_GRACE_TIME        10  
     PASSWORD_VERIFY_FUNCTION   verify_function


2、将profile指定给具体用户：

alter user sec profile sec_profile;

三、表空间资源限制
注意：Oracle 建议您使用数据库资源
Manager 而不是 SQL 配置文件来建立数据库资源限制。
数据库资源管理器提供了一种更灵活的方法
管理和跟踪资源使用。 有关更多信息
数据库资源管理器，请参阅 Oracle 数据库管理员
指导。

create user itme identified by zero default tablespace myspace 
quota 10M on myspace 
quota 5M on system temporary tablespace temp profile default account unlock;


配额条款
使用 QUOTA 子句指定用户可以分配的最大空间量
表空间。
一个 CREATE USER 语句可以有多个用于多个表空间的 QUOTA 子句。
UNLIMITED 允许用户在表空间中无限制地分配空间。
QUOTA 条款的限制 您不能将此条款指定为临时
表空间。
简介条款
指定要分配给用户的配置文件。 配置文件限制的数量
用户可以使用的数据库资源。 如果省略此子句，则 Oracle 数据库
将默认配置文件分配给用户。



四、客体重用：

达梦：
http://k.sina.com.cn/article_7033464851_1a33a281300100pxe3.html?subch=otech



































CREATE TABLE "NC"."NR_AIN_HOURDB0" (
  "TIME" DATE NOT NULL ,
  "ID" NUMBER(16) NOT NULL ,
  "V" NUMBER(20,3) ,
  "AVGV" NUMBER(20,3) ,
  "MAXV" NUMBER(20,3) ,
  "MAXT" DATE ,
  "MINV" NUMBER(20,3) ,
  "MINT" DATE ,
  "S" NUMBER(2) ,
  "AVGS" NUMBER(2) ,
  "MAXS" NUMBER(2) ,
  "MINS" NUMBER(2) 
)
NOLOGGING
NOCOMPRESS

STORAGE (
  BUFFER_POOL DEFAULT
)
PARALLEL 1
NOCACHE
DISABLE ROW MOVEMENT
;

-- ----------------------------
-- Primary Key structure for table NR_AIN_HOURDB0
-- ----------------------------
ALTER TABLE "NC"."NR_AIN_HOURDB0" ADD CONSTRAINT "NR_AIN_HOURDB10_PK" PRIMARY KEY ("TIME", "ID");


-------------
oracle_migration 使用步骤：

conn.config文件配置：
oracle_server_uri=//192.71.0.118/orcl			//oracle IP,SID
oracle_log_user=ORA_USER2						//oracle 用户名
uxdb_server_host=127.0.0.1
uxdb_server_port=5432
uxdb_server_dbname=uxdb
uxdb_log_user=uxdb

./export_oracle_inc -s 192.168.30.199:1521/imc   -u uxmig   -p nariacc -l nc,pubuser >table_owner1.ddl
./init_foreign_server_inc -f conn.config -p '1qaz!QAZ!@#'  -r nariacc
./import_uxdb_inc -f conn.config -p '1qaz!QAZ!@#'  -i table_owner1.ddl
./sync_table_inc -f conn.config -p '1qaz!QAZ!@#' -r nariacc -l nc,pubuser -s 2022/2/22-15:05:00 -i 480 -a -D  -v -q 8

1、导出ddl
./export_oracle -s 192.71.0.118:1521/orcl   -u ORA_USER2   -p 123456 -l ORA_USER2 >table_owner2.ddl
./init_foreign_server -f conn.config -p'1qaz!QAZ' -r 123456
./import_uxdb -f conn.config -p '1qaz!QAZ' -i table_owner2.ddl
./add_table -f conn.config -p '1qaz!QAZ' -r 123456 -l ORA_USER2
同步数据：
./sync_table -f conn.config -p '1qaz!QAZ' -r 123456

sql语句：
create table NR_AIN_HOURDB0(
       classid number(20),
       classname varchar(3000) not null,
	   time date
       );

ALTER TABLE NR_AIN_HOURDB0 ADD CONSTRAINT NR_AIN_HOURDB10_PK PRIMARY KEY (classid,time);

insert into NR_AIN_HOURDB0 select rownum,'create user C##java identified by oracle default tablespace users temporary tablespace temp quota 100m on users quota 100m on system CREATE USER C##sidney IDENTIFIED BY out_standing1 DEFAULT TABLESPACE example QUOTA 10M ON example ',sysdate from dual connect by level <=5;


select a.constraint_name,  a.column_name 
from user_cons_columns a, user_constraints b 
where a.constraint_name = b.constraint_name 
  and b.constraint_type = 'P' and a.table_name = 'NR_AIN_HOURDB0'

oracle_fdw:
1、create extension oracle_fdw;
2、create server osdba_fdw foreign data wrapper oracle_fdw options (dbserver '//192.71.0.118:1521/orcl');
3、create user mapping for uxdb server osdba_fdw options(user 'ora_user1', password '123456');
4、create foreign table "test_tab"(id int, name varchar(100)) server osdba_fdw options(table 'TEST_TAB');
select * from test_tab;

alter system set nls_date_format= 'yyyy-mm-dd hh24:mi:ss' scope=spfile;



2022-03-07

统计信息：

查看某个表的统计信息：
select *
from ux_catalog.ux_stat_user_tables
  where schemaname = 'myschema' and relname = 'tb1';


二、pg_stat_activity
查看当前运行中的耗时较长的SQL语句：
select current_timestamp - query_start as runtime, datname, usename, query
    from ux_stat_activity
    where state != 'idle'
    order by 1 desc;
  
停止正在执行的sql：
1、
SELECT ux_cancel_backend(进程id);
这种方式只能kill select查询，对update、delete 及DML不生效)

2、
SELECT ux_terminate_backend(PID);
这种可以kill掉各种操作(select、update、delete、drop等)操作；


顺序扫描代价计算：
顺序扫描函数：
cost_seqscan

总代价 = 总的IO花费 + 总的CPU花费
获取页和元祖：
select RELPAGES,RELTUPLES from ux_class where relname = 'HF_GXZH';

并行执行未显示可能将max_parallel_workers_per_gather设置为0；
max_parallel_workers_per_gather = 0

总代价 = 启动花费+总的IO花费+总的CPU花费
spc_seq_page_cost = 1
总的IO花费 = spc_seq_page_cost * RELPAGES

cpu_tuple_cost = 0.01
总的CPU花费 (cpu_tuple_cost + quxsqlual_cost.per_tuple) * RELTUPLES


where in （递增0.00125）
quxsqlual_cost.per_tuple：
2个条件：
quxsqlual_cost.per_tuple = 0.0025

3个条件：
quxsqlual_cost.per_tuple = 0.0037499999999999999
4个条件：
0.0050
5个：
0.00625
6个：
0.0075
7个：
0.00875

比如where in后面
0.01+0.0025 = 0.0125 * 100 = 1.25 + 2 = 3.75

actual time:

ExecutorRun
	standard_ExecutorRun
		ExecutePlan
			ExecProcNode
				ExecProcNodeFirst
					ExecProcNodeInstr
						InstrStopNode
	

ExecScan				//按照全局变量 ExecDirection 指定方向返回符合条件的元祖

ExecScanFetch			//


2022-3-10

河南移动：
mod(x,1)这个永远=0

 call dbms_application_info.set_module(?,?)   王奇
 
mod(dbms_utility.get_hash_value(rowid,1,10000),1)  王奇



get_hash_value：此函数计算给定字符串的哈希值。


create table tb(id int,val char(20));
insert into tb  values( 1, 'aaa');
insert into tb values( 2, 'bbb');
insert into tb values( 3, 'ccc');
create or replace function dbms_utility.get_hash_value(name varchar2, base numeric, hash_size numeric)
returns numeric as
$$
	select mod(abs(hashtextextended(name,0)),hash_size - base) + base;
$$ language sql;

对
oid  | castsource | casttarget | castfunc | castcontext | castmethod
insert into ux_cast values(17237,9002,'text'::regtype,0,'i','i');

create or replace function dbms_utility.get_hash_value(name text, base numeric, hash_size numeric)
returns numeric as
$$
	select mod(abs(hashtextextended(name,0)),hash_size) + base;
$$ language sql;

select dbms_utility.get_hash_value(rowid,1,10000)from tb;
 select * from tb where mod(dbms_utility.get_hash_value(rowid,1,10000),1)=0;

2、call dbms_application_info.set_module(?,?)
记录数据库中正在执行的模块或事务的名称；

module_name
当前正在运行的模块的名称。 当前模块终止时，如果有新模块，则使用新模块的名称调用此过程，如果没有，则使用 NULL。 长度超过 48 个字节的名称将被截断。

action_name
当前模块中当前操作的名称。 如果您不想指定操作，则该值应为 NULL。 超过 32 个字节的名称将被截断。





oracle查看记录的会话信息：
SELECT sid,serial#,client_info,MODULE,action FROM v$session;


exec dbms_application_info.set_module('test module','test action');

call dbms_application_info.set_module('test module','test action');
 
向v$session系统表中的MODULE、ACTION字段添加注释；

select distinct sid from v$mystat;

select module,action,client_info from v$session where sid=1036;


实现语法：

CREATE PROCEDURE dbms_application_info.set_module(a text, b text)    
LANGUAGE SQL    
AS $$
set log_filename=a;   
$$;    
    
CALL dbms_application_info.set_module(1, 2); 

最终语句：
CREATE SCHEMA dbms_application_info;
CREATE PROCEDURE dbms_application_info.set_module(str1 text, str2 text)
 as $$
	declare string text;
	begin string:='set module=' || $1 || ';';
		string:=string || 'set action=' || $2;
		execute string;
	end; $$
LANGUAGE pluxsql;



static struct config_string ConfigureNamesString[] =
{
	{
		{"module", UXC_USERSET, PROCESS_TITLE,
			gettext_noop("Name of module that is currently running."),
			NULL
		},
		&module,
		"",
		NULL, NULL, NULL
	},
	{
		{"action", UXC_USERSET, PROCESS_TITLE,
			gettext_noop("Name of current action within the current module."),
			NULL
		},
		&action,
		"",
		NULL, NULL, NULL
	},




2022-03-10
1、数据类型隐式转换：
通过向ux_cast表中插入对应数据实现转换；


函数:
1、max函数，找到ux_cast表的最大oid；
select max(oid) from ux_cast;


语法添加：
1、gram.y中添加：
1）子句类型：node节点
在%type <node>添加；

2）通过makeNode创建节点；
如：
maxrefClause *n = makeNode(maxrefClause);
maxrefClause为节点类型；

2、在parsenodes.h中添加
maxrefClause节点类型

3、在nodes.h添加枚举类型
在NodeTag中添加枚举：
T_maxrefClause

语义分析：

1、子句调用栈：
parse_analyze
	transformTopLevelStmt
		transformOptionalSelectInto
			transformStmt
				transformSelectStmt
					transformWhereClause
						transformExpr
							transformExprRecurse
								transformBoolExpr
							transformExprRecurse	
								transformSubLink
									parse_sub_analyze

编译命令：
 ./build.sh --release=standard --version=2.1.1.4 --license=internal --enable-root --nouxfs

sudo yum -y install gcc flex bison readline readline-devel zlib zlib-devel   openssl openssl-devel libxml2 libxml2-devel libxslt libxslt-devel gettext libssl libssl-devel libssh linssh-devel    perl-ExtUtils-Embed
yum install -y ant fuse fuse-devel boost-devel

yum install -y libtool*
yum -y install automake









2022-03-25

自强考试：
1、添加guc参数，启动数据库并打印相关配置信息；
2、对数据库指定内容进行替换；


配置项说明：
replacetext:配置项名称
testdatabae:指定的数据库名称
scla:指定数据列名称
secret:需要替换内容
xxxxxx:替换后输出内容

replacetext = "uxdb,scla,secret,xxxxxx"

测试过程：

create table testdatabase(sno int, snamea char(20), scla varchar(8000));
insert into testdatabase values(1, 'zhangsan', 'top-secret');
insert into testdatabase values(2, 'lisi', 'confidential');
insert into testdatabase values(3, 'wangwu', 'secret');
insert into testdatabase values(4, 'zhaoliu', 'secret');



insert into testdatabase values(5, 'secret', 'secret');

select scla from testdatabase;



((Form_ux_attribute *)slot->tts_tupleDescriptor->attrs).attname.data

NameStr(slot->tts_tupleDescriptor->attrs->attname)



数据库：
MyProcPort->database_name


2022-03-28

1、pgpool链接：

http://www.manongjc.com/detail/21-yrviykughdzydkb.html


2022-03-29

insert into ux_cast values(17098,9002,'BIGINT'::regtype,0,'i','i');
隐士转换可以通过以下方式
首先通过 select max(oid) from ux_cast; 获取最大oid，



checkRuleResultList

./initdb  -D data -Atrust --enable_rowid --running-mode=compatible
create table tb(id int);
insert into tb values(1);

create view v_test(col1) as select rowid from tb;



2022-03-30
申威平台打包
1、
10.1.106.183   root/Uxsino@2021  uxdb/Uxsino@2021


10.1.106.181   root/Uxsino@2021  uxdb/Uxsino@2021



如何确定系统版本
1、查看平台信息
lsb_release -a			//查看平台信息（eg：centos或kylin操作系统）
cat /etc/issue			//查看平台信息

2、查看cpu信息
lscpu
cat /proc/cpuinfo


　　--build=编译该软件所使用的平台		//使用uname -i
　　--host=该软件将运行的平台
　　--target=该软件所处理的目标平台


申威编译报错：
1、
./configure --build=arm-linux

2、修改源
/etc/apt/sources.list

deb http://sh-packages.chinauos.com/server-enterprise/1030 fou/sp3 main contrib non-free

3、readline 未找到
configure: error: readline library not found

sudo apt-get install -y libreadline-dev

4、openssl

RedHat Fedora 平台 
yum -y install openssl-devel 

Debian ,ubunu 平台 
apt-get install libssl-dev

5、configure: error: libcurl not found

sudo apt-get install libcurl4-openssl-dev

6、解决安装报错
mvn使用
https://blog.csdn.net/daodan988/article/details/51535644

7、
uxdb-std-Neo6-x86_64-v2.1.1.4.064.p1.run
uxdb-std-Neo6-x86_64-v2.1.1.4.064.p1.run-b3748211f4a1dc9c6bc9517623e1178f.md


apt-get命令：
1、搜索readline软件
sudo apt-cache search readline



2022-04-01

uxdb-server-linux7-2.1.0.4.02s-SECURITY.tar.gz


报错节点：
SHA-1: 6e3dbe1289802d3bbe9c3b8dcab8da6b7c49a12d

* Merge branch 'bug/ver2.1.0.4s_dev/#99638' into 'dev/ver2.1.0.4s_dev'

#99638 解决uxop用户备份还原表、schema、数据库失败，提示SET TRANSACTION ISOLATION LEVEL的问题

See merge request db/uxdb-ng!2658


2022-04-02

修改函数：
mod,round,nvl,trunc,decode,to_number,to_date

trunc不知道类型：
I_FREE_RES_QUERY_392_202102

562 - 583
测试步骤：


select mod(101::varchar,'10');
select round('1'::interval);			//兼容模式返回interval类型
select nvl(1::numeric,1::integer);

select decode(1::smallint, '2012'::integer, '24', '2012-01-02');
select TO_NUMBER('123.45'::interval);		//兼容模式下不存在这个问题



未修改函数：

listagg							//目的：将列转为行
grouping_id						//未实现
regexp_like						//未实现
pg_backend_pid					//未实现
chartorowid
userenv							//

function add_months				//在oracle模式下已经存在
months_between					//在oracle模式下已经存在
last_day						//在oracle模式下已经存在
to_char							//已实现

已完成函数：
mod,round,nvl,trunc,decode,to_number,to_date，
add_months、months_between、last_day、 to_char

处理问题：
listagg        			//有序聚集函数的直接参数必须使用分组列GROUP BY 
grouping_id         
regexp_like          	//
pg_backend_pid       	//可以使用
chartorowid
userenv   

336979 ERROR: date out of range: "20211122"
150163 ERROR: value for "yyyy" in source string is out of range Detail: Value must be in the range -2147483648 to 2147483647.
1029003 all（）用法
1058106 ERROR: value "100006050057" is out of range for type integer
239176 ERROR: CASE types integer and interval cannot be matched

to_date函数报错修改：
https://222.212.87.87:10943/db/uxdb-ng/merge_requests/4162/diffs#b2975fb7cb2248aafd11fe58ac3c2cd8943ba258

regexp_like函数相关功能实现：
https://222.212.87.87:10943/db/uxdb-ng/merge_requests/2343



listagg:
create table tc(id text,name text);
select listagg(id || ':' || id || '/' || name || ',') within group(order by id) from tb;
select listagg(id || ':' || id || '/' || name || ',')  within group(order by id::text) over(order by id)from tb;

to_char：
CREATE FUNCTION ux_catalog.to_char(text)
RETURNS varchar
AS 
$$
  select $1;
$$
LANGUAGE sql;
COMMENT ON FUNCTION ux_catalog.to_char(text) IS 'Convert text to string';

兼容模式已支持以下函数：round、TO_NUMBER、to_date
以下函数实现在oracle模式下：add_months、months_between、last_day

CREATE FUNCTION add_months(TIMESTAMP WITH TIME ZONE,INTEGER)
RETURNS TIMESTAMP
AS $$ SELECT (ux_catalog.add_months($1::ux_catalog.date, $2) + $1::time)::oracle.date; $$
LANGUAGE SQL IMMUTABLE STRICT;



TIMESTAMP		//without 无时区
timestamptz		//有时区



规约冲突：

      | c_expr MOTH_P
        {
          $$ = makeNode(ResTarget);
          $$->name = $2;
          $$->indirection = NIL;
          $$->val = (Node *)$1;
          $$->location = @1;
        }
















create function sfunc_listagg(text[], text)
returns int[] as
$$
begin
	return $1 || $2; 
end;
$$
language pluxsql;

create function final_listagg(text[], text)
returns int[] as
$$
declare 
	len int := 0;
begin
	return $1;
end;
$$
language pluxsql;

CREATE AGGREGATE listagg(text order by text)
{
	sfunc = sfunc_listagg,
	stype = text[],
	finalfunc = final_listagg,
	initcond = '{''''}'
};



create function fin_mid(int[], real)
returns int as
$$
declare
len int := 0;
begin
len = array_length($1, 1);
return $1[round(len*$2)];
end;
$$
language pluxsql;

//list_agg实现（实现列转行）：
create table tb(id text,name text);

insert into tb  values('4', 'eee');
insert into tb  values('1', 'aaa');
insert into tb  values('2', 'bbb');
insert into tb  values('3', 'ccc');
insert into tb  values('5', 'fff');



create table oracle.ux_order_by_list_agg(data text , sort text);


create function ux_catalog.sfunc_listagg(flag int, text, text)
returns int as
$$
begin
	insert into oracle.ux_order_by_list_agg values($2, $3);
	return 0;
end;
$$
language pluxsql;

create function ux_catalog.final_listagg(falg int, text, text)
returns text as
$$
declare
	result text := '';
begin
	select listagg(data) into result from oracle.ux_order_by_list_agg order by sort;
	delete from oracle.ux_order_by_list_agg;
	return result;
end;
$$
language pluxsql;

CREATE AGGREGATE oracle.listagg(text, text order by text)
(
	sfunc = sfunc_listagg,
	stype = int4,
	finalfunc = final_listagg,
	initcond = 0
);



create function fin_mid(int[], real)
returns int as
$$
declare
len int := 0;
begin
len = array_length($1, 1);
return $1[round(len*$2)];
end;
$$
language pluxsql;

//中位数：

create function gen_arrary(int[], int)
returns int[] as
$$
begin
	return $1 || $2; 
end;
$$
language pluxsql;

create function fin_mid(int[], real)
returns int as
$$
declare 
	len int := 0;
begin
	len = array_length($1, 1);
	return $1[round(len*$2)];
end;
$$
language pluxsql;

CREATE AGGREGATE mid(real order by int)
(
	sfunc = gen_arrary,
	stype = int[],
	finalfunc = fin_mid,
	initcond = '{0}'
);






2022-04-12


1、身份鉴别：

PerformAuthentication

ClientAuthentication

ux_class_aclcheck(Oid table_oid, Oid roleid, AclMode mode)

标记：
mac_create_policy

mac_set_user_label

mac_apply_row_policy
mac_set_column_label

mac_drop_row_policy
mac_drop_column_label
mac_drop_user_label

4、强访

mac_compare_label

5、
log_audit_event


insertlogs_to_uxdb(char **data, int batch_size, char *next_filename, int *last_datasize)

_bt_check_unique(Relation rel, BTInsertState insertstate, Relation heapRel,
				 IndexUniqueCheck checkUnique, bool *is_unique,
				 uint32 *speculativeToken)


static bool
ri_PerformCheck(const RI_ConstraintInfo *riinfo,
				RI_QueryKey *qkey, SPIPlanPtr qplan,
				Relation fk_rel, Relation pk_rel,
				TupleTableSlot *oldslot, TupleTableSlot *newslot,
				bool detectNewRows, int expect_OK)

SPI_processed

ResultRelInfo *relationInfo, TupleTableSlot *slot, EState *estate

ExecConstraints(ResultRelInfo *resultRelInfo,
				TupleTableSlot *slot, EState *estate)

BlockNumber blocknum, char *buffer
mdextend

secure_raw_read(Port *port, void *ptr, size_t len)

int64 get_min_tblspace_size(Oid tblspc_oid)
min_space_size
表空间最小限额

check_password(const char *username,
			   const char *shadow_pass,
			   PasswordType password_type,
			   Datum validuntil_time,
			   bool validuntil_null)

InitializeSessionUserId(const char *rolename, Oid roleid)

void
hba_getauthmethod(hbaPort *port)

UXDB-IF-

_bt_check_unique(Relation rel, IndexTuple itup, Relation heapRel,
				 Buffer buf, OffsetNumber offset, ScanKey itup_scankey,
				 IndexUniqueCheck checkUnique, bool *is_unique,
				 uint32 *speculativeToken)

ri_PerformCheck(const RI_ConstraintInfo *riinfo,
				RI_QueryKey *qkey, SPIPlanPtr qplan,
				Relation fk_rel, Relation pk_rel,
				HeapTuple old_tuple, HeapTuple new_tuple,
				bool detectNewRows, int expect_OK)
				
void getSession(
        const char* strSessionId,		会话id
        long lSessionLineNum,			会话个数
        const char* strProcessId,		进程id
        const char* strSessionStartTime,		会话开始时间
        const char* strUserName,			用户名
        const char* strDatabaseName,		数据库
        const char* strApplicationName,		应用名称
        const char* strConnectionFrom,		链接地址
        const char* strCommandTag,			命令
        const char* strErrorSeverity,		严重错误信息
        const char* strLogTime,				日志时间
        const char* strMessage)				日志信息	
		
		

month


2022-04-14

https://blog.csdn.net/deniro_li/article/details/103745618

hh12	//时分秒正常
hh24
mi
ss
ms
us
ssss

tzh
tzm

mm
ddd
iddd
dd
d			//一周的星期几
id
iw			//iso标准的年中的第几周
q			//季度
cc			//第几世纪，格式两位

yyyy		年正常
yyy
yy
y

w		当月第几周(未实现)
j		从公元前 4713 年 1 月 1 日至今，已经经过多少天。

select to_date(20211122113001,'yyyy-mm-dd  hh24:mi:ms');


ddd:表示当年第几天
select to_date(20222,'yyyy-ddd');


ddd
select to_date(20211122113001,'yyyy-ddd  hh24:mi:ss');

w:
select to_date(20220412,'yyyy-mm-dd w hh24:mi:ms');

cc：第几世纪，格式两位
select to_date(21,'cc');

tzm：
select to_date(202111221130011,'yyyy-mm-dd  hh24:mi:ms tzm');
tzh：
select to_date(202111221130011,'yyyy-mm-dd  hh24:mi:ms tzh');





表示day的：dd 表示当月第几天；ddd表示当年第几天；dy 当周第几天 简写 比如星期五或者fri；day当周第几天 全写













bison -v ora_gram.y




函数：

1、获取随机数函数：
random()


2022-04-15
JYJT涉密改造沟通群（#140293）

nhibernate

nhibernate + spring mvc的demo

nhibernate 介绍：
https://blog.csdn.net/sufu1065/article/details/80116384

https://www.cnblogs.com/vipstone/archive/2011/09/15/2177830.html

nhibernate + spring
https://blog.csdn.net/wb09100310/article/details/46778773

spring学习笔记：
https://www.cnblogs.com/GoodHelper/archive/2009/11/20/SpringNet_Index.html

nhibernate + spring整合：
https://wenku.baidu.com/view/ad9c0e3467ec102de2bd89c4.html


demo:
https://www.cnblogs.com/dongteng/p/8378650.html

访问数据库配置：
https://blog.csdn.net/zhangxian_engineer/article/details/6313970

关联单子：
105978

不兼容报错；
需要迁移；

确定下是不是vs2008搭建的
cs工程文件是哪个？

Console.WriteLine("---------数据库链接成功！")


Npgsql-1.0：
Error thrown by a dependency of object 'Npgsql-1.0' defined in 'assembly [Spring.Data, Version=1.3.0.20214, Culture=neutral, PublicKeyToken=65e474d141e25e07], resource [Spring.Data.Common.dbproviders.xml] line 683' :
 Unsatisfied dependency expressed through constructor argument with index 2 of type [System.Type] : 
 Could not convert constructor argument value [Npgsql.NpgsqlConnection, Npgsql, Version=1.0.0.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7] to required type [System.Type] : Cannot convert property value of type [System.String] to required type [System.Type] for property ''.
while resolving 'constructor argument with name dbmetadata' to 'Spring.Data.Common.DbMetadata#15D72B1' defined in 'assembly [Spring.Data, Version=1.3.0.20214, Culture=neutral, PublicKeyToken=65e474d141e25e07], resource [Spring.Data.Common.dbproviders.xml] line 683'



 <constructor-arg name="connectionType" value="Npgsql.NpgsqlConnection, Npgsql, Version=1.0.0.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7"/>
 <constructor-arg name="connectionType" value="System.Data.SqlClient.SqlConnection, System.Data, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"/>
 
 <constructor-arg name="connectionType" value="Npgsql.NpgsqlConnection, Npgsql, Version=1.0.0.0, Culture=neutral, PublicKeyToken=5d8b90d52f46fda7"/>
 
类型转换问题：
发生这一错误的主要原因是connectionString类型为system.string，但spring.data中的类型是system.type,
无法将类型 [System.String] 的属性值转换为属性所需的类型 [System.Type]，最终导致了这个错误。
方案一：
对类型进行转换，但存在对框架语法不熟悉
方案二：
通过升级新组件方式，正在进行



spring.data:
定义变量：
https://www.springframework.net/doc-latest/reference/html/dbprovider.html


类型转换问题：

MVC3+NHibernate2.1+Spring.NET1.3

问题：存在connectionString类型为system.string，但spring.data中的类型是system.type,
无法将类型 [System.String] 的属性值转换为属性所需的类型 [System.Type]，最终导致这个错误。

分析结论：
1、升级新组件方式：原框架组件（MVC3+NHibernate2.1+Spring.NET1.3），升级新框架组件（MVC4+NHibernate3.3+Spring.NET2.0）后，问题依然存在，
通过查看spring源码，Npgsql相关代码没有差别，故该问题与组件版本应该没啥关系。
2、通过分析mysql，该问题应该与dll版本号有关，spring.data框架中version存在该版本号，则正常，如不存在，则mysql也会报该报错；
eg：引入mysql-5.2.3 ddl动态库，由于spring.data框架中存在该版本，故正常，如删除mysql-5.2.3 ddl动态库，则存在该类型转换问题；
通过查看spring.data框架中Npgsql相关版本号，分别是：
1.0.0.0
1.98.1.0
2.0.0.0
然后查看Npgsql源码版本号，最低版本号为2.0.12.0，照这样看该框架与Npgsql无法适配，可能需要对spring框架进行修改，
所以师伟你那边可否找个熟悉这个框架的，去看下这个问题，我这边是没辙了；


该问题属NHibernate与spring框架问题，你那边可否找个熟悉这个框架的，去看下这个问题，

Npgsql：
1.0.0.0
1.98.1.0
2.0.0.0

<db:provider id="DbProvider" provider="Npgsql-2.0" connectionString="Data Source=${db.datasource};Database=${db.database};User Id=${db.user};Password=${db.password};"/>


<entry key="connection.driver_class" value="NHibernate.Driver.NpgsqlDriver" />
<entry key="dialect" value="NHibernate.Dialect.PostgreSQLDialect" />


MVC+NHibernate+Spring+ .NET适配：

目前需要写一个nhibernate + spring mvc的demo，
框架这边我已经搭好了，但是进行适配时，
会报一些框架上的报错，
需要对这个nhibernate + spring mvc框架熟悉的同事协助下

    <add  key = "db.datasource"  value = "192.168.0.137" />
    <add  key = "db.user"  value = "uxdb" />
    <add  key = "db.password"  value = "123456" />
    <add  key = "db.database"  value = "postgres" />
	
Data Source=${db.datasource};Database=${db.database};User Id=${db.user};Password=${db.password};

connectionString="Host=${db.datasource};Database=${db.database};Username=${db.user};Password=${db.password}"

   <db:provider id="DbProvider" provider="Npgsql-2.0" connectionString="Host=192.71.0.137;Database=uxdb;Username=uxdb;Password=123456" />


2022-04-22

1、top关键字，建表语句字段是关键字，在创建表的时候失败，给关键字加上双引号可建表成功，但后台程序调用的时有该字段的调用，调用时提示“语法错误，在“top”或附近”
2、运算符调用时支持<=  ，不支持 <   = ，两个运算符中间含有空格，在调用时提示“语法错误在“=”或附近的”
3、start with …connect by 递归调用，适配过程中含有递归调用，数据库暂不支持start with递归调用，提示“语法错误在“start”"或附近
4、无效的类型numeric输入语法"null"

1.  top 关键字， 已有解决方案， 对于 使用百分比的场景需要做函数单独理。 研发开销2人天
2.  更改词法解析， 加上后续测试   研发开销3人天
3.  用 pg 的 with  recusive  语法替换解决。  已有部分工作， 对于简单场景  研发开销3人天
4.   已有方案， 研发开销2人天。 

<=语法：
select * from tb where id < =2;	
支持的：
 <>
 >=
 <=
 ||		//链接

不支持的：
 ->				//无json这个类型


 &&				//无这个操作符

 @@				//圆中心，无这个操作符
 <^				//uxdb不存在该操作符
 >^				//uxdb不存在该操作符

 <<				//无这个操作符
 >>				//无这个操作符
 ##				//无这个操作符

 ?#				//无这个操作符
 ?-				//无这个操作符
 ?|				//无这个操作符
 @>				//无这个操作符
 <@				//无这个操作符
 ~=				//无这个操作符

 &>				//无这个操作符
 

 |/				//无这个操作符
 &<				//无这个操作符
 !!				//阶乘，无这个表达式


 ~*				//无这个操作符
 !~				//无这个操作符
 ?&				//无这个操作符
 #-				//无这个操作符
 @?				//无这个操作符
 *>				//对record类型结果进行比较
 *<
 *=
 ^@				//无这个操作符，等效于starts_with
 ~~				//无这个操作符，等效于like
 
2022-04-25

top关键字，建表语句字段是关键字，在创建表的时候失败，给关键字加上双引号可建表成功，但后台程序调用的时有该字段的调用，调用时提示“语法错误，在“top”或附近”

create table tb(id int, top int);
create table tb(id int, "top" int);
insert into tb values(1,1);
insert into tb values(1,2);

select * from tb where  top = 1;
select * from tb where  "top" = 1;


create table test(id int, name text);

insert into test values(11, 'b');
insert into test values(22, 'a');
insert into test values(33, 's');
insert into test values(44, 'h');
insert into test values(55, 'w');
insert into test values(6, 'f');
insert into test values(7, 'q');


2022-04-25

top关键字为RESERVED_KEYWORD，故对于字段名的引用需要添加双引号进行引用，
改为UNRESERVED_KEYWORD后，无需进行标识，即可识别为字段名。

由于top关键字在语法上与字段名冲突，故在top语法为空时，存在移进、规约冲突，
故修改top语法，对于top语法与非top语法分开使用，但当top语句为空时，由于top有括号语法，
所以top可能被识别为函数，故存在‘（’移进、规约冲突,通过添加top关键字优先使用解决



#143313：top关键字，建表语句字段是关键字，在创建表的时候失败

top关键字为RESERVED_KEYWORD，故对于字段名的引用需要添加双引号进行引用，
改为UNRESERVED_KEYWORD后，无需进行标识，即可识别为字段名。

由于top关键字在语法上与字段名冲突，故在top语法为空时，存在移进、规约冲突，
故修改top语法，对于top语法与非top语法分开使用，但当top语句为空时，由于top有括号语法，
所以top可能被识别为函数，故存在‘（’移进、规约冲突,通过添加top关键字优先使用解决

bison基本概念及语法介绍
https://blog.csdn.net/weixin_46222091/article/details/105990745

2022-04-26

create table tb(name number);

oracle jdbc使用方法：
https://blog.csdn.net/weixin_45595683/article/details/112545805

jdbc的使用：
将jar包解压，解压了以后把  com 文件夹和MainTest.java文件放在同一个路径，然后编译执行：

MainTest.java文件在139机器的jdbc路径下：
/home/uxdb/script/uxdb/jdbc
java编译：
eg：编译MainTest.java
编译：javac MainTest.java
执行：java MainTest



2022-04-27

support/#139826
打包要求：
root登录
internal



uxdb-std-kylin10-arm64-v2.1.1.4.014.p2.rpm
uxdb-std-kylin10-arm64-v2.1.1.4.014.p2-c928f322f09bf8476202dd92596b3536.md

2022-05-06

解决版本问题：

1、首先查看系统是否兼容
2、如果不兼容的话，寻找解决方案，查看是否修改代码

windows编译postgres

1、进入src\tools\msvc路径，执行build.bat
2、编译后跑回归测试，perl vcregress.pl check

MSBuild.exe uxsql.sln /p:Configuration=Release /p:Platform="Win32"


windows版本历史：
winxp、（2001/10/25）
win2008、（2008/2/27）
win7、（2009/10/22）
win8、（2012/10/26）
win10 （2015/07/29）



头文件：
C:\Program Files (x86)\Windows Kits\10\Include\10.0.10240.0\ucrt
C:\Program Files (x86)\Windows Mobile 5.0 SDK R2\PocketPC\Include\Armv4i


rownum报错：

set ora_grammar to on;
select ux_backend_pid();
 
SELECT ROWNUM  FROM t1_rn  WHERE ROWNUM <= 5;


standard_planner
	subquery_planner
		grouping_planner
			preprocess_limit


今日进展：
1、解决了win 32 xp环境下初始化出错的问题
2、兼容功能问题调查，已经明确是rownum问题，其余兼容功能及兼容模式运行正常
3、图形化安装工具测试（目前发现在win xp32 、win 2008R2 环境下，会卡住，等于初步适配有问题） -> 目前还未让工具同事介入

后续计划（4日内）：
1、解决32位环境下 rownum 问题（已完成）
2、依次针对 win xp 32位、win 2008 R2 x64 进行打包测试。
3、针对 win 7 x64、 win 8 x64、win 10 x64 使用现有包进行打包测试（带图形化安装工具），确认基本测试通过后，再进行免license打包。

分支：
win xp：
support/#144088_for_winxp32

win x64：
hotfix/ver2.1.1.4p
#support/ver2.1.1.4p


%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin

Java\jre1.8.0_221

uxdb-std-win-x86_32-v2.1.1.4-56-01-winXP.zip
uxdb-std-win-x86_32-v2.1.1.4-56-01-win7.zip


uxdb-std-win-x86_64-v2.1.1.4-19-p2.exe

uxdb-std-win-x86_64-v2.1.1.4-19-p2-1fb5d8292c8a082e7ebd643eea7970c7.md

uxdb-std-win-x86_32-v2.1.1.4-19-p2-winXP.exe
uxdb-std-win-x86_32-v2.1.1.4-19-p2-win7.exe


打包：

call izpack_pkg_cmd.bat 2.1.1.4 standard 

cacls "C:\code" /E /G uxdb:F
cacls "C:\code\uninstaller" /E /G Administrator:F

cacls "%installDir%" /E /G %username%:F
cacls "%installDir%\uninstaller" /E /G Administrator:F


winxp安装时存在setx命令设置失败报错，setx命令用于设置环境变量，
winxp不支持该命令，需要手动添加下环境变量；

下面这些库会影响哪些功能：
OpenSSL-Win64
libxml2-2.9.8
libxslt-1.1.32
iconv-1.11.1
zlib-1.2.7
gettext-tools-dev_ext_0.18.1.1-2_win64


2022-05-26

1、由触发器造成的，id是触发插入的
insert into tb values(1) returning id;
2、String sql = "select user_id from mail_index where id = ?";
   DatabaseHelper helper = DB.getInstanceSQLite(dbPath);
   userId = helper.queryColumn(sql,"user_id",id);
然后id的值是3fe98d9d-0b93-4346-bbbb-c17c2303a7a6

3、使用别名，没有加as（问题单：85040）


1、第一个问题是触发器造成的，那触发器语句是啥，触发器语句是否对字段带双引号？（还有706开发已经在改了，）
2、第二个问题是类型转换问题吗？ （uxobject 转换string应用报错？）
3、改造语法， 加上后续测试，研发开销3人天


后续开发测试时间，不涉及系统测试，只是开发这边自测时间；


CREATE OR REPLACE FUNCTION auditlogfunc() RETURNS TRIGGER AS $example_table$ 
declare i int;
    BEGIN 
        INSERT INTO TB1(ID) VALUES (1) returning "id" into i; 
        RETURN NEW;  
    END; 
$example_table$ LANGUAGE pluxsql;


CREATE TRIGGER example_trigger AFTER INSERT ON TB 
FOR EACH STATEMENT EXECUTE PROCEDURE auditlogfunc();


insert into tb values(1);



数据库后端sql：INSERT INTO TB1(id) VALUES (1) returning "id";
错误:  字段 "id" 不存在 第 42 个字符处
语句:  INSERT INTO TB1(id) VALUES (1) returning "id";

触发器：
错误:  字段 "id" 不存在 第 42 个字符处
查询:  INSERT INTO TB1(ID) VALUES (1) returning "id"
上下文:  在SQL语句的第4行的PL/uxSQL函数AUDITLOGFUNC()
语句:  insert into tb values(1);

jdbc：
错误:  字段 "column1" 不存在 第 50 个字符处
语句:  insert into jdbc_tb_numeric values($1) returning "column1"


1、returning id，id不存在报错分析，通过创建触发器，链接jdbc构造returning id，
报错非触发器导致，insert语句可能在jdbc做了改造；

3、别名加不加as都无法插入，需实现该语法功能；

1、returning id这个问题，通过对比触发器，链接jdbc构造returning id，
根据现场报错信息，报错应该是jdbc对输入sql做了改造导致；

2、

3、insert插入时字段引用别名，别名加不加as都无法插入，所以现场需求是否是insert 插入时字段引用别名；


insert all 
into table1(id) values(1)
into table2(id) values(1)
select * from dual;
http://download.oracle.com/docs/cd/B19306_01/server.102/b14200/statements_9014.htm#SQLRF01604




create table UserInfo
(
UserId int primary key ,
UserName varchar(20),
password varchar(20) not null
);

create table UserDetails
(
id int  primary key,
name varchar(50) not null,
userId int,
foreign key (userId) references UserInfo(UserId)
);


insert into UserInfo values (1,'jeff','aaa');
insert into UserInfo values(2,'wzqwzq','bbb');
insert into UserInfo values(3,'lglg','ccc');
insert into UserDetails values(3,3,3);


delete FROM UserInfo where UserId=3;

客户那边使用的还是之前的框架，由于spring+NHibernate框架存在卡住问题，
客户那边创建了demo工程进行验证；

Npgsql，主键、外键索引报错卡住问题：
问题分析：
通过分析，版本适配问题，
分析Npgsql2.0.12.0版本之前对ExecuteNonQuery未做适配，
故2.0.12.0之前版本都存在这个问题，

解决方案：
由于uxdb目前驱动适配使用2.2.3版本，
所以对2.2.3版本Npgsql版本号做了适配，目前验证未发现异常；



但spring+NHibernate框架版本较低，只适配2.0.0
但spring+NHibernate框架版本较低，只适配2.0.0，
由于框架名称与版本号固定的，对应Npgsql，


2022-05-31

php手册：
https://www.php.net/manual/zh/book.pgsql.php


2022-06-01
Npgsql:
EntityFramework6(EF6)连接Postgresql数据库：
https://blog.csdn.net/carcarrot/article/details/105574477

dotnetcore 缺 动态库，原dotnet依赖库不支持
https://blog.csdn.net/u012122318/article/details/81809653

.net.core驱动Npgsql：
https://blog.csdn.net/Chen_Victor/article/details/61196160?utm_source=blogxgwz5

.net core工程搭建：

.net.core实战实例一：
https://www.jianshu.com/p/bc489b8966a9

使用以下命令链接数据库：
Scaffold-DbContext "Host=192.71.0.137;Database=uxdb;Username=uxdb;Password=1" Npgsql.EntityFrameworkCore.PostgreSQL -OutputDir Models

msi 解压命令msiexec
msiexec /a  "F:\git\Npgsql-4.0.9.msi" /qb TARGETDIR="F:\git\npgsql"


Benchmark工具使用：
https://blog.csdn.net/penriver/article/details/122276382


uxdb最优参数配置，共享内存最大128GB：
max_connections = 1024
shared_buffers=40GB
maintenance_work_mem=8GB
wal_buffers=1GB
effective_cache_size=64GB
bgwriter_delay = 100ms
bgwriter_lru_maxpages = 500
bgwriter_lru_multiplier = 5.0
effective_io_concurrency = 0
synchronous_commit = off
max_wal_size = 32GB
min_wal_size = 4GB
random_page_cost = 1.1
fsync = off
checkpoint_timeout = 30min

hot_standby = on
max_wal_senders = 3
wal_keep_segments = 64
full_page_writes = on
wal_log_hints = on

最有参数修改：
shared_buffers=64GB
maintenance_work_mem=4GB
wal_buffers=1GB
max_wal_size=4GB
effective_cache_size=64GB
autovacuum = on
autovacuum_naptime = 1380min
ora_grammar = on
max_connections = 1000
fsync = off
checkpoint_timeout = 1d
synchronous_commit = off


2022-06-07

1、
CS8618: 在退出构造函数时，不可为 null 的 字段“Read”必须包含非 null 值。请考虑将 字段 声明为可以为 null


2022-06-10

1、层次查询connect by
120066
https://www.pianshen.com/article/2898753313/

2022-06-16

词法语法分析：

flex与bison：
1、flex用作词法分析，bison用作语法分析；

词法分析把输入分解成一个个有意义的词块，称作token；
语法分析则确定这些词块彼此之间如何关联，使用语法树表达；
eg：
A = B + C;
flex将其分解成A、=、B、+、C和;
接着bison将其确定为一个表达式,简化如下：
                +---+
                | = |
                +---+
               /     \
          +---+       +---+
          | A |       | + |
          +---+       +---+
                     /     \
                +---+       +---+
                | B |       | C |
                +---+       +---+



2022-06-21

rowid影响5~6%；




max_connections = 128
shared_buffers=4GB
#maintenance_work_mem=8GB
#wal_buffers=1GB
#effective_cache_size=8GB
#bgwriter_delay = 100ms
#bgwriter_lru_maxpages = 500
#bgwriter_lru_multiplier = 5.0
effective_io_concurrency = 0
synchronous_commit = off
#max_wal_size = 32GB
#min_wal_size = 4GB
random_page_cost = 1.1
fsync = off
checkpoint_timeout = 30min

hot_standby = on
max_wal_senders = 3
wal_keep_segments = 64
full_page_writes = on
wal_log_hints = on

仓数：  warehouses=10   runMins=20

79.4 us

75848bc74411130ede23995d0ab1aefb12c4c4b0
dc7420c2c9274a283779ec19718d2d16323640c0
1f51c17c68d05c28d5b9294d8013cb9e7e653160
941697c3c1ae5d6ee153065adb96e1e63ee11224
5788e258bb26495fab65ff3aa486268d1c50b123
73487a60fc1063ba4b5178b69aee4ee210c182c4
623a9ba79bbdd11c5eccb30b8bd5c446130e521c


win拷贝linux文件格式问题：
1、修改文件
修改格式：
命令行模式执行
：set ff=unix 或者：set fileformat=unix

2、使用dos2unix递归转换文件夹下的格式：
首先安装dos2unix
sudo yum -y install dos2unix

find . -type f -not -path '*/\.*' -exec grep -Il '.' {} \; | xargs -d '\n' -L 1 dos2unix -k
转换为：在当前目录中递归查找所有非隐藏文件，然后使用grep，列出所有非二进制（-I）非空文件，
然后一次将其通过管道传送到xargs（由换行符分隔）中的一个文件至dos2unix并保留原始时间戳。

牵扯其他修改：
Track latest completed xid as a FullTransactionId.


2022-06-24
postgres编译：
./configure  --prefix=/home/uxdb/pginstall/ --with-openssl --with-blocksize=32 

内存消耗计算方法：
https://www.yht7.com/news/129198

工时登记填写：
706项目编号：
JA02903774202220291

公共交通：
A01093500202210484

河南移动：
A01097617202210156

2115系版本工时登记到 < UX010107783202210564 ~UXDB 2022年开发~全立>
2114维护工时 <UX010107783202210543~UXDB 2.1.1.4 版本维护~全立>
对外项目工时填写对应项目编号
其他类工时，继续登记到<UXDB产品线>

2022-06-27

98,632  insert
100 client 100 table

10s 20s 1min





CREATE TABLE persons
(
  id  int,
  name  varchar(255),
  gender  varchar(255),
  idnumber  varchar(255),
  contact  varchar(255),
  remarks  varchar(255),
  province  varchar(255),
  city  varchar(255),
  county  varchar(255),
  town  varchar(255),
  village  varchar(255),
  longitude  numeric(38),
  latitude  numeric(38)
);

INSERT INTO persons VALUES (1, 'Cheese', '男', '123456789', 'nve', 'this is man', 
'shanxi', 'xian', 'china', 'qianba', 'nande', 97.5, 9.99);

./uxbench -c 10 -T 10 -f table.sql
./uxbench -U UXDB -c 10 -T 10 -f table.sql

INSERT INTO persons select 1, 'Cheese', '男', '123456789', 'nve', 'this is man', 
'shanxi', 'xian', 'china', 'qianba', 'nande', 97.5, 9.99 from generate_series(1,100000);

1并发
9065.552214
8887.956140

使用uxbouncer：
Measured tpmC (NewOrders) = 68571.0
Measured tpmTOTAL = 152588.18

未使用uxbouncer：
Measured tpmC (NewOrders) = 553451.79
Measured tpmTOTAL = 1230589.24

进行相同的三轮测试，每轮测试
select数量：171859 
insert数量：98632 
update数量：1974 
delete数量：1043

2022-07-01

兼容性语法：
兼容dm语法实现：
参考手册：
DM8 SQL语言使用手册

兼容oracle使用：
https://docs.oracle.com/en/database/oracle/oracle-database/12.2/sqlrf/DECODE.html

mysql手册：
https://www.mysqlzh.com/ 

2022-07-04
性能相关记录：
1、性能优化
https://blog.csdn.net/qq_40026782/article/details/109221038?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2-109221038-blog-88997709.pc_relevant_vip_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-2-109221038-blog-88997709.pc_relevant_vip_default&utm_relevant_index=3

性能分析：

内存超过55GB时间：
3:30

监控系统数据:
timeout 605800 dstat -tcdmnr --disk-util -N ens33 > 1000ware500terminal_jr.csv 60 &

timeout 1800 dstat -tcdmnr --disk-util -N ens192 > 200ware500terminal_jr_henan_p9.csv 60 &

timeout 7200 dstat -tcdmnr --disk-util -N ens192 > 200ware400terminal_jr_henan_p9.csv 60 &



内存泄漏检测
https://blog.csdn.net/Frederick_Fung/article/details/117529699
valgrind:

valgrind --tool=memcheck --log-file=valgrind%p.txt ./a.out

valgrind --tool=memcheck --leak-check=full ./a.out

使用抑制错误
valgrind --tool=memcheck  --suppressions=./gw.supp --log-file=valgrind%p.txt ./a.out

valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all --trace-children=yes --suppressions=./gw.supp --log-file=valgrind%p.txt ./runBenchmark.sh com_props.pg

$ cat gw.supp 
{
	1
	Memcheck:Value8
	fun:_itoa_word
}
{
	2
	Memcheck:Cond
	fun:vfprintf
}
{
	3
	Memcheck:Cond
	fun:_itoa_word
}

–trace-children=no|yes [no] //如果是yes，被调程序若用exec开启了一个子进程，那valgrind将会追踪此子进程的执行情况
--leak-check=full			//Memcheck跟踪malloc/new函数对应的free/delete等的调用，默认值为summary，
只统计发生了多少次泄漏。如果设置为full或 yes，则每个单独的泄漏将被详细显示或计为错误。

2022-07-06
获取系统性能数据：
在linux执行以下命令（获取cpu与io使用情况）：
nmon -F sys100f.nmon -s 2 -c 10800 
使用工具对nmon生成的sys100f.nmon进行解析：
nmon_analyser_v69

查看进程io占比：
命令：iotop -oP
https://zhuanlan.zhihu.com/p/354809310

iostat -x 1 10	//表示1s打印一次，打10次，结果util表示io百分比；


2022-07-07
1、
Oracle（+）、不等于操作符补充下测试用例

c/c++全数据：
https://www.bilibili.com/video/av374923818


windows dll系统库搜索链接：
https://www.dll-files.com/


izpack问题：

注销izpack自启动功能：
ux_ctl.exe unregister -N UxdbServer


2022-07-08

1、windows安装数据库报错：
无法定位程序输入点ucrtbase.terminate




ed2k://|file|mu_windows_7_and_windows_server_2008_r2_sp1_x86_x64_dvd_619642.iso|2048196608|D1D032D20568F9ED16F072075F4E9961|/


发票抬头:
名称：
北京优炫软件股份有限公司
纳税号：
911101086851120558
地址：
北京市海淀区学院南路62号中关村资本大厦11层1111-1113室
电话：
010-82886998
开户行及账号：
北京银行股份有限公司中关村海淀园支行
01091448700120105109956







2022-07-26

报错栈：

#4  0x0000000000533cf3 in RecordTransactionAbort (isSubXact=false) at xact.c:1657
#5  0x0000000000534b85 in AbortTransaction () at xact.c:2706
#6  0x00000000005352e4 in AbortCurrentTransaction () at xact.c:3227





uxdb.c:1436
finish_xact_command:uxdb.c:2792

CommitTransactionCommand
	CommitTransaction
		CSNSnapshotCommit
			CSNLogSetCommitSeqNo

csn未调用函数：
1、CSNSnapshotPrepareCurrent
2、csnlog_desc
3、CSNSnapshotAssignCurrent
4、




报错原因：
CSNSnapshotCommit
assignedCSN = ux_atomic_read_u64(&proc->assignedCSN);  //获取的csn值无效

#0  CSNLogSetCommitSeqNo (xid=517, nsubxids=0, subxids=0x0, csn=18446744073709551615, write_xlog=true)
    at csnlog.c:132
#1  0x0000000000557c64 in CSNSnapshotCommit (proc=0x7f304faa3e68, xid=517, nsubxids=0, subxids=0x0)
    at csn_snapshot.c:664
#2  0x00000000005343d6 in CommitTransaction () at xact.c:2203
#3  0x0000000000534fa5 in CommitTransactionCommand () at xact.c:2955
#4  0x0000000000901f07 in finish_xact_command () at uxdb.c:2792
#5  0x00000000008ffd46 in exec_simple_query (query_string=0x1f59270 "create table t2(id int,b text);") at uxdb.c:1436



代码移植问题记录：
一、未移植代码
diff --git a/src/backend/storage/lmgr/lwlock.c b/src/backend/storage/lmgr/lwlock.c
index 862097352b..1f78161d9a 100644
--- a/src/backend/storage/lmgr/lwlock.c
+++ b/src/backend/storage/lmgr/lwlock.c
@@ -135,6 +135,8 @@ static const char *const BuiltinTrancheNames[] = {
 	"CommitTSBuffer",
 	/* LWTRANCHE_SUBTRANS_BUFFER: */
 	"SubtransBuffer",
+	/* LWTRANCHE_CSN_LOG_BUFFERS */
+	"CSNLogBuffer",
 	/* LWTRANCHE_MULTIXACTOFFSET_BUFFER: */
 	"MultiXactOffsetBuffer",
 	/* LWTRANCHE_MULTIXACTMEMBER_BUFFER: */

2022-08-01

pgpool：
上游服务器:
健康检查：
lifecheck：
故障转移：就是进行主备切换；
仲裁：一种投票机制；


1、watchdog核心:
1、管理和协调本地节点看门狗状态
2、与内置或外部生命检查系统lifecheck交互，用于本地和远程Pgpool-II 节点健康检查。
3、与Pgpool-II主进程进行通讯，通过watchdog执行集群命令；
4、与所有参与的 Pgpool-II 节点通信去协调领导者/协调者节点（leader/coordinator）的选择，并确保集群中的仲裁。
5、管理active/coordinator上的vip，并允许用户提供用于升级和降级的自定义脚本
6、验证watchdog集群中参与的Pgpool-II 节点的Pgpool-II 配置的一致性。
7、在启动时同步所有 PostgreSQL 后端的状态。
8、为 Pgpool-II 主进程提供分布式锁定功能，用于同步不同的故障转移命令。

2、与集群中其他节点通讯：
看门狗使用 TCP/IP 套接字与其他节点进行所有通信。每个看门狗节点可以有两个与每个节点一起打开的sockets，
一个是该节点创建并启动与远程节点的连接的传出（客户端）套接字，
第二个套接字是侦听由远程watchdog节点启动的入站连接的套接字。
一旦与远程节点的套接字连接成功，看门狗就会在该套接字上发送 ADD NODE (WD_ADD_NODE_MESSAGE) 消息。
并且在接收到 ADD NODE 消息后，看门狗节点使用该节点的 Pgpool-II 配置验证消息中封装的节点信息。
如果节点通过验证测试，则会将其添加到群集中，否则连接将断开。

3、IPC和数据格式：
Watchdog 进程公开一个用于 IPC 通信的 UNIX 域套接字，它接受并提供 JSON 格式的数据。
所有的 Pgpool-II 内部进程，包括 Pgpool-II 内置的 lifecheck 和 Pgpool-II 主进程都使用这个 IPC 套接字接口与watchdog进行交互。
该 IPC 套接字也可以被任何外部/第 3 方系统用于与看门狗进行交互。

4、看门狗寿命检查（Watchdog Lifecheck）

看门狗生命检查是看门狗的子组件，用于监控参与看门狗集群的 Pgpool-II 节点的健康状况。
Pgpool-II 看门狗内置了三种远程节点健康检查方法，“心跳”、“查询”和“外部”模式。

在“心跳”模式下，生命检查进程通过 UDP 套接字发送和接收数据以检查远程节点的可用性，
并且对于每个节点，父生命检查进程产生两个子进程，一个用于发送心跳信号，另一个用于接收心跳信号。
在“查询”模式下，lifecheck 进程使用 PostgreSQL libpq 接口来查询远程 Pgpool-II。
在这种模式下，生命检查进程会为每个健康检查查询创建一个新线程，一旦查询完成，该线程就会被销毁。
在“外部”模式下，此模式禁用 Pgpool-II 的内置生命检查，并期望外部系统将监视本地和远程节点。

除了远程节点健康检查外，看门狗 lifecheck 还可以通过监控与上游服务器的连接来检查它安装的节点的健康状况。
为了监控与上游服务器的连接，Pgpool-II lifecheck 使用 execv() 函数执行“ping -q -c3 hostname”命令。
因此，会产生一个新的子进程来执行每个 ping 命令。
这意味着对于每个健康检查周期，都会为每个配置的上游服务器创建和销毁一个子进程。
例如，如果在 lifecheck 中配置了两个上游服务器，并且要求它每隔 10 秒进行一次健康检查，
那么在每 10 秒后，lifecheck 将产生两个子进程，每个上游服务器一个，每个进程将一直存活到 ping 命令完成。


1、心跳检查：
设置参数：heartbeat_destination
配置为对端机器；

2、看门狗配置

远程uxpool节点主机名
other_pgpool_hostname

3、健康检查：
https://blog.csdn.net/weixin_34112208/article/details/90132545#:~:text=health_check_period%20This%20parameter%20specifies%20the%20interval%20between%20the,need%20to%20reload%20pgpool.conf%20if%20you%20change%20health_check_period.
health_check

检测后端数据库，如果网络或服务器异常，执行故障转移；

4、看门狗
1、wd_hostname 	：指定uxpool服务器的ip地址，用于发送/接收查询和数据包；
2、看门狗如何检查uxpool的生命检查（lifecheck）：
看门狗检查的uxpool服务的响应，而不是进程，
通过uxpool发送查询命令到uxdb检查响应情况，
看门狗还检查从uxpool到客户端服务器的链接，用于监控uxpool服务；
配置参数：wd_heartbeat_port
heartbeat_destination检测生命信号的远端uxpool机器；

3、other_pgpool_hostname
监视远程uxpool服务器的ip；

watchdog日志信息：
LOG:  watchdog process is initialized
LOG:  watchdog: escalation started
LOG:  I am the master watchdog node

4、看门狗功能
用于解决单点故障，通过仲裁使故障在处理脑裂和网络分区方面更具容错性，3.7版本引入仲裁故障转移以减少pg服务器故障误报；
pgpool-II 节点的数量必须为奇数，并且大于或等于 3。

a、首先从主watchdog同步所有已配置后端节点的状态，如果uxpool节点继续成为主节点本身，他将在本地初始化后端状态；
b、当后端节点状态因故障转移等改变时，看门狗会将信息通知给其他uxpool并进行同步；
c、发生联机恢复时，watchdog会限制客户端与其他uxpool节点链接，以避免后端之间不一致；
d、与其他uxpool进行协调，以确保故障恢复、故障转移；

5、看门狗（watchdog）的寿命检查（lifecheck），用于监视看门狗集群的uxpool节点运行状况，以提供高可用。
a、心跳模式下，看门狗使用心跳信号定期监视其他uxpool，如果监视失败，看门狗将视为uxpool节点故障；

6、所有uxpool节点配置参数一致









2022-08-02

sql优化计划：

like模糊查询优化：
https://blog.csdn.net/weixin_43922449/article/details/120442352

1、查询优化：
select ux_relation_filepath('t1');
2、查看执行计划：
explain (ANALYZE,VERBOSE,BUFFERS)

执行计划介绍：
https://www.cnblogs.com/duanleiblog/p/13751805.html


1、Index Only Scan
https://www.cnblogs.com/abclife/p/13906623.html
https://wiki.postgresql.org/wiki/Index-only_scans

执行前需要进行vacuum，保证元组数据的可见性，
通过Index Only Scan，可以直接从索引直接输出结果，而无需扫描数据块；

Index Only Scan：包含我们查询语句的所有字段，提取出相应的index，就不必提取数据块了；
Index scan: 输出的是tuple，它先扫描索引块，然后得到rowid扫描数据块得到目标记录。
一次只读一条索引项，那么一个 PAGE面有可能被多次访问。

pg性能优化：
https://blog.csdn.net/pg_hgdb/category_10630706.html
https://www.cnblogs.com/duanleiblog/p/14049247.html#a3

1、like语法优化
https://postgresql.blog.csdn.net/article/details/114123959

2、导入数据优化
https://postgresql.blog.csdn.net/article/details/114585593


性能优化：


查找自上次使用 重置统计信息以来从未使用的索引，重置统计信息函数ux_stat_reset()
SELECT s.schemaname,
       s.relname AS tablename,
       s.indexrelname AS indexname,
       ux_relation_size(s.indexrelid) AS index_size
FROM ux_catalog.ux_stat_user_indexes s
   JOIN ux_catalog.ux_index i ON s.indexrelid = i.indexrelid
WHERE s.idx_scan = 0      -- has never been scanned
  AND 0 <>ALL (i.indkey)  -- no index column is an expression
  AND NOT i.indisunique   -- is not a UNIQUE index
  AND NOT EXISTS          -- does not enforce a constraint
         (SELECT 1 FROM ux_catalog.ux_constraint c
          WHERE c.conindid = s.indexrelid)
ORDER BY ux_relation_size(s.indexrelid) DESC;



PostgreSQL 15版本新特性:
发布时间：2022-5-20号发布
性能提升
PostgreSQL 在最近的多个版本中，一直在持续提升性能，15版本也不例外。此次新版本对大数据集的排序，特别是在数据集大小超过 work_mem参数指定大小时，性能显著提高。

新版本中对各类查询也进行了优化，包括对SELECT DISTINCT指令引入了并行查询功能，对使用row_number(), rank()，count() 等窗口函数也进行了增强。 
现在使用PostgreSQL外部数据封装器postgres_fdw来管理远程数据时，可以并行提交事务。还有多处对分区表查询的性能优化。

PostgreSQL 14版本正式发布：
发布时间：2021-09-30号发布
在高并发、高写入负载、并行查询和逻辑复制等方面的性能提升。
PostgreSQL 14版本中在有大量连接的场景下，大幅提高了事务的吞吐量，在一些测试场景下，最高可达1倍的提升。

PostgreSQL 13正式发布：
发布时间：2020-09-24







CREATE TABLE UXDBC_DBF_CAPITAL_DATESENSITIVE_VIEW_MATVIEW_DELETE_0001_TB01 (ID INT,NAME CHAR(10));
INSERT INTO UXDBC_DBF_CAPITAL_DATESENSITIVE_VIEW_MATVIEW_DELETE_0001_TB01 VALUES (1,'HELLOWORD'),(3,'helloword'),(5,'HELLOword'),(4,'helloword');
CREATE MATERIALIZED VIEW UXDBC_DBF_CAPITAL_DATESENSITIVE_VIEW_MATVIEW_DELETE_0001_VIEW01 AS SELECT * FROM UXDBC_DBF_CAPITAL_DATESENSITIVE_VIEW_MATVIEW_DELETE_0001_TB01;

#150166 

数据库内部对象名长度限制为64位(包含结束符,实际对象名最大为63位)，超过63位会被截断。
按照rowid原有设计，rowid对应的的序列名是在表明的基础上拼接“_UXDB_ROWID_SEQ”构成，
在表名恰为64位时序列名拼接部分丢失，造成rowid序列名与表名相同；
所以在对该表rowid序列名初始化时，由于该序列名与表名相同，识别到该表不是一个序列报错；

2022-08-30





2022-08-31

兼容模式下，两个字符字段，通过jdbc绑定参数插入数据，第一个设置为空串，第二个为null ，
会报 错“insufficient data left in message”

 insert into organ( memo,guidkey ) values('',null);


(gdb) p *input_message
{data = 0x2e6d260 "", len = 20, maxlen = 1024, cursor = 10}


正常：
x/20b msg->data
0x2e6d260:      0       0       0       2       0       0       0       0
0x2e6d268:      0       2       255     255     255     255     0       0
0x2e6d270:      0       0       0       0



2022-09-01
问题单：137770
--release=standard
--version=2.1.1.4
--license=commercial
--extension-adaptor=yes
--block-size=32
--nouxfs
--extended_parameters

./build.sh --release=standard --version=2.1.1.4 --license=commercial --extension-adaptor=yes --nouxfs --extended_parameters


2022-09-05

c语言提高





2022-09-08

explain：

1、explain参数介绍：
analyze 默认为true，会把query实际执行一遍；
VERBOSE 输出结果集的各个列， 输出信息查看Output:
BUFFERS 显示共享缓冲区命中信息；



2、计划树是从下往上执行；
3、输出信息介绍：
Seq Scan  ：全表扫描
Filter: 	过滤条件
Rows Removed by Filter: 表明过滤了多少行数据，属于Seq Scan 节点的VERBOSE 信息，只有EXPLAIN 命令中的VERBOSE 选项为on 时才会显示；
Buffers: shared hit=11 表明了从共享缓存中命中了11 个BLOCK，属于Seq Scan 节点的BUFFERS 信息，只有EXPLAIN 命令中的BUFFERS 选项为on 时才会显示
Planning time: 0.066 ms 表明了生成查询计划的时间
Execution time: 0.160 ms 表明了实际的SQL 执行时间，其中不包括查询计划的生成时间

Index Scan 是索引扫描；
Index Scan using no_index on public.class 表明是使用的public.class 表的no_index 索引对表进行索引扫描的
Index Cond:索引扫描的条件

IndexOnly Scan 是覆盖索引扫描
Heap Fetches 表明需要扫描数据块的个数


BitmapHeap Scan：
把Index Scan 的随机读转换成了按照数据块的物理顺序读取，在数据量比较大的时候，这会大大提升扫描的性能。
可以运行set enable_indexscan =off; 来指定关闭Index Scan 

Bitmap Index Scan on no_index 表明使用no_index 索引进行位图索引扫描
Index Cond: (class.st_no = 2) 表明位图索引的条件为class.st_no = 2
Bitmap Heap Scan on public.class 表明对public.class 表进行Bitmap Heap 扫描
Recheck Cond: (class.st_no = 2) 表明Bitmap Heap Scan 的Recheck操作 的条件是class.st_no = 2，这是因为Bitmap Index Scan 节点返回的是位图，位图中每位代表了一个扫描到的数据块，通过位图可以定位到一些符合条件的数据块（这里是3，Buffers: shared hit=3），而Bitmap Heap Scan 则需要对每个数据块的元组进行Recheck
Heap Blocks: exact=1 表明准确扫描到数据块的个数是1


一般来说：
大多数情况下，Index Scan 要比 Seq Scan 快。但是如果获取的结果集占所有数据的比重很大时，这时Index Scan 因为要先扫描索引再读表数据反而不如直接全表扫描来的快。
如果获取的结果集的占比比较小，但是元组数很多时，可能Bitmap Index Scan 的性能要比Index Scan 好。
如果获取的结果集能够被索引覆盖，则Index Only Scan 因为不用去读数据，只扫描索引，性能一般最好。但是如果VM 文件未生成，可能性能就会比Index Scan 要差。


2022-09-15

1、指针指向字符串常量，常量保存在全局静态数据区，且该数据不能被修改；

2、const修改的变量或指针，表示该变量或指针是只读的；
eg：
const int *p1;
int const *p2;
int * const p3;
在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；
在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。

3、函数参数使用字符串常量， 参数指针指向常量区；

函数指针指向地址被改变：
https://bbs.csdn.net/topics/380023886

2022-09-20

connection_cache

uxpool.conf修改参数：
search_primary_node_timeout				//执行故障切换命令时，查找主节点的时间，当没有活跃节点时，该参数影响健康检查时间；
connect_timeout

set args -n -d > uxpool.log 2>&1
handle SIGUSR1 nostop
b trigger_failover_command


2022-09-21



select * from UX_DEPEND;

add_exact_object_address_extra
测试用例：
create table tb(id int);
create schema so5;
create synonym table so5.test_syn on tb;
drop schema so5;
create synonym table so5.test_syn on tb;


报错：
cannot drop %s because other objects depend on it

REFCLASSID：
REFOBJID：oid

CLASSID | OBJID | OBJSUBID | REFCLASSID |  			REFOBJID
			表oid			模式oid所在表			表依赖的模式oid

生成oid：
GetNewObjectId

插入uxdepend：
recordDependencyOn
	recordMultipleDependencies


同义词删除函数失败：
原因：可能函数有特殊处理，查看UX_DEPEND中的函数依赖关系是怎么建立的？
select * from UX_DEPEND WHERE OBJID = 16775

oid的生成：
https://xiaowing.github.io/post/20171117_pg_knowhow_oid/#:~:text=OID%E7%9A%84%E7%94%9F%E6%88%90%E6%9C%BA%E5%88%B6%20%E5%BD%93%E4%B8%80%E6%9D%A1%E5%85%83%E7%BB%84%E8%A2%ABINSERT%E5%88%B0%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%97%B6%E5%80%99,%28%E4%B9%9F%E5%8C%85%E6%8B%AC%E8%AF%AD%E6%B3%95%E5%B1%82%E9%9D%A2%E7%9A%84%20UPDATE%20%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%9B%A0%E4%B8%BAPG%E4%B8%AD%E7%9A%84UPDATE%E6%9C%AC%E8%B4%A8%E4%B8%8A%E6%98%AF%E5%B0%86%E6%9B%B4%E6%96%B0%E5%89%8D%E7%9A%84%E6%97%A7%E5%85%83%E7%BB%84%E6%A0%87%E8%AE%B0%E4%B8%BA%E6%97%A0%E6%95%88%E5%B9%B6%E6%96%B0%E5%A2%9E%E5%85%83%E7%BB%84%29%E3%80%82



索引添加：
1、
src/include/catalog/indexing.h
添加对应字段索引，例如，给oid添加索引；
2、src/backend/utils/cache/syscache.c
添加cache字段信息
3、src/include/utils/syscache.h
该位置需要与第2步对应，否则编译会报错
4、使用索引SynonymOidIndexOId
	//对rel表随机生成一个oid
	oid = GetNewOidWithIndex(rel, SynonymOidIndexOId,
									Anum_ux_synonym_oid);

2022-09-26

复现问题：

create table tb(exp_date TIMESTAMP WITH TIME ZONE);
insert into tb values(sysdate);
select * from tb where EXP_DATE = (EXP_DATE - 1);
select * from tb where EXP_DATE = (EXP_DATE + 1);
select * from tb where EXP_DATE < '2020-10-11 00:00:00+08'::TIMESTAMPtz + 1;
select * from tb where EXP_DATE > '2020-10-11 00:00:00+08'::TIMESTAMPtz - 1;


这个是已经有TIMESTAMP WITHOUT TIME ZONE 和 int 的操作符了

但是没有TIMESTAMP WITH TIME ZONE 和 int的操作符


TIMESTAMP WITHOUT TIME ZONE：不带时区：TIMESTAMP
TIMESTAMP WITH TIME ZONE：带时区：TIMESTAMPTZ

TIMESTAMP加法：
CREATE OR REPLACE FUNCTION oracle.add_days_to_timestamp(TIMESTAMPTZ,integer)
RETURNS timestamptz AS $$
SELECT ($1 + interval '1 day' * $2) :: TIMESTAMPTZ;
$$ LANGUAGE SQL IMMUTABLE;

CREATE OPERATOR UX_CATALOG.+ (
  LEFTARG   = TIMESTAMPTZ,
  RIGHTARG  = INTEGER,
  PROCEDURE = oracle.add_days_to_timestamp
);

TIMESTAMP减法：
CREATE OR REPLACE FUNCTION oracle.subtract(TIMESTAMPTZ,integer)
RETURNS timestamptz AS $$
SELECT ($1 - interval '1 day' * $2) :: TIMESTAMPTZ;
$$ LANGUAGE SQL IMMUTABLE;

CREATE OPERATOR UX_CATALOG.- (
  LEFTARG   = TIMESTAMPTZ,
  RIGHTARG  = INTEGER,
  PROCEDURE = oracle.subtract
);

TIMESTAMPTZ大于：
CREATE OR REPLACE FUNCTION UX_CATALOG.GTTIMESTAMPTZ(TIMESTAMPTZ,integer)
RETURNS BOOLEAN AS 
$$
	SELECT $1 > $2::TIMESTAMPTZ;
$$LANGUAGE SQL IMMUTABLE;

CREATE OPERATOR UX_CATALOG.> (PROCEDURE = GTTIMESTAMPTZ, LEFTARG = TIMESTAMPTZ, RIGHTARG = integer, COMMUTATOR = <, NEGATOR = <=);

TIMESTAMPTZ小于：





相关问题单：
103554 

create table test2 as select (to_timestamp('2010-2-12 13:24:52.123456','YYYY-MM-DD HH24:MI:SS.FF6')) + (SELECT CAST('1' AS int)) -(to_timestamp('2010-2-12 13:24:52.123456','YYYY-MM-DD HH24:MI:SS.FF6'));
create table test1 as select (time(1) without time zone '2016-07-08 12:00:00.234') + (SELECT CAST('1' AS int)) -(time(1) without time zone '2016-07-08 12:00:00.234');


2022-10-09

1、
语法词法分析：
https://blog.csdn.net/x311609001028/article/details/79781687



2022-10-11
1、添加repmgrd
sudo vi /etc/logrotate.d/repmgrd

2、修改repmgrd文件
添加su命令，指定用户组进行翻转
/home/uxdb/uxdbinstall/dbsql/bin/logrepmgrd.log {
        missingok
        compress
        rotate 1
        maxsize 4K
		dateext
        weekly
        create 0600 uxdb uxdb
        postrotate
            /usr/bin/killall -HUP repmgrd
        endscript
        su root root
}

rotate：指定保存多少个备份文件
hourly：每小时回滚一次日志
minsize 1M ：文件大小超过 1M 后才会切割
dateext：指定滚动文件的后缀是当前日期


3、手动强制切割日志
sudo logrotate -f  /etc/logrotate.conf

调试logrotate
sudo logrotate -vfd /etc/logrotate.d/repmgrd



2022-10-13







8、

【现场问题】：
[不带安全属性的用户输入]测试项要求:
1.导入文件要求是[带有安全属性的用户数据输出]测试项导出的含有标记的数据文件；
2.要求导入时数据库自动识别标记字段，根据导入用户自动生成标记。(即导入用户在写入这个数据时，标记为导入用户的默认写标记)

验证步骤
1、找强访标记
2、验证dump导出后，将标记删除，然后导入，看标记是否重新生成；
3、如果重新生成，那只需要在导出时，将标记删除即可；
否则，需要查看如何重新生成标记



7、

执行命令：

./ux_dump -p 5432 -U uxdumprestore -n public -P -F p -d uxdb>uxdbdump.sql

uxsql -p 5432 -U uxdumprestore uxdb <uxdbdump.sql

查看是否审计：
./uxsql -U uxdumprestore -d uxdb
select * from uxaudit.log_event;

ux_dump日志：
_selectOutputSchema

只导出数据：
./ux_dump -p 5432 -U uxdumprestore -n public -P -F p -d uxdb -a >uxdbdump.sql

问题：
1、添加标记，无法通过普通用户使用copy
2、使用uxdumprestore用户，通过uxdumprestore用户进行备份恢复；
但uxdumprestore使用copy命令的标记，未使用uxdumprestore用户默认标记；


命令：

查看用户拥有模式权限：
\dn+ 或者
select a.nspname,b.rolname,string_agg(a.pri_t,',') from (select nspname,(aclexplode(COALESCE(nspacl, acldefault('n'::"char",nspowner)))).grantee as grantee,(aclexplode(COALESCE(nspacl, acldefault('n'::"char",nspowner)))).privilege_type as pri_t from pg_namespace where nspname not like 'pg%' and nspname <> 'information_schema') a,ux_authid b where (a.grantee=b.oid or a.grantee=0) and b.rolname='uxdb' group by a.nspname,b.rolname;

-p 5432 -U uxdumprestore -n public -P -F p -d uxdb>uxdbdump.sql

2022-10-14

uxsql 恢复命令调试
命令：
uxsql -p 5432 -U uxdumprestore uxdb <uxdbdump.sql

调试文件：startup.c

idle出现位置：
359                     pset.db = UXSQLconnectdbParams(keywords, values, true)

2022-10-18

timer定时器验证：
create extension ux_cron;

create table order1 (date timestamp, status int);

insert into order1 values ('2019-08-01', 0);

insert into order1 values ('2019-08-21', 2);

insert into order1 values ('2019-09-01', 0);

insert into order1 values ('2019-08-11', 0);

insert into order1 values ('2019-11-11', 0);
insert into order1 values ('2022-11-11', 0);


CREATE FUNCTION e_test() RETURNS void
AS $e_test$
 BEGIN
       update order1 set status=5 where TO_TIMESTAMP(now()::text, 'YYYY-MM-DD HH24:MI:SS.US') > TO_TIMESTAMP(date::text, 'YYYY-MM-DD HH24:MI:SS.US') and status=0;
 END;
 $e_test$ LANGUAGE pluxsql;

CREATE EVENT TRIGGER event_test ON timer
EXECUTE PROCEDURE e_test();

ALTER EVENT TRIGGER event_test ENABLE;

select * from order1 ;

查看定时任务号：
select * from cron.job;

停止任务：
select * from cron.unschedule(1);

2022-10-24

编译报错
1、不存在这个文件gnu/stubs-n32_hard.h
修改方法：注释头文件
 /usr/include/gnu/stubs.h  +23

2、报错： 
/lib64/libdl.so: error adding symbols: file in wrong format

修改方法：

由于configure默认编译32位（可以通过config查看编译参数）
mips编译参数：
linux64-mips64
所以编译方式通过：
./configure linux64-mips64

3、core问题
mips平台，
set jit = on；
执行层次查询时，有段错误

修改代码：


1、
根据nodes.h文件中参数修改：
~/uxdb_devel/uxdb-ng/uxdb-2.1/src/include/nodes/nodes.h

	T_HierarClause,
	T_ConnectBy,
	T_StartWith,
	T_PriorClause,
	T_SysConnectPath,
	T_ConnectRoot,


/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/executor/execExpr.c
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/executor/execExprInterp.c
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/jit/llvm/llvmjit_expr.c

linux已安装软件命令：
rpm -qa|grep llvm
卸载安装包：
sudo rpm -e llvm9.0-libs-9.0.1-9.el7.x86_64 llvm9.0-9.0.1-9.el7.x86_64
查看llvm所有安装包：
sudo yum list |grep llvm
或者	yum search llvm


ExecProcNode			：循环第84次报错，调试到83
ExecSort				：循环第15次报错，调试到14		打断点 ExecRunCompiledExpr
ExecRunCompiledExpr		：循环第11次报错，调试到10		打断点 ExecRunCompiledExpr
llvm_compile_expr		：循环第14次报错，调试到13		打断点 llvm_compile_expr
ExecMergeJoin			: 循环第2次报错，调试到1		打断点	ExecProject




段错误位置：
evalexpr_0_13





EEOP_ASSIGN_SCAN_VAR
EEOP_DONE




llvm调试方法：
https://blog.csdn.net/zhongyunde/article/details/109013865

复现core语句：
create table tab_connect_by (child number,parent number);
insert into tab_connect_by (CHILD, PARENT) values(15, 38);
insert into tab_connect_by (CHILD, PARENT) values(38, null);
create table a1 as select * from tab_connect_by;

select a.CHILD from tab_connect_by a inner join a1 w on a.child=w.child start with a.PARENT is null connect by prior a.child = a.parent ;

构造内连接：
create table tab_connect_by (child number,parent number);
insert into tab_connect_by (CHILD, PARENT) values(15, 38);
insert into tab_connect_by (CHILD, PARENT) values(38, null);
create table a1 as select * from tab_connect_by;

正常sql：
select a.CHILD from tab_connect_by a inner join a1 w on a.child=w.child;
select a.CHILD from tab_connect_by a inner join a1 w on a.child=w.child connect by prior a.child = a.parent;



2022-10-27
报错信息：
1、
/data/uxdata

2、
repmgrd启动：
starting up

项目名称：
A01087028202220002
东北证券带外管理系统建设项目

2022-10-29



               HeapTuple tuple;
               HeapTuple user_label_tup;
               Oid policy_id = InvalidOid;
               Oid ulevel = InvalidOid;
               Oid uscope = InvalidOid;

               Oid plc_level = HeapTupleGetPlCol2(tuple);
               Oid plc_scope = HeapTupleGetPlCol3(tuple);
                       policy_id = RelationGetMacPolicyId(cstate->rel, InvalidOid);

                               user_label_tup = SearchSysCache2(USERLABELUSERPOLICY, ObjectIdGetDatum(GetUserId()), ObjectIdGetDatum(policy_id));
                       if (HeapTupleIsValid(user_label_tup))
                       {
                               ulevel = ((Form_ux_user_label)GETSTRUCT(user_label_tup))->max_read_level;
                               uscope = ((Form_ux_user_label)GETSTRUCT(user_label_tup))->max_read_scope;
                               ReleaseSysCache(user_label_tup);
                       }

                       if(ulevel >= plc_level && (plc_scope&uscope)==plc_scope)
                       {
                                                       /* Format and send the data */
                               CopyOneRowTo(cstate, HeapTupleGetOid(tuple), HeapTupleGetPlCol1(tuple), HeapTupleGetPlCol2(tuple), HeapTupleGetPlCol3(tuple), values, nulls);
                               processed++;
                       }



2022-10-31

一、验证以下步骤：
那再完善一下第三点（FTP_ITC.1）的场景（均包括客户端和服务端信息说明）：
1）单节点访问，会话被锁定，记录日志和审计表
2）单节点访问，ssl证书到期，记录日志和审计表
3）主备模式，ssl证书到期，记录日志和审计表


openssl证书配置：
https://blog.csdn.net/qq_34479012/article/details/125629699?spm=1001.2014.3001.5501

openssl x509 -req -in root.csr -text -days 3650 -extfile /home/uxdb/openssl/openssl.cnf -extensions v3_ca -signkey root.key -out root.crt
openssl req -new -nodes -text -out server.csr -keyout server.key -subj "/CN=test1"


openssl x509 -req -in server.csr -text -days 365 -CA root.crt -CAkey root.key -CAcreateserial -out server.crt


uxsql "host=localhost user=uxdb dbname=uxdb password=1qaz!QAZ sslmode=require"
uxsql "host=192.71.0.139 user=uxdb dbname=uxdb password=1qaz\!QAZ sslmode=verify-ca"

linux恢复系统时间：
sudo ntpdate -u ntp.api.bz

查看证书的有效期：

cat server.crt |openssl x509 -noout -enddate

12、校验证书是否过期

openssl x509 -in server.crt -checkend 0


设置ssl认证到期时间：
202210311637Z
-startdate 120814050000Z -enddate 120814060000Z 
openssl x509 -req -in server.csr -text -startdate 202210311637Z -enddate 202210311640Z  -CA root.crt -CAkey root.key -CAcreateserial -out server.crt

openssl x509 -req -in server.csr -text -enddate 20170106071311Z  -CA root.crt -CAkey root.key -CAcreateserial -out server.crt

openssl ca -config conf/caconfig.cnf -startdate 20160107071311Z -enddate 20170106071311Z -batch -out server_cert_2048.pem -in

gmssl配置：

步骤1、
# 生成ca相关：
gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -pkeyopt ec_param_enc:named_curve -out ca.old
gmssl req -new -days 365 -sm3 -x509 -key ca.old -text -subj "/C=CN/ST=China/L=Beijing/O=uxsino/OU=UXDB/CN=uxsino.com_CA" -out ca.crt
gmssl sms4 -in ca.old -out ca.key -a -k '1qaz!QAZ'

# 生成server相关
gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -pkeyopt ec_param_enc:named_curve -out server.old
gmssl req -new -key server.old -out server.req -subj "/C=CN/ST=China/L=Beijing/O=uxsino/OU=UXDB/CN=uxsino.com_server"
gmssl sms4 -d -a -k '1qaz!QAZ' -in ca.key -out ca.new
gmssl x509 -req -in server.req -CA ca.crt -CAkey ca.new -set_serial 111111 -text -days 365 -sm3 -out server.crt
gmssl sms4 -in server.old -out server.key -a -k '1qaz!QAZ'

# 生成client相关
gmssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:sm2p256v1 -pkeyopt ec_param_enc:named_curve -out uxsinodb.old
gmssl req -new -key uxsinodb.old -out uxsinodb.req -subj "/C=CN/ST=China/L=Beijing/O=uxsino/OU=UXDB/CN=uxsino.com_client"
gmssl sms4 -d -a -k '1qaz!QAZ' -in ca.key -out ca.new2
gmssl x509 -req -in uxsinodb.req -CA ca.crt -CAkey ca.new2 -set_serial 111111 -text -days 1 -sm3 -out uxsinodb.crt
gmssl sms4 -in uxsinodb.old -out uxsinodb.key -a -k '1qaz!QAZ'

# 修改权限
chmod 0400 server.key
chmod 0400 uxsinodb.key

cp ca.crt ~/.uxsinodb/root.crt
cp uxsinodb.key ~/.uxsinodb/
cp uxsinodb.crt ~/.uxsinodb/

# 修改集群配置文件
vim UXDATA/uxsinodb.conf
ssl = on
ssl_ciphers = 'ECDHE-SM2-WITH-SMS4-SM3'
ssl_ecdh_curve = 'sm2p256v1'
ssl_cert_file = '../server.crt'
ssl_key_file = '../server.key'
ssl_ca_file = '../ca.crt'

vim UXDATA/ux_hba.conf
hostssl all all 0.0.0.0/0 md5 00:00-24:00 clientcert=1
#host all all 0.0.0.0/0 md5 00:00-24:00

步骤2：
date -s 12/12/2022			//时间选择使客户端认证过期，服务端认证正常；

步骤3：
注意：启动数据库需要带参数-Q
启动数据库：
./ux_ctl -I -D data -Q start

步骤4：
链接数据库：

uxsql "host=[ip地址] user=uxdb dbname=uxdb password=1qaz\!QAZ sslmode=verify-ca"		//host需要指定ip地址，如果默认本地链接，非tcp链接，故未获取本地ip地址；
步骤5：
查看审计日志

2022-11-3
pg机制：

1、wal日志流复制：
https://blog.csdn.net/Wemesun/article/details/126213248


2、

执行alter system命令

根据
uxsinodb.login

PathNameOpenFile




	remove("master_slave.txt");
	srand(time(NULL));

    FILE* fp = fopen("master_slave.txt", "w");//打开文件文本

    if (fp == NULL)//判断是否打开成功
    {
        printf("Open File Error\n");
        return;
    }
	fprintf(fp,"%5d",rand()%100);
    fclose(fp);//关闭文件文本

shell脚本:

1、shell脚本调试
执行命令(使用-x)：
bash -x xxx.sh

uxdbpath="/home/uxdb/uxdbinstall/dbsql/bin"
masterpath="$uxdbpath/master"		#主机集簇路径
standbypath="$uxdbpath/slave_1"		#备机集簇路径
standbyip="uxdb2"
tempFile="$masterpath/master_slave.txt"						#master_slave.txt配置（该路径配置不用改）



MD5FIRST="first"

while :
do
if [[ ! -f "$tempFile" ]]; then
master_exist=0
MD5FIRST="null"
fi

if [[ -f "$tempFile" ]]; then
master_exist=1
fi

if [[ ($master_exist -eq 1) && ("$MD5FIRST" == "first")]]; then
MD5FIRST=`md5sum $tempFile`
fi

if [[ $master_exist -eq 1 ]]; then				#master_slave.txt文件已经存在
	MD5NUM=`md5sum $tempFile`
	if [ "$MD5NUM" != "$MD5FIRST" ]; then		#字符串比较用!=
	scp $masterpath/uxsinodb.auto.conf uxdb@$standbyip:$standbypath
	ssh -T $standbyip  "$uxdbpath/ux_ctl reload -D $standbypath"
	MD5FIRST=$MD5NUM
	fi
fi
sleep 2
done


ux_syn_uxsinodb_auto.sh脚本需要在执行select ux_reload_conf()前启动；
因为脚本中的系统命令可能有告警，让脚本在后端执行，且将日志输出到一个文件中：
nohup sh ux_syn_uxsinodb_auto.sh >results.log&

2022-11-07

dbt5编译：
cmake . -DDBMS=pgsql

2022-11-08


高斯tpce：
https://gitee.com/hwrd/dbt5-tpce-for-opengauss


2022-11-16




select
 a.attname as filed,
 (case
  when a.attnotnull = true then 'NO'
  else 'YES' end) as null,
 (case
  when (
  select
   count(ux_constraint.*)
  from
   ux_constraint
  inner join ux_class on
   ux_constraint.conrelid = ux_class.oid
  inner join ux_attribute on
   ux_attribute.attrelid = ux_class.oid
   and ux_attribute.attnum = any(ux_constraint.conkey)
  inner join ux_type on
   ux_type.oid = ux_attribute.atttypid
  where
   ux_class.relname = c.relname
   and ux_constraint.contype = 'p'
   and ux_attribute.attname = a.attname) > 0 then true
  else false end) as key,
 concat_ws('', t.typname) as type,
 
  col1.is_identity as extra,
  col1.column_default as default 
from
    ux_tables ta,
 ux_class c,
 ux_attribute a ,
 ux_type t,
 information_schema.columns as col1
where
    ta.tablename=c.relname
 and a.attnum>0
 and a.attrelid = c.oid
 and a.atttypid = t.oid
 and col1.table_name=c.relname and col1.column_name=a.attname
 and ta.schemaname= col1.table_schema
 and ta.schemaname  ='模式名'
 and (c.relnamespace::regnamespace)::text='模式名'
 and c.relname='表名'
order by
    ta.schemaname,
 c.relname desc
 ;


show  columns  from 


show create table 
问题单：146876

SHOW COLUMNS FROM student_info; 
field（字段名）	type（字段类型） Null（是否不能为null） key（键值） default（默认值） Extra（）

	HeapTuple tuple = NULL;
	Form_ux_class classForm = NULL;
	tableInfo tableinfo;
	tuple = SearchSysCache1(RELOID, ObjectIdGetDatum(tableoid));
	if (!HeapTupleIsValid(tuple))
	{
		ereport(ERROR, (errcode(ERRCODE_CACHE_LOOKUP_FAILED), errmsg("cache lookup failed for table %u.", tableoid)));
	}
	classForm = (Form_ux_class)GETSTRUCT(tuple);

	int natts = get_relnatts(tableoid);
	for (i = 0; i < natts; i++) 
	{
		HeapTuple tp = SearchSysCache2(ATTNUM, ObjectIdGetDatum(tableoid), Int16GetDatum(i + 1));
		if (HeapTupleIsValid(tp))
		{
			Form_ux_attribute att_tup = (Form_ux_attribute)GETSTRUCT(tp);

			char* result = NULL;
			Datum txt;
			if (att_tup->attisdropped)
			{
				ReleaseSysCache(tp);
				continue;
			}
			/* is local */
			if(!att_tup->attislocal && !relispartition)
			{
				ReleaseSysCache(tp);
				continue;
			}
			txt = DirectFunctionCall2(
				format_type, ObjectIdGetDatum(att_tup->atttypid), ObjectIdGetDatum(att_tup->atttypmod));
			quote_identifier(NameStr(att_tup->attname));			//获取属性名field
			result = TextDatumGetCString(txt);						//获取数据类型type
			if (att_tup->attnotnull)								//判断是否为null
			if (att_tup->atthasdef) 								//获取默认值
			{
				Relation attrdefDesc;
				ScanKeyData skey[2];
				SysScanDesc adscan;
				HeapTuple tup = NULL;
				bool isnull = false;

				attrdefDesc = table_open(AttrDefaultRelationId, AccessShareLock);
				ScanKeyInit(&skey[0], Anum_ux_attrdef_adrelid, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(tableoid));
				ScanKeyInit(&skey[1], Anum_ux_attrdef_adnum, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(att_tup->attnum));
				adscan = systable_beginscan(attrdefDesc, AttrDefaultIndexId, true, NULL, 2, skey);

				while (HeapTupleIsValid(tup = systable_getnext(adscan))) 
				{
					Datum val,
							txt;
					char *tmptxt = NULL;
					val = fastgetattr(tup, Anum_ux_attrdef_adbin, attrdefDesc->rd_att, &isnull);
					txt = DirectFunctionCall3(ux_get_expr, val, ObjectIdGetDatum(tableoid), true);
					tmptxt = TextDatumGetCString(txt);
					if (att_tup->attgenerated == ATTRIBUTE_GENERATED_STORED)
						appendStringInfo(buf, " GENERATED ALWAYS AS %s STORED", tmptxt);
					else 
					{
						if(tmptxt != NULL && strlen(tmptxt) > 0)
							appendStringInfo(buf, " DEFAULT %s", tmptxt);
					}
				}	
				systable_endscan(adscan);
				table_close(attrdefDesc, AccessShareLock);
			}
				
			ReleaseSysCache(tp);
	}
		
		get_index_list_info										//获取索引信息

static void
get_table_att_type_default(Oid tableoid, StringInfo tfield, StringInfo ttype,StringInfo tnull,StringInfo tdefault, Oid reloftype, bool relispartition)
{
	int i;
	int actual_atts = 0;
	int natts = get_relnatts(tableoid);
	for (i = 0; i < natts; i++) 
	{
		HeapTuple tp = SearchSysCache2(ATTNUM, ObjectIdGetDatum(tableoid), Int16GetDatum(i + 1));
		if (HeapTupleIsValid(tp))
		{
			Form_ux_attribute att_tup = (Form_ux_attribute)GETSTRUCT(tp);

			char* result = NULL;
			Datum txt;
			if (att_tup->attisdropped)
			{
				ReleaseSysCache(tp);
				continue;
			}
			/* is local */
			if(!att_tup->attislocal && !relispartition)
			{
				ReleaseSysCache(tp);
				continue;
			}
			txt = DirectFunctionCall2(
				format_type, ObjectIdGetDatum(att_tup->atttypid), ObjectIdGetDatum(att_tup->atttypmod));

			strcpy(tfield.data, quote_identifier(NameStr(att_tup->attname)));
			strcpy(ttype.data,TextDatumGetCString(txt));

			if (att_tup->attnotnull)
				strcpy(tnull.data, "NO");
			else
				strcpy(tnull.data, "YES");
			if (att_tup->atthasdef) 
			{
				Relation attrdefDesc;
				ScanKeyData skey[2];
				SysScanDesc adscan;
				HeapTuple tup = NULL;
				bool isnull = false;

				attrdefDesc = table_open(AttrDefaultRelationId, AccessShareLock);
				ScanKeyInit(&skey[0], Anum_ux_attrdef_adrelid, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(tableoid));
				ScanKeyInit(&skey[1], Anum_ux_attrdef_adnum, BTEqualStrategyNumber, F_OIDEQ, ObjectIdGetDatum(att_tup->attnum));
				adscan = systable_beginscan(attrdefDesc, AttrDefaultIndexId, true, NULL, 2, skey);

				while (HeapTupleIsValid(tup = systable_getnext(adscan))) 
				{
					Datum val,
							txt;
					char *tmptxt = NULL;
					val = fastgetattr(tup, Anum_ux_attrdef_adbin, attrdefDesc->rd_att, &isnull);
					txt = DirectFunctionCall3(ux_get_expr, val, ObjectIdGetDatum(tableoid), true);
					tmptxt = TextDatumGetCString(txt);
					if (att_tup->attgenerated == ATTRIBUTE_GENERATED_STORED)
						appendStringInfo(buf, " GENERATED ALWAYS AS %s STORED", tmptxt);
					else 
					{
						if(tmptxt != NULL && strlen(tmptxt) > 0)
							strcpy(tdefault.data, tmptxt);
						else
							strcpy(tdefault.data, "NULL");
					}
				}	
				systable_endscan(adscan);
				table_close(attrdefDesc, AccessShareLock);
			}
			ReleaseSysCache(tp);
		}
	}
	return;
}

create table tb1(did int primary key,id int UNIQUE);

create table tb(id int primary key, name text not null);


SHOW COLUMNS FROM tb;


2022-11-18

show columns from table语法介绍：

key
1、索引第一列显示 mul		（所有索引显示mul，如果索引为组合索引，那么创建组合索引第一列显示mul）
2、如果有多个Key值应用于表的给定列，Key将按PRI、UNI、MUL的顺序显示优先级最高的那个。
3、如果多个列组成一个复合UNIQUE索引，UNIQUE索引可以显示为MUL

Extra：
auto_increment： 用于具有自动递增属性的列。
on update CURRENT_TIMESTAMP：用于具有on update CURRENT_TIMESTAMP属性的TIMESTAMP或DATETIME列
VIRTUAL GENERATED or STORED GENERATED：用于生成列
DEFAULT_GENERATED：用于具有表达式默认值的列。


2022-11-21


获取索引：
get_table_alter_info
	get_index_list_info
		ux_get_indexdef_worker















测试用例：

2、如果有多个Key值应用于表的给定列，Key将按PRI、UNI、MUL的顺序显示优先级最高的那个。

3、如果多个列组成一个复合UNIQUE索引，UNIQUE索引可以显示为MUL
create table demo3(id int unique,idme varchar(20),pwd varchar(20));
alter table demo3 add unique (id, idme);
show columns from demo3;

后面字段后面跟空格：
create table demo13(id int,idme varchar(20),pwd varchar(20));
alter table demo13 add unique(id                       , idme);
show columns from demo13;


alter index：

primary验证：
create table demo(id int primary key,idme varchar(20),pwd varchar(20));
alter table demo add unique (id);
show columns from demo;
drop table demo;



unique验证：

create table demo(id int,idme varchar(20),pwd varchar(20));
alter table demo add unique (id);
show columns from demo;
drop table demo;

如果多个列组成一个复合UNIQUE索引，UNIQUE索引可以显示为MUL
create table demo(id int,idme varchar(20),pwd varchar(20));
alter table demo add unique (id, idme);
show columns from demo;
drop table demo;

字段后面跟空格：
create table demo(id int,idme varchar(20),pwd varchar(20));
alter table demo add unique(id                       , idme);
show columns from demo;
drop table demo;











alter验证优先级






验证create index
create table demo(id int,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id);
show columns from demo;
drop table demo;

create table demo(id int unique,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id,   idme);
show columns from demo;
drop table demo;


验证create unique

create table demo(id int,idme varchar(20),pwd varchar(20));
create unique index inx1 on demo(id);
show columns from demo;
drop table demo;

create table demo(id int not null,idme varchar(20),pwd varchar(20));
create unique index inx1 on demo(id  , idme);
show columns from demo;
drop table demo;

create (unique)index验证优先级：
create table demo(id int,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id);
show columns from demo;
drop table demo;

create table demo(id int primary key,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id);
show columns from demo;
drop table demo;


create table demo(id int,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id,   idme);
create unique index inx1 on demo(id);
show columns from demo;
drop table demo;

create table demo(id int primary key,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id,   idme);
create unique index inx1 on demo(id);
show columns from demo;
drop table demo;



create table demo(id int unique,idme varchar(20),pwd varchar(20));
create index inx2 on demo(id,   idme);
show columns from demo;
drop table demo;


多字段验证：
create table demo(id int primary key,idme varchar(20) unique,pwd varchar(20));
alter table demo add unique(id                       , idme);
create index inx2 on demo(pwd);
show columns from demo;
drop table demo;


2022-11-22

show index from 语句实现
各字段介绍
Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment 

--Table：表名
--Non_unique：是否包含重复项，如果不包含，为0，否则，包含为1；
--Key_name：索引名称，如果索引是主键，则名称总是primary。（联合索引，索引名称相同）
--Seq_in_index：索引Key_name中的列序列号，从1开始。
--Column_name：Key_name中对应Seq_in_index的列名。
Collation：在索引中如何对列排序。它可以有值A(升序)、D(降序)或NULL(未排序)。
--Cardinality：行数，根据统计信息进行计数的；
--Sub_part：如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL
--Packed：指示key如何被压缩。如果没有被压缩，则为NULL。
--Null：该字段是否可以为null，如果是：yes，不是为空
Index_type：索引类型
Comment：字段注释
Index_comment：索引注释

添加字段注释：
comment on column demo1.id is '123';
添加索引注释：
comment on index demo1_idme_key is 'index_comm';
查看表注释信息：
Select a.attnum,(select description from ux_catalog.ux_description where objoid=a.attrelid and objsubid=a.attnum) as descript ,
a.attname,ux_catalog.format_type(a.atttypid,a.atttypmod) as data_type from ux_catalog.ux_attribute a where 1=1 and 
a.attrelid=(select oid from ux_class where relname='demo1' ) and a.attnum>0 and not a.attisdropped order by a.attnum;



测试用例：
--Non_unique
--Null
create table demo(id int,idme varchar(20),pwd varchar(20));

create index inx3 ON demo(idme, id);
--Cardinality
insert into demo(id) select generate_series(1,99);
--Comment
comment on column demo.id is '123';
--Index_comment
comment on index inx1 is 'index_comm';


2022-11-28

FORMAT(x,n)将数字x格式化，并以四舍五入的方式保留小数点后n位，结果以字符串形式返回。若n位0则返回结果函数不含小数部分。

mysql> select format(12332.123456,4),format(12332.1,4),format(12332.2,0);
+------------------------+-------------------+-------------------+|
format(12332.123456,4) | format(12332.1,4) | format(12332.2,0) |
+------------------------+-------------------+-------------------+|
12,332.1235            | 12,332.1000       | 12,332            |
+------------------------+-------------------+-------------------
+1 row in set (0.00 sec)

mysql> 
uxdb=# select format(12332.123456,4),format(12332.1,4),format(12332.2,0);
错误:  函数 format(numeric, integer) 不存在第1行select format(12332.123456,4),format(12332.1,4),format(12332... 
^提示:  没有匹配指定名称和参数类型的函数. 您也许需要增加明确的类型转换.
uxdb=#

测试用例： 
补0、补小数点
select format(12332,4);
select format(12332.,4);
select format(12332.123,4);

四舍五入：
select format(12332.123446,4);
select format(12332.123456,4);

select format(12332.123486,0);


实现函数：
1、
SELECT CAST(135.1235 as DECIMAL(18,3));
2、
补0、补小数点
select round(12332,4);
select round(12332.,4);
select round(12332.123,4);

四舍五入：
select round(12332.123446,4);
select round(12332.123456,4);

select round(12332.123486,0);

round不支持以下功能：
如果以数字开头，则将开头的数字部分转为数字。
如果不能转为数字，则按照 0 处理。

测试用例：

SELECT
    FORMAT(111111, 2),
	FORMAT(111111., 2),
    FORMAT(111111.111, 2),
    FORMAT(111111.111, 0),
    FORMAT('111111', 2),
	FORMAT(12332.123446,4),
	FORMAT(12332.123456,4),
    FORMAT(NULL, 2);

2022-11-29
FORMAT函数实现：

函数分析：
1、输出格式化结果#,###,###.##
2、输出结果为字符串
3、第三个参数，受lc_time_names值的影响，影响小数点、千位分隔符和分隔符之间的分组；
但lc_time_names值不影响FORMAT()的结果

设置千位分隔符：
\pset numericlocale		//numeric设置千位分隔符

CREATE OR REPLACE FUNCTION ux_catalog.format(NUMERIC, INTEGER)
RETURNS text AS
$$
declare 
	result  text;
begin
if $1 is NULL or $2 is NULL then
	return 'NULL';
end if;
        SELECT ux_catalog.round($1,$2)::text into result;
return result;
end;
$$LANGUAGE pluxsql;





CREATE OR REPLACE FUNCTION ux_catalog.format(NUMERIC, INTEGER)
RETURNS text AS
$$
declare 
	result  text;
begin
        SELECT ux_catalog.round($1,$2)::text into result;
return result;
end;
$$LANGUAGE pluxsql STRICT;


create table DemoTable
(
Amount numeric
);
insert into DemoTable values(95868685.50);
select format(Amount,2) from DemoTable;


千位分隔符实现：


for i in input_str:
    if input_str[lenth] == '.':
        break
    lenth += 1

if lenth % 3 == 0:
    pos_separator = 3
else:
    pos_separator = lenth % 3

for i in range(0, lenth):
    if i == pos_separator:
        output_str += ',' + input_str[i]
        pos_separator += 3
    else:
        output_str += input_str[i]

output_str += input_str[lenth:]





char_length			//获取字串长度


CREATE OR REPLACE FUNCTION ux_catalog.format(NUMERIC, INTEGER)
RETURNS text AS
$$
declare 
	result  text[];
	output_str text[];
	lenth int := 0;
	len int := 0;
	pos_separator int;
	i int;
begin
SELECT ux_catalog.round($1,$2)::text into result;
SELECT char_length(result) into len;
for i in 1.. len loop
    if result[lenth] == '.' then
        exit;
	end if;
    lenth:=lenth+1;
end loop;
if lenth % 3 == 0 then
    pos_separator = 3;
else
    pos_separator := lenth % 3;
end if;

for i in 1.. lenth loop
    if i == pos_separator then
        output_str :=output_str + ',' + result[i];
        pos_separator :=pos_separator + 3;
    else
        output_str :=output_str + result[i];
	end if;
end loop;
output_str :=output_str + result[lenth];

return output_str;
end;
$$LANGUAGE pluxsql;



format_numeric_locale



setDecimalLocale

LC_NUMERIC						//UXLC_localeconv

lc_numeric 设置local				//对应变量全局locale_numeric


{ oid => '3824', descr => 'convert numeric to money',				//numeric_cash对numeric进行处理，返回money
  proname => 'money', provolatile => 's', prorettype => 'money',
  proargtypes => 'numeric', prosrc => 'numeric_cash' },


numeric_to_char
	


coerce_to_target_type

ParseFuncOrColumn
	func_get_detail
		func_select_candidate

调试函数：
(gdb) p *(A_Const *)((FuncCall *)expr)->args->head->data
$10 = {type = T_A_Const, val = {type = T_String, val = {ival = 38330192,
      str = 0x248df50 "11111"}}, location = 14}
(gdb) p *(A_Const *)((FuncCall *)expr)->args->head->next->data




		/* 函数为format，且函数第二个参数为UNKNOWNOID时，进行对该字段类型进行强制转换 */
		if ((0 == strcmp(NameListToString(funcname), "format")) && (nargs == 1 && argtype == UNKNOWNOID))
			arg = coerce_to_target_type(pstate, arg,
										argtype, TEXTOID,
										-1, COERCION_EXPLICIT,
										COERCE_EXPLICIT_CAST, -1);
		argtype = exprType(arg);
		
2022-12-2

drop table if exists y1 cascade;
create table y1(id1 serial,id2 timestamp default now() on update current_timestamp,id3 timestamp on update now(),id4 int GENERATED ALWAYS AS (1 + 2) STORED);
SHOW COLUMNS FROM y1;


.net配置后端链接：
1、app.config配置
查看区域化项目

2、cs后端配置：

代码如下：
string myschool = System.Configuration.ConfigurationManager.ConnectionStrings["ConnStr"].ToString();
MessageBox.show(myschool);
NuxsqlConnection conn = new NuxsqlConnection(myschool);

try
{
	conn.Open();
	Console.WriteLine("数据库连接成功!");
	Console.ReadLine();
}




2022-12-2
rac数据库启动
1、启动corosync：
进入路径：
/home/uxdb/corosync/sbin
sudo ./corosync -c ../etc/corosync/corosync.conf

2022-12-05
930考试：
1、考题位置：   
svn|||   40.部门管理\03.产品服务部\05.专题记录\03.自强考试备考\

2、代码上传位置
930考试分支  origin/support930_examination   基于上次送测版本 切出的考试分支     
每个人领到的题 都要在下周三(12/8)以前进行上传  设计文档 代码上传(svn： 40.部门管理\01.产品研发部\08.930\02.930考试）

3、我的考试题
4-3 实现记录表存储信息查询工具
4-4 增加接口返回错误原因格式化文本输出
2-2 实现对数据导入和数据查询的关键词替换


4-3 实现记录表存储信息查询工具

实现步骤：
1、获取表数据文件位置；
2、获取表的长度；
3、获取每条记录tuple在文件中的位置和长度；
4、如果为大字段，指明大字段的存储情况；


1、
ux_relation_filepath			//获取表路径
2、
ux_relation_size				//获取表大小
3、

测试语句：
create table FixSizeTable
(
sno CHAR(20),
sname CHAR(20),
height INT
);

create table VarSizeTable
(
sno  VARCHAR(20),
sname VARCHAR(20),
sex  CHAR(20)
);

insert into FixSizeTable values('1', 'zhangsan', 1);

insert into FixSizeTable values('2', 'lisi', 2);

insert into FixSizeTable values('3', 'wangwu', 3);


insert into VarSizeTable values('1', 'zhangsan', 'M');

insert into VarSizeTable values('2', 'lisi', 'W');

insert into VarSizeTable values('3', 'wangwu', 'M');



内核代码分析：
tuple获取：

1）、页page	（块对应结构体：PageHeaderData）
页中的pd_linp 即上图中的 line-pointer，可变长度的数组，与元组一一对应，用来存储每一个元组在当前page内部的起始偏移地址
pd_linp的数据结构定义：
typedef struct ItemIdData
{
	unsigned	lp_off:15,		/* tuple位置（tuple在块中的起始位置） */
				lp_flags:2,		/* state of item pointer, see below */
				lp_len:15;		/* tuple长度（tuple的总长度（HeapTupleData + HeapTupleHeaderData + data area）） */
} ItemIdData;

2）、元祖（tuple对应的结构体：HeapTupleData）

1、元组主要由三部分组成
除了 t_data 之外的 HeapTupleData，t_data 也就是 HeapTupleHeaderData，还有一部分就是 实际的data area。

2、HeapTupleData 中的len = HeapTupleHeaderData + data area的长度，
t_self 标识当前 tuple 所处的 page 位置；


typedef struct HeapTupleData
{
	uint32		t_len;			/* header + data的长度(不包含HeapTupleData的长度) */
	ItemPointerData t_self;		/* 当前元组所处的页的位置（包含block-number 以及 page内的offset，也就是表文件中真实tuple的位置） */
	Oid			t_tableOid;		/* table the tuple came from */
	HeapTupleHeader t_data;		/* -> tuple header and data */
} HeapTupleData;

struct HeapTupleHeaderData
{
	union
	{
		HeapTupleFields t_heap;
		DatumTupleFields t_datum;
	}			t_choice;

	ItemPointerData t_ctid;		/* current TID of this or newer tuple (or a
								 * speculative insertion token) */

	/* Fields below here must match MinimalTupleData! */

	uint16		t_infomask2;	/* number of attributes + various flags */

	uint16		t_infomask;		/* various flag bits, see below */

	uint8		t_hoff;			/*  标识整个header + 后面的bit占用的偏移(tuple头的长度)  */

	/* ^ - 23 bytes - ^ */

	bits8		t_bits[FLEXIBLE_ARRAY_MEMBER];	/* bitmap of NULLs */

	/* MORE DATA FOLLOWS AT END OF STRUCT */
};

tuple存储内核分析：
https://www.cnblogs.com/flying-tiger/p/8029941.html

pg的页tuple从文件末尾向开头分配

text_to_cstring		//text转char
cstring_to_text		//char转text

获取块信息：
通过创建插件pageinspect，获取块元组详细信息：
create extension pageinspect;


wal日志：

1、相关问题单
108463、


防疫：
1、发热：布洛芬片
2、发热、流鼻涕、鼻塞、打喷嚏等：复方氨酚烷
3、咽干咽痛：地喹氯铵含片
4、咳嗽咳痰：
按柠流肠溶胶囊
羚甲司坦口服溶液
福多司坦口服溶液
氨澳特罗口服溶液
氢澳酸右美沙芬胶囊/口服溶液
福尔可定口服溶液


2022-12-15

同步guc参数：
问题：
1、有些guc参数不能进行同步

guc参数分析：

UXC_INTERNAL		//alter命令无法修改
UXC_POSTMASTER		//alter命令可以修改，但需要重启后生效
UXC_SIGHUP			//alter命令可以修改，但需要reload或重启生效
UXC_SU_BACKEND		//alter命令可以修改，但需要重启后生效
UXC_BACKEND			//alter命令可以修改，但需要重启后生效
执行ux_reload_conf可以生效：
UXC_SIGHUP
UXC_SUSET			
UXC_USERSET			

guc参数分析：
https://blog.csdn.net/qq_21127313/article/details/72765786



AlterSystemSetConfigFile			//alter system入口

测试步骤：
alter system set max_connections TO 100;
alter system set lock_timeout TO 2;
select * from ux_replication_guc;

备库代码流程：
StartupXLOG
	ReadRecord
		XLogReadRecord
			ReadPageInternal
				XLogPageRead




walreceiver进程：
sigusr1_handler()->StartWalReceiver()->AuxiliaryProcessMain()->WalReceiverMain()->walrcv_receive()

startup进程：
PostmasterMain()->StartupDataBase()->AuxiliaryProcessMain()->StartupProcessMain()->StartupXLOG()




xlog.c:7873
heap_redo






gdb屏蔽信号调试：
handle SIGUSR1 nostop
b heap_xlog_insert



代码备份：
1、
		int ret = -1;
		char *gucname = NULL;
		bool isnull;
		if (SPI_connect() < 0)
			ereport(ERROR,
					(errcode(ERRCODE_TRIGGERED_ACTION_EXCEPTION),
					 errmsg("SPI_connect failed")));
		ret = SPI_execute("select ux_relation_filepath('tt');", false, 0);
		//ret = SPI_exec("select ux_relation_filepath('tt');", 0);
		if (ret != SPI_OK_SELECT)
			elog(ERROR, "SPI_execute failed !");
		gucname = text_to_cstring((const text *)SPI_getbinval(SPI_tuptable->vals[0],
															  SPI_tuptable->tupdesc,
															  1, &isnull));
		if(NULL != gucname)
		elog(WARNING, "gucname = %s!", gucname);
		SPI_finish();

2、
	// if (record->blocks->rnode.relNode == ReplicationGucRelationId)
	// {
	// 	int ret = -1;
	// 	SPIPlanPtr spiplan;
	// 	char *gucname = NULL;
	// 	bool isnull;
	// 	char questring[128] = {0};
	// 	if (SPI_connect() != SPI_OK_CONNECT)
	// 		elog(ERROR, "SPI_connect failed");
	// 	strcpy(questring, "select name from tt;");
	// 	spiplan = SPI_prepare(questring, 0, NULL);
	// 	if (spiplan == NULL)
	// 		elog(ERROR, "SPI_prepare failed for query_string");

	// 	ret = SPI_execute_plan(spiplan, NULL, NULL, true, 0);
	// 	if (ret != SPI_OK_SELECT)
	// 		elog(ERROR, "failed to execute query_string");
	// 	gucname = text_to_cstring((const text *)SPI_getbinval(SPI_tuptable->vals[0],
	// 														  SPI_tuptable->tupdesc,
	// 														  1, &isnull));
	// 	if (NULL != gucname)
	// 		elog(WARNING, "gucname = %s!", gucname);
	// 	if (SPI_finish() != SPI_OK_FINISH)
	// 		elog(ERROR, "SPI_finish failed");
	// }




StartupXLOG






walreceiver进程和startup进程
https://blog.51cto.com/u_15316394/5004211

通过系统表方式：
目前无法实现，由于备机在应用系统表数据时，处于恢复状态，在恢复状态下，无法执行alter system，故该方案不可行，
目前通过工具，调用libuxsql方式实现；

获取流复制备机ip：
select client_hostname from ux_stat_replication ;


guc主备可配置筛选：


执行ux_reload_conf可以生效：
UXC_SIGHUP
UXC_SUSET			
UXC_USERSET	

ssl
ssl_passphrase_command_supports_reload


可同步参数：
enable_audit
ssl
ssl_passphrase_command_supports_reload
ssl_prefer_server_ciphers


安全属性：

ssl
ts_size_threshold
enable_resource_limit

ux_security.password_length
ux_security.login_idle_timeout
ux_security.login_error_lock_times
ux_security.role_password_lifetime
ux_security.login_error_lock_duration
ux_security.password_condition_digit
ux_security.password_condition_symbol
ux_security.password_condition_simple
ux_security.password_condition_user
ux_security.password_condition_lower_case_character
ux_security.password_condition_upper_case_character

mpp发送命令：

问题单：
174367

接口：
ExecuteCriticalRemoteCommand






2022年工作总结：
1季度：
1、安全重构2114s插件、工具适配，并进行任务分配、工具自测；
2、协助跟踪安全组内成员完成安全重构相关问题；
3、解决2114s安全相关问题单；
4、redmine问题单处理（11+9）
5、现场问题处理（2+4）
6、自强考试

#129390、#130692、#131113、#131788、#132282、#132331、#132671、#132965

1月：
对外（现场）支持：
2、#110025：软江项目支持：uxpool core问题
5、自强tpcc测试支持

2114s工具、插件适配：
1、#127403：2114s插件、工具适配进度跟踪、问题讨论；
4、#129390:ux_cron、repmgr插件提示模式不存在，ux_cron extension插件未加载等问题
3、#130692：createuser 权限问题分析Permission denied：
repmgr解决安全功能下uxsmo超级用户问题
安全兼容版 ux_hint_plan插件问题整理
#131113：orafce中隐式转换结果不对
#131788：ver2.1.1.4s :安全集群，auditlogger 进程被kill掉
132282:安全集群，logger 系统日志进程被kill掉之后，存在残留进程；
#132331：ver2.1.1.4s：创建排序规则指定locale失败
#132671：2114s安全兼容模式下，创建ux_cron插件，提示uxdb数据库不存在
#132087：插件、工具自测
安全兼容 make check_32_compatible_security自测用例存在审计进程退出问题，
定位与关闭其他子进程审计管道读端有关，具体原因待分析
#132965：repmgr注册主节点提示"repmgr" extension is not available
repmgr故障切换未成功原因

review以下问题单：
review #129215问题单
#128644:解决兼容模式下char类型不可用
#129229：mysql_fdw、oracle_fdw、tds_fdw、uxdb_fdw插件报关键字为非法选项的错误。
#129207 解决安全兼容版中，dict_xsyn、file_fdw、unaccent插件关键字不识别问题
3、检视问题单 #129783ux_stat_statements、ux_probackup、dblink工具及插件问题修复
1、跟踪127403问题单进度；
2、检视问题单129783、129229；
review 130147 代码







2月：

对外支持：
8、分析repmgr故障切换未成功原因（已完成）

1、131788:ver2.1.1.4s :安全集群，auditlogger 进程被kill掉之后，不会自动拉起（已完成）
2、132282:安全集群，logger 系统日志进程被kill掉之后，存在残留进程；（已完成）
3、#132331：ver2.1.1.4s：创建排序规则指定locale失败（已完成）
4、#132671：2114s安全兼容模式下，创建ux_cron插件，提示uxdb数据库不存在（已完成）
5、#132087：插件、工具自测（已完成）
6、安全兼容 make check_32_compatible_security自测用例存在审计进程退出问题
7、#132965：repmgr注册主节点提示"repmgr" extension is not available（已完成）

9、自强考试2-1数据库内置函数功能裁剪及功能修改实现、
2-2实现对数据导入和数据查询的关键词替换、
3-5根据数据库系统负载给出创建分区建议；
考试题目方案分析及编码（正在进行）

3月：
对外支持：
#129384：旋极军工项目打包支持
#135974 河南移动中标项目支持
#138262 中防生态适配打包


#134746 ：修改max_pool参数值为异常时，uxpool可以正常停止
#134875 ：安全兼容模式下，控制台uxpool相关命令报错
#134743 ：安全兼容模式下，控制台show部分uxpool参数报错
#135100：主环境断电后，uxpool备库生升主库异常
#134730：资源管理调研
#125828:28所军创项目支持，分析where in语句查询变慢原因
安全重构迭代四相关问题单自测
#135974:调研oracle set_module函数
#136538  repmgr多次主备切换问题
#137009：where in问题分析
自强考试准备


2季度：
1、河南移动兼容多个函数支持
2、对外支持项目15个
3、redmine问题单处理19个
4、研发部培训1次


4月：
1、河南移动兼容多个函数支持
2、对外支持项目5个
3、问题单9个
4、研发部培训1次

对外支持：
#138851 add_months、months between、last day、to char等函数支持
#135974:listagg、grouping_id、regexp_like、 pg_backend_pid、chartorowid、userenv等函数功能支持


#136773、#138851、#135974、#138262、#136367、#138648、#138851、#125233、#139594、
#140293、#141388、#143313、#139826、#144088、#148035、#148163、#146359等

1、以下工作已全部完成:
#136773: 进行自强考试
#138851 add_months、months between、last day、to char等函数支持
#135974:listagg、grouping_id、regexp_like、 pg_backend_pid、chartorowid、userenv等函数功能支持
#135974 河南移动中标项目支持提作符类型问题
#138262 中防生态适配打包
#136367 dbms_utility.get hash_value功能支持
#138648 沈抚项目支持，分析系统环境报错问题
#138851 trunc、decode、nvl、mod等函数支持
#125233: 开发文档-安全功能规范编写
#139594:to date函数参数1使用数字报错
#140293: nhibernate + spring mvc整合demo编写
进行uxpool研发部培训

5月：
1、对外支持项目3个
2、问题单4个

1)主要完成工作:
#139594:to_date函数参数1使用数字报错
#140293:nhibernate + spring mvc整合demo编写（JYJT涉密）
#141388:运算符调用时支持<=，不支持《，两个运算符中间含有空格，在调用时提示“语法错误在“="或附近的
#143313:top关键字，建表语句字段是关键字，在创建表的时候失败
#139826:项目打包支持
分析验证numeric null问题
#144088: windowsxp环境编译uxdb数据库

6月

1、对外支持项目7个
2、问题单6个

repmgr虚拟ip重启后无法绑定问题分析
#139826:706涉密项目问题分析
别名加不加as都无法插入，需实现该语法功能
Npgsql，主键、外键索引报错卡住问题:
#139826:insert 使用别名不加as，且字段引用别名
504门户网站php驱动适配
#148035: oracle服务退出，uxdb定时任务执行handel住未退出（贵州省疾控中心）
#148163:dotnetcore 缺动态库，原dotnet依赖库不支持（西安公共交通）
#146359:706项目合入层次查询相关代码，并打包验证功能
#139826:706 start with代码合入，并打包验证



3季度：
1、河南移动性能分析优化
2、tpcc改造支持验证
3、对外支持项目11个
4、进行部门分享

7月

#135974:河南移动与2114基线分支数据库tpcc性能比对
#151152:河南移动分支移植pg14新特性代码:
#151152:空闲连接性能下降问题分析
验证rowid对insert语句的影响
验证uxbouncer连接池效果
验证改造后的idbc连接池功能
华能区块链项目支持协助;
#151917:空闲连接性能下降问题分析 验证修改后的idbc连接池功能:
#150671河南移动稳定性问题分析，验证目前测发现主要是机器磁盘性能查引起
#151917:河南移动现场性能问题分析:
uxpool功能代码查看

8月
重庆传最、9601项目、陕西军民融合信创、中船WRT项、博华jg、UXDB PATCH版本维护、沈抚项目、

1、#135974解决现场varchar到text隐士转换性能问题1#135974:
2、#135974:对现场添加索引进行优化，有些sl组合索引比单条索引执行效率高，有些单条索引执行效率高
3、#135974:对之前优化遗漏的sql进行优化
4、#135974:筛选执行次数高的sql进行预热
5、河南移动性能问题分析讨论:
河南移动sql整理优化，查看sql类型，本地构造验证分析;
6、#154893:csn性能指标测试，csn代码移植
7、#154893:解决编译报错csn代码编译报错
8、#154893:整理select&insert平均时间在10ms以内的sql，对sal平均时间性能问题进行分析
9、uxpool部门培训资料准备&&分享
10.157558: decode代码移植
11、#80809:重庆传最
12、#155646:陕西军民融合信创项目(打包)
13、#154893: csn性能指标测试
14、#151152:海量空闲连接性能下降
15、#106431:中船WRT项(打包)
16、进行uxpool的watchdog部门培训
17、了解学习explain的功能:

9月
#135974:河南移动性能分析组织会议讨论
#135974:河南移动性能查看pg12之后性能优化情况
#135974:河南移动性能分析验证idbc对性能影响情况
#159080:博华jg打包
#159256:numeric like操作符不存在
#155333兼容模式repmgr适配
#158996:兼容模式下创建物化视图失败
#158998:兼容模式下删除where条件带列名为小写或大小写混合字符串删除成功
#159696:兼容模式，jdbc绑定参数，固定格式空串+null
#137770:uxdb patch版本维护
#137770: 2114 patch ky v10 + x86打包
#157170:2114p uos系统arm平台编译打包
#135974:河南移动性能优化sql整理
#138648:沈抚项目uxpoolcore问题分析
#157170:9601项目编译打包
查看学习explain 性能分析方法
参加uXSync同步工具介绍会议
参加uxmpp hash分布部门分享

4季度：
1、云上贵州功能开发3个
2、ISCCC测试功能开发1个
3、redmine 问题单处理19个
4、对外支持项目9个
5、930考试支持

10月

1、#138648:沈抚项目uxpoolcore问题分析
2、#162414:删除模式未级联删除该模式同义词下存在其他模式依赖的同义词
3、#162962: time with time zone与int类型数字运算，报错: operator does not exist: time with time zone + integer
4、华能区块链项目对外支持
5、熟悉正则表达式的用法:
6、#125233:调查ux dump南计信息
7、#164747:[不带安全属性的用户输入]测试项要求
8、#164771:事件触发器功能移植

11月


207入围项目 mips平台层次查询问题(该问题系环境问题，暂未解决)
东北证券带外管理系统建设项目支持(已完成)
3、#166572: 针对普通用户使用dump导出，普通用户只能导出有权访问的数据(已完成)
4、华能区块链项目支持(已完成)
5、#166877:单节点访问，会话被锁定;ssl证书到期，记录日志和审计表(已完成)
6、#167428:主备同步参数修改的操作(已完成
7、ISCCC测试项目支持gmssl脚本修改(已完成)
8、ISCCC测试用例补充验证(已完成)
9、#125233:ISCCC测试项目支持，tpce编译调试(已完成)
10、#164410:主备同步参数修改的操作(已完成)
11、#164410:207入围项目问题支持(已完成)
12、pg手册与pg内核执行计划代码浏览
13、#169050:授权状态需要显示security，方案+修改代码+打包测试打包(已完成)
14、#169617:兼容mysql功能SHOW COLUMNS FROM table完成50%
15、repmgr日志回滚调研

12月

#169617:兼容mysql功能SHOW COLUMNS FROM table
#170076:兼客mysgl功能SHOWINDEX FROM table
#170706;兼容mysl函数FORMAT
#170953:SHOW COLUMNS的Null与Key列显示值大小写与mysql不一致
#170964:UNIQUE索引不能包含NULL值并且表中没有PRIMARY KEY，SHOW COLUMNS的key列显示错误
支持.net配置，链接报错
#170706:FORMAT函数与系统函数冲突问题
#170960: mysql模式，SHOW COLUMNS的多列主键时，key列显示错误
#170990: mysql模式，当列包含自增，on update以及标识列时，SHOW COLUMNS的默认值列显示与mysg不-致，且Extra列功能未实现
#170939: mysql模式，SHOW COLUMNS创建表字段中包含大小写混合与汉字时，Field列uxdb带双引号，与mysal不-致
#171755:930考试支持
#171158:主备环境，主库修改配置参数并进行ux reload conf0，可以同步到备库





rebrand路径：
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-tools/scripts/bash/rebrand






redis_fdw
https://blog.csdn.net/seapeak007/article/details/54340839

安装redis：

sudo yum -y install hiredis-devel.x86_64


redis_fdw使用简介:
1、创建表categories记录不同分类下条目的数量

CREATE TABLE categories
(
  catid character varying(32) NOT NULL,    --主键
  cname character varying(64),    --分类名称
  nums integer,    --条目数量
  CONSTRAINT categories_pkey PRIMARY KEY (catid)
);

2、CREATE EXTENSION redis_fdw;    --创建redis_fdw扩展

3、
创建需要关联的redis服务器
CREATE SERVER redis_server
    FOREIGN DATA WRAPPER redis_fdw
    OPTIONS (address '127.0.0.1', port '6379');
	
4、创建redis中存储catid/nums映射的虚拟表
CREATE FOREIGN TABLE rd_categories1 (key text, val text)
            SERVER redis_server
            OPTIONS (database '0');


5、创建触发器:

CREATE OR REPLACE FUNCTION public.insert_new_item()
  RETURNS trigger AS
$BODY$  
begin
    insert into rd_categories values(NEW.catid, 0,1);
    return NEW;  
end  
$BODY$
  LANGUAGE pluxsql VOLATILE
  COST 100;
ALTER FUNCTION public.insert_new_item()
  OWNER TO uxdb;
CREATE TRIGGER new_category
  AFTER INSERT
  ON public.categories
  FOR EACH ROW
  EXECUTE PROCEDURE public.insert_new_item();

6、创建用户映射：
CREATE USER MAPPING FOR PUBLIC SERVER redis_server OPTIONS ( password 'secret');

7、
测试:
insert into categories values('123', 'ces', 0);    --插入一条数据

在redis里查看：
[root@uxdb1 bin]# ./redis-cli -p 6379
127.0.0.1:6379> keys *
"123"
127.0.0.1:6379> get 123
"0"

redis不带触发器：


CREATE EXTENSION redis_fdw;    --创建redis_fdw扩展
CREATE SERVER redis_server
    FOREIGN DATA WRAPPER redis_fdw
    OPTIONS (address '127.0.0.1', port '6379');
CREATE USER MAPPING FOR PUBLIC SERVER redis_server OPTIONS ( password 'secret');
CREATE FOREIGN TABLE rd_categories (key text, val text)
            SERVER redis_server
            OPTIONS (database '0');

CREATE EXTENSION redis_fdw;
CREATE SERVER redis_server
    FOREIGN DATA WRAPPER redis_fdw
    OPTIONS (address '192.71.0.139', port '6379');
CREATE USER MAPPING FOR PUBLIC SERVER redis_server OPTIONS ( password 'secret');
CREATE FOREIGN TABLE rd_categories (key text, val text) SERVER redis_server OPTIONS (database '0');
insert into rd_categories values ('a', '111');
select * from rd_categories;


insert into rd_categories values('fcc', '1');

在redis里查看：
[root@uxdb1 bin]# ./redis-cli -p 6379
127.0.0.1:6379> keys *
"123"
127.0.0.1:6379> get 123
"0"


oracle_fdw:
create extension oracle_fdw;
create server osdba_fdw foreign data wrapper oracle_fdw options (dbserver '//192.71.0.244:1521/orcl');
CREATE USER MAPPING FOR uxdb SERVER osdba_fdw OPTIONS (user 'C##ora_tkb', password '123456');
CREATE  FOREIGN TABLE "test_tab" (id int,name varchar(100)) SERVER osdba_fdw OPTIONS (table 'TEST_TAB');
select * from test_tab;
INSERT INTO test_tab select generate_series(1,10),'bb';
select * from test_tab limit 5,10;




fdw（外部数据包装器）
https://www.jiangguo.net/c/wyW/2e5.html


https://github.com/pg-redis-fdw/redis_fdw
https://github.com/redis/hiredis


Latest commit number:5abc858e03e4a6946ef75983aebe4d47268c4c28




#175604:redis_fdw适配,The branch that adapts redis_fdw is REL_12_STABLE,Latest commit number:5abc858e03e4a6946ef75983aebe4d47268c4c28


2023-2-2


1、mpp高可用修改了什么特性，master和worker都看下
2、这次uxdb使用2115B
3、

分支代码：
support/#129384


http://192.30.1.2/uxdb/uxdb-security_reframe/%E4%BC%98%E7%82%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E5%8A%9F%E8%83%BD%E6%89%8B%E5%86%8C%20V2.1/html/data-column.html#wallet


加密：

加密文档：
svn\30.项目\02.通用版

1、多个列加密时，加密系统表数据如何存储；
2、刷盘时，申请一个页原因；
3、密钥与根密钥如何进行解密；


2023-2-17



./build.sh --license=commercial --nouxfs

php编译：利于php-7.2.34版本
进入php-7.2.34主目录，执行以下命令：


./configure --prefix=/home/uxdb/uxdbinstall/driver/php

编译pdo_uxsql.so：
进入路径php-7.2.34/ext/pdo_pgsql
执行以下命令：
/home/uxdb/uxdbinstall/driver/php/bin/phpize
aclocal					//存在问题，可跳过aclocal、autoconf
autoconf
./configure --with-php-config=/home/uxdb/uxdbinstall/driver/php/bin/php-config --with-uxsql=/home/uxdb/uxdbinstall/dbsql/bin
arm编译：
./configure --with-php-config=/home/uxdb/uxdbinstall/driver/php/bin/php-config --with-pdo-uxsql=/home/uxdb/uxdbinstall/dbsql/bin
生成路径
ext/pgsql/.libs/pdo_uxsql.so

编译uxsql.so：
进入路径php-7.2.34/ext/pgsql
执行以下命令：
/home/uxdb/uxdbinstall/driver/php/bin/phpize
aclocal
autoconf
./configure --with-php-config=/home/uxdb/uxdbinstall/driver/php/bin/php-config --with-uxsql=/home/uxdb/uxdbinstall/dbsql/bin




2023-02-21

已修复版本：
REL_14_BETA1

已修复版本基版本：
REL_13_BETA1


时间线：
7966b7980138ebcee7ae986ebcc393aea38a35c0  --》e4f9737fac77a5cb03a84d1f4038d300ffd28afd


198b3716dba68544b55cb97bd120738a86d5df2d		2021-03-31 7:12（未修复）

9ee7d533dacf8594057ced2d016250f09056c284		2021-03-31 7:46（未修复）

65158f497a7d7523ad438b2034d01a560fafe6bd		2021-03-31 8:01（未修复）

055fee7eb4dcc78e58672aef146334275e1cc40d		2021-03-31 23:09（未修复）

86dc90056dfdbd9d1b891718d2e5614e3e432f35		2021-03-31 23:52(已修改)






ExecInitModifyTable


ExecModifyTable

内存未释放问题：

记录其他问题：
cpu利用率超过90%

返工计划和执行UPDATE和DELETE。

这个补丁做了两组密切相关的更改:

1.对于UPDATE, ModifyTable节点的子计划现在只交付已更改列的新值(即，在查询的SET子句中计算的表达式)以及行标识信息(如CTID)。ModifyTable必须重新获取原始元组，
以合并任何未更改列的旧值。这样做的核心优势是，在继承或分区目标关系的所有表中，更改后的列是一致的，而其他列可能不是。当UPDATE涉及连接时，第二个优点是需要通过计划树的数据更少。
当然，缺点是需要额外获取每个要更新的元组。然而，这在上下文中似乎是非常自由的;即使是最坏情况的测试也没有显示它对总查询成本的增加超过百分之几。在某些情况下，
将重新获取与元组访问结合起来可能会很有趣，ModifyTable必须这样做才能标记旧元组死亡;但这将需要大量的重构，似乎不会买那么多，所以这个补丁没有尝试它。

2.对于继承的UPDATE/DELETE，我们不再为每个目标关系生成一个单独的子计划，而是生成一个与SELECT计划完全相同的子计划，然后将ModifyTable置于子计划之上。
为了让ModifyTable知道给定的输入行指的是哪个目标关系，将向行标识信息添加一个表类垃圾列。这样就摆脱了inheritance_planner()这种可怕的hack，
在存在许多unprunable 的目标关系的情况下消除了O(N^2)计划成本和内存消耗。

点2当然需要点1，这样就有了子计划返回的非垃圾列的统一定义。
但是，如果我们想在分区层次结构中同时拥有普通表和外部表，就不能坚持对行标识垃圾列进行统一定义。因为不能让每个子表都有自己的行标识列，
所以这个补丁包含了将类似的行标识列合并到subplan结果的一列中的条款。
特别是，我们可以将fdw通常用作行标识的整行Vars合并为一列，假设它们是RECORD类型。(不过，对于实际的复合Datums来说，使用表的行类型OID标记仍然是可以的。)

在这个补丁中还有更多的工作可以做，但现在似乎是可以接受的。

FDW作者应该注意以下几个API变化:

* AddForeignUpdateTargets()的参数列表已经改变，它必须使用的方法添加垃圾列到查询。调用add_row_identity_var()，而不是直接操作解析树。
你可能也需要重新考虑添加的内容。

* PlanDirectModify()现在必须稍微努力找到ForeignScan计划节点;如果外部表是分区层次结构的一部分，那么ForeignScan可能不是ModifyTable的直接子表。有关示例代码，请参阅postgres_fdw。

*要检查一个关系是否是目标关系，将其relid与root->parse->resultRelation进行比较已经不够了。
相反，根据需要检查all_result_relids或leaf_result_relids。



    update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
        );

update parted_tab set b = 'b'
from
  (select a from some_tab union all select a+1 from some_tab) ss (a)
where parted_tab.a = ss.a;
select tableoid::regclass::text as relname, parted_tab.* from parted_tab order by 1,2;

修改不全：
未修改
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/replication/logical/worker.c
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/executor/execIndexing.c

标记注释：
/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/executor/execPartition.c




/* #177670:Rework update 修改点不同记录 */
/* 
 * SHA-1: fb5883da86154c3126264bfd97b0cd6f293bcebd
 * Remove PartitionRoutingInfo struct.
 * 
 */
 
 
e1551f96e643a52a035c3b35777d968bc073f7fc


目前问题：
日期：2023/3/01
存储过程内存膨胀问题工作进展：

1、目前标准版除ux_pathman、uxdb_fdw还需要开发进行定位测试验证,其他功能基本验证正常，
2、兼容版还未进行验证，
预估1-2天完成以上问题；
3、
现场内存膨胀问题，目前已验证正常， 后面佳慧验证还有其他问题，明天佳慧是否可以用新包验证下新问题是否存在；
4、
然后明天测试就可以开始介入测试，具体新包提供时间看明天测试情况；




src/backend/executor/nodeModifyTable.c src/backend/nodes/equalfuncs.c src/backend/optimizer/util/appendinfo.c src/test/regress/compatible_testcase/expected/inherit.out src/test/regress/compatible_testcase/expected/insert_conflict.out src/test/regress/compatible_testcase/expected/partition_join.out src/test/regress/compatible_testcase/expected/partition_prune.out src/test/regress/compatible_testcase/expected/rowsecurity.out src/test/regress/compatible_testcase/expected/updatable_views.out src/test/regress/compatible_testcase/expected/update.out src/test/regress/compatible_testcase/expected/with.out

2023-03-03
逻辑复制
https://blog.51cto.com/2012ivan/2524740

1、
配置postgresql.conf

wal_level = logical

2、创建发布者

yangjie=# create table users(id int, name name);
CREATE TABLE
yangjie=# create publication pub1 for table users;
CREATE PUBLICATION
创建发布者pub1,并添加表users.
另一种用法是添加数据库中所有用户表到发布者alltables:

create publication alltables for all tables;

3、另一个机器创建表users和订阅者

yangjie=# create subscription sub1 connection ‘host=192.71.0.139 port=5432 dbname=uxdb’ publication pub1;
NOTICE: created replication slot “sub1” on publisher
CREATE SUBSCRIPTION

创建订阅者时，表不会被复制，我们需要先自己创建这些表，如果没有发现本地表复制将会失败。

当发布者添加新表时，订阅者不能自动的获知，我们需要更新订阅者：

alter subscription sub1 refresh publication;

4、
为了逻辑复制能在下游节点正确执行UPDATE和DELETE，我们需要定义如何找到唯一行，这就是复制标识，默认情况下，复制标识将是表的主键，如果已经定义了主键，将不需要做任何动作，

alter table users add primary key(id);
发布者和订阅者都要执行

明确定义复制标识
yangjie=# alter table users replica identity using index users_pkey;

5、执行update、delete






p *(A_Const*)(((A_Expr*)(((SelectStmt*)((RawStmt *)raw_parsetree_list->head->data)->stmt)->whereClause))->rexpr)




2023-03-09

bit类型等于一个值的时候，不加引号，好改吗 。
create  table t1(id  bit);
select * from  t1  where id =1; 


bit类型：

mysql中bit类型一般都是使用整数类型表示，所以支持的bit位数最大只能是64位。而在pg中有专门的bit类型bit(范围1～83886080)，以及可变长度的bit类型varbit。

区别一：
插入值， mysql可以获取到， uxdb不能；





create  table t1(id  bit(3));
insert into t1 values(B'001');
insert into t1 values(B'010');
insert into t1 values(B'011');
insert into t1 values(B'100');
insert into t1 values(B'101');
insert into t1 values(B'110');
insert into t1 values(B'111');

select * from t1 where id = 2;
select * from t1 where id != 2;
select * from t1 where id > 2;
select * from t1 where id >= 2;
select * from t1 where id < 2;
select * from t1 where id <= 2;

select * from t1 where id = 8;
select * from t1 where id != 8;
select * from t1 where id < 8;
select * from t1 where id <= 8;
select * from t1 where id > 8;
select * from t1 where id >= 8;


select * from t1 where 2 = id;
select * from t1 where 2 != id;
select * from t1 where 2 > id;
select * from t1 where 2 >= id;
select * from t1 where 2 < id;
select * from t1 where 2 <= id;

select * from t1 where 8 = id;
select * from t1 where 8 != id;
select * from t1 where 8 < id;
select * from t1 where 8 > id;
select * from t1 where 8 <= id;
select * from t1 where 8 >= id;



copy vd_his_alarm from '/home/uxdb/uxdbinstall/dbsql/bin/vd_his_alarm_202302221655.csv' WITH csv header delimiter ',';

存储过程内存膨胀问题：

使用现场存储过程语句与数据，目前sql执行缓慢问题已解决，内存未释放问题正常；
但使用改造后的存储过程语句多次执行存在以下问题，且该问题必先：（改造存储过程语句中存在太多次update、delete）
问题一：存储过程语句执行第一次，内存从400MB增长200MB到600MB，之后每次增长10MB，第六次，内存增长翻倍（从600M变为1.2GB），后面再执行20多次，内存变化稳定在10M；
分析结果：
1、pg14和pg最新版本15.2也存在该问题；
2、通过查看统计信息， 存储过程访问共享内存比较频繁；
3、直接执行存储过程中的sql未复现问题一；
目前分析方法是通过调试内存上下文去查看内存释放问题，需要确定位置，
uxdb的内存都是通过内存上下文进行分配，需要调试内存上下文对于内存申请释放情况，分析内存泄露问题；


pg内存分配和操作系统内存分配：
https://www.modb.pro/db/486292


调用栈：
#0  BuildCachedPlan (plansource=0x2cf95c0, qlist=0x0, boundParams=0x1f23e40, queryEnv=0x0)
    at plancache.c:885
#1  0x0000000000a473d8 in GetCachedPlan (plansource=0x2cf95c0, boundParams=0x1f23e40,
    useResOwner=true, queryEnv=0x0) at plancache.c:1214
#2  0x000000000074b7c3 in _SPI_execute_plan (plan=0x1f5b140, paramLI=0x1f23e40, snapshot=0x0,
    crosscheck_snapshot=0x0, read_only=false, fire_triggers=true, tcount=0) at spi.c:2225
#3  0x0000000000748d6a in SPI_execute_plan_with_paramlist (plan=0x1f5b140, params=0x1f23e40,
    read_only=false, tcount=0) at spi.c:577
#4  0x00007f51fae53d59 in exec_stmt_execsql (estate=0x7ffd55b92e50, stmt=0x1f84ff8) at pl_exec.c:4170
#5  0x00007f51fae4fa19 in exec_stmt (estate=0x7ffd55b92e50, stmt=0x1f84ff8) at pl_exec.c:2040
#6  0x00007f51fae4f71b in exec_stmts (estate=0x7ffd55b92e50, stmts=0x1f6c2b8) at pl_exec.c:1931
#7  0x00007f51fae4f5cf in exec_stmt_block (estate=0x7ffd55b92e50, block=0x7f520d2adfc0)
    at pl_exec.c:1872
#8  0x00007f51fae4f818 in exec_stmt (estate=0x7ffd55b92e50, stmt=0x7f520d2adfc0) at pl_exec.c:1964
#9  0x00007f51fae4d327 in pluxsql_exec_function (func=0x1e906f0, fcinfo=0x7ffd55b93140,
    simple_eval_estate=0x0, atomic=false) at pl_exec.c:596
#10 0x00007f51fae47be8 in pluxsql_call_handler (fcinfo=0x7ffd55b93140) at pl_handler.c:269
#11 0x0000000000682e16 in ExecuteCallStmt (stmt=0x1e64108, params=0x0, atomic=false, dest=0x1e64708)
    at functioncmds.c:2474



/home/uxdb/uxdb_devel/uxdb-ng/uxdb-2.1/src/backend/utils/cache/plancache.c:1179			//CachedPlan


内存使用情况：




1、直接执行：
    update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
        );

存储过程：
create procedure tstprc_sa_sts_vehicle_alarm_day2(sts_time_str character varying)
    language pluxsql
as
$$
begin
    update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
        );
end;
$$;

2、直接执行：
update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.sts_time = '2023-02-19 12:00:00'::timestamp and ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
            where a.beg_gnss_time >= '2023-02-19 00:00:00'::timestamp
              and a.beg_gnss_time <= '2023-02-20 23:59:59'::timestamp
              and t.alarm_src is not null
        );

存储过程：
create procedure tstprc_sa_sts_vehicle_alarm_day(sts_time_str character varying)
    language pluxsql
as
$$
begin
update sa_sts_vehicle_alarm_day ad
    set total_alarm_num = 1 where ad.sts_time = '2023-02-19 12:00:00'::timestamp and ad.vehicle_id in (
            select vehicle_id from vd_his_alarm  a
                                       left join bi_inf_alarm_type t on a.alarm_code = t.alarm_code
            where a.beg_gnss_time >= '2023-02-19 00:00:00'::timestamp
              and a.beg_gnss_time <= '2023-02-20 23:59:59'::timestamp
              and t.alarm_src is not null
        );
end;
$$;

由于ux_opclass的opcintype对应ux_amop的左操作符类型，左操作符类型为int4，
左操作符int4对应的操作符类integer_ops, 操作符类对应的操作符族唯一，故左操作符为int4时，使用integer_ops操作符类

2023-03-22

bit与bool类型比较

create  table t1(id  bit(3), city char(60));
insert into t1 values(B'001', '111');
insert into t1 values(B'010', '222');
insert into t1 values(B'011', '333');
insert into t1 values(B'100', '444');
insert into t1 values(B'101', '555');
insert into t1 values(B'110', '666');
insert into t1 values(B'111', '777');

select * from t1 where id > 1::bool;
select * from t1 where id >= 1::bool;
select * from t1 where id = 1::bool;
select * from t1 where id != 1::bool;
select * from t1 where id <= 1::bool;
select * from t1 where id < 1::bool;

select * from t1 where id > 0::bool;
select * from t1 where id >= 0::bool;
select * from t1 where id = 0::bool;
select * from t1 where id != 0::bool;
select * from t1 where id <= 0::bool;
select * from t1 where id < 0::bool;

















